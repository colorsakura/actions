{"A计科工程/Clion":{"title":"Clion","links":[],"tags":["TODO","ide"],"content":"Clion\n\n参考链接"},"A计科工程/Fcitx":{"title":"Fcitx","links":["E临时笔记/Rime"],"tags":["TODO","fcitx"],"content":"FCITX\nFcitx 是一款全平台的输入法框架，拥有多种语言输入法。\nFcitx5 Chinese Add On\n自定义词库\nFcitx5 拼音输入法的词库是由 libime 这个库提供的。并且拼音和双拼使用同样的词库。\nArch 系统上，词库目录在 /usr/share/libime. 内容如下图。\n\n\nsc.dict : 通用拼音词库\nextb.dict  : CJK 扩展词库\nzrm.main.dict : 自然码码表词库 (非拼音词库)\n\n工具：libime_pinyindict txt 和 dict 互相转换工具\n格式：词 拼音 词频\n我 wo 0\n我们 wo&#039;meng 0\n\n\n                  \n                  Note\n                  \n                \n\n词频建议全部为 0, 不然无法转换，原因暂时不明。\n拼音不支持不正确的拼音格式。\n\n\n中英混合输入\n经过测试，这个功能是由 spell 这个选项提供的。\n用户输入历史\n位置：~/.local/share/fcitx5/pinyin\nFcitx5 Rime\nRime 输入法可自定义程度较高，同时学习成本也高。\n如果没有特殊的癖好，完全没有必要去折腾。就拼音输入法而言，\nRime 的上限也不一定高于 Fcitx5 自带的拼音输入法。\n自定义词库\n推荐使用雾凇拼音\npkill fcitx5\n# 删除默认设置\nrm ~/.local/share/fcitx5/rhyme\n# 克隆远程仓库\ngit clone github.com/iDvel/rhyme-ice.git ~/.local/share/fcitx5/rhyme\n不推荐去修改定制配置，雾凇拼音已经做的很好了，没有必要去浪费时间去折腾一个输入法。\n总结\n目前这两款输入法体验上没有较大的差距，Rhyme 支持中英混合输入。\n参考链接"},"A计科工程/GRPC":{"title":"GRPC","links":[],"tags":[],"content":""},"A计科工程/LLDB":{"title":"LLDB","links":[],"tags":[],"content":"LLDB Debug"},"A计科工程/Potplayer":{"title":"Potplayer","links":[],"tags":[],"content":"Madvr\nLavFilters"},"A计科工程/Wayland":{"title":"Wayland","links":[],"tags":[],"content":""},"A计科工程/gpg":{"title":"gpg","links":[],"tags":["linux","gpg","doc","TODO"],"content":"GPG 简明教程\n\nGPG 介绍\n创建密钥\n保存密钥\n恢复密钥\n更改密钥\n使用密钥"},"A计科工程/isync":{"title":"isync","links":[],"tags":[],"content":"isync 是一款文件同步软件，支持将文件同步到不同的云盘和存储服务上。"},"A计科工程/vim":{"title":"vim","links":[],"tags":["TODO","vim","Doc","neovim"],"content":"\nVIM 简易教程"},"A计科工程/下载工具":{"title":"下载工具","links":[],"tags":["TODO","aria2","windows","linux"],"content":"下载工具\n记录推荐使用的全平台下载工具\n\nqBittorrent\n参考链接"},"A计科工程/主机运维/Linux-定时任务":{"title":"Linux 定时任务","links":[],"tags":["TODO"],"content":"定时任务\n在 Linux 上，总有一些服务需要定时运行，来减少人力。Linux 有很多优秀的定时任务管理器.\r\n在 Arch 上，由于 systemd 是默认安装的，所以使用它提供 timer 来编写定时任务。\nsystemd 服务\n"},"A计科工程/主机运维/Linux-常用命令":{"title":"Linux 常用命令","links":[],"tags":["TODO","linux"],"content":"Linux 常用命令\n记录在 Linux 下一些常用的命令。\n\n终端运行任务\njobs, bg, fg 这三个命令由 shell 提供，不同的 shell 之间选项可能有一点区别。\n在终端下允许的命令，可以使用 Ctrl z"},"A计科工程/主机运维/Linux-软件清单":{"title":"Linux 软件清单","links":["A计科工程/主机运维/Linux/btrfs","A计科工程/主机运维/Linux/fdisk","A计科工程/主机运维/Linux/iproute2","A计科工程/主机运维/Linux/nftables","A计科工程/主机运维/Linux/smartdns","A计科工程/neovim"],"tags":["linux"],"content":"Linux 软件清单\n记录 Linux 桌面环境下常用的软件，除命令行软件外，其他软件必须完美支持 Wayland 才可以收录。\n\n文件系统\nbtrfs\n\nbtrfs-progs\nbtrfs-assistant\nsnapper\n\n分区工具\n\nfdisk\n\n网络\n\niproute2\nnftables\nsmartdns\nclash-meta\ndnsmasq\nwireshark\n\n蓝牙\n\nbluez\nbluez-utils\n\n桌面\nKDE:\nWM(sway):\r\n- sway\r\n- swayidle\r\n- swaylock\r\n- waybg\n字体\n\nfont-noto\nfont-noto-cjk\nttf-jetbrains-mono\nttf-twemoji\nttf-zhudou-sans\n\n音频\n\npipewire\npipewire-jack\n\n视频\n\nmpv\nvulkan-intel\nyt-dlp\n\n编辑器\n\nneovim\nvisual-studio-code\nzed\n\n其他\n\nalacritty\nanki\nblender\nfirefox\njetbrains 系列\nkitty\nobs studio\nobsidian\nqbittorrent\nthunderbird\nyazi\nzathura\nzotero\nmangohud(监控 FPS)\n\n与硬件相关\nCPU\nIntel:\r\n- intel-ucode\r\nAMD:\r\n- amd-ucode\nGPU"},"A计科工程/主机运维/Linux/Arch/Arch-安装手册":{"title":"Arch 安装手册","links":[],"tags":["TODO","linux","archlinux","tutor"],"content":"Arch 安装手册\n详细的安装教程请参阅：Arch Wiki 官方安装指南\n\n\n                  \n                  Note\n                  \n                \n\n一切以官方 wiki 为主，多看 wiki，多实践，才能有进步。\n\n\n\n一. 安装环境确定\n1.1 禁用 reflector 服务\n2020 年，archlinux 安装镜像中加入了 reflector 服务，它会自己更新 mirrorlist（软件包管理器 pacman 的软件源）。在特定情况下，它会误删某些有用的源信息。这里进入安装环境后的第一件事就是将其禁用。也许它是一个好用的工具，但是很明显，因为地理上造成的特殊网络环境，这项服务并不适合中国大陆用户启用。\n\n通过以下命令将该服务禁用：\n\nsystemctl stop reflector.service\n\n通过以下命令查看该服务是否被禁用，按下 q 退出结果输出：\n\nsystemctl status reflector.service\n同时，你可以使用 Tab 键在输入命令的时候对命令、参数或文件路径进行自动补全，提高效率的同时降低输入错误的风险。\n\n1.2 确认是否为 UEFI 模式\n禁用 reflector 服务后，我们再来确认一下是否为 UEFI 模式：\nls /sys/firmware/efi/efivars\n若输出了一堆东西（efi 变量），则说明已在 UEFI 模式。否则请确认你的启动方式是否为 UEFI。\n\n1.3 连接网络\n\n\n                  \n                  Note\n                  \n                \n\narchlinux 的安装**必须**要求网络环境。\n\n\n1.3.1 使用无线连接：\n使用 iwctl 进行连接：\niwctl # 进入交互式命令行\ndevice list # 列出无线网卡设备名，比如无线网卡看到叫 wlan0\nstation wlan0 scan # 扫描网络\nstation wlan0 get-networks # 列出所有 wifi 网络\nstation wlan0 connect wifi-name # 进行连接，注意这里无法输入中文。回车后输入密码即可\nexit # 连接成功后退出\n若无线网卡无法显示，请按照的说明 确保你的无线网卡硬件开关处于打开状态。\n你可以使用如下命令查看内核是否加载了你的无线网卡驱动。\nlspci -k | grep Network\n以我的硬件为例，输出如下：\n00:14.3 Network controller: Intel Corporation Wi-Fi 6 AX201 (rev 20)\n部分无线网卡不兼容，请考虑使用有线连接安装 archlinux，比如用 usb 连接手机共享网络\n1.3.2 使用有线连接：\n正常来说，只要插上一个已经联网的路由器分出的网线（DHCP），直接就能联网。\n可以等待几秒等网络建立连接后再进行下一步测试网络的操作。\n若笔记本没有网线接口请使用带网线接口的扩展坞。\n1.3.3 测试网络连通性\n通过 ping 命令测试网络连通性：\nping www.bilibili.com\n稍等片刻，若能看到数据返回，即说明已经联网。与 Windows 不同的是，需要按下 Ctrl + C 手动退出 ping 命令。\n如果无线网络还是无法连接，请使用 ip link 命令查看无线网卡设备，使用 ip link set &lt;设备名&gt; up 命令激活对应的无线网卡。若看到类似 Operation not possible due to RF-kill 的报错，继续尝试 rfkill unblock wifi 来解锁无线网卡。\n如有需要，可以参考 archWiki 相关内容\n1.4 安装 SSH\n\n\n                  \n                  Note\n                  \n                \n\n强烈推荐使用 ssh 远程安装，避免手动输入命令，减少输入错误，避免安装失败。\n\n\n安装 openssh 服务，之后用 ssh 连接，避免使用丑陋的界面。\n# 安装之前配置镜像源比较好\npacman -Sy openssh\n# 启动 sshd 服务\nsystemctl start sshd\n# 设置密码\npasswd root\n\n\n                  \n                  Note\n                  \n                \n\n不要忘记设置 root 用户的密码\n\n\n\n1.5 更新系统时钟\n使用 timedatectl 确保系统时间是准确的。这一步不是可选的，正确的系统时间对于部分程序来说非常重要：\ntimedatectl set-ntp true # 将系统时间与网络时间进行同步\ntimedatectl status # 检查服务状态\n\n1.6 更换软件仓库镜像源\n使用 vim 编辑器修改 /etc/pacman.d/mirrorlist 文件。将 pacman 软件仓库源更换为国内软件仓库镜像源：\nvim /etc/pacman.d/mirrorlist\n\n放在最上面的是会使用的软件仓库镜像源，推荐的镜像源如下：\nServer = mirrors.ustc.edu.cn/archlinux/$repo/os/$arch # 中国科学技术大学开源镜像站\nServer = mirrors.tuna.tsinghua.edu.cn/archlinux/$repo/os/$arch # 清华大学开源软件镜像站\nServer = repo.huaweicloud.com/archlinux/$repo/os/$arch # 华为开源镜像站\nServer = mirror.lzu.edu.cn/archlinux/$repo/os/$arch # 兰州大学开源镜像站\n\n前车之鉴 —— 请不在这一步中添加 archlinuxcn 源！如果你在 /etc/pacman.conf 中添加了内容，请将它们删掉。\n2 分区和格式化\n2.1 分区\n\n\n                  \n                  Warning\n                  \n                \n\n分区操作的部分命令具有危险性！除非你知道每一个命令在干什么，否则请不要执行！同时，请提前做好数据备份，防止数据丢失！\n\n\n\n/ 根目录：&gt;= 128GB（和用户主目录在同一个 Btrfs 文件系统上）\n/home 用户主目录：&gt;= 128GB（和根目录在同一个 Btrfs 文件系统上）\n/boot/efi EFI 分区：256MB（由电脑厂商或 Windows 决定，无需再次创建）\nSwap 分区：&gt;= 电脑实际运行内存的 60%（设置这个大小是为了配置休眠准备）\n\n\n\n                  \n                  推荐使用swapfile代替swap分区，这样调整大小更灵活。 \n                  \n                \n\n因为采用 Btrfs 文件系统，所以根目录和用户主目录实际在一个分区上，只是在不同的子卷上而已。这里根目录和用户主目录的大小仅为参考，一般来说日常使用的 linux 分配 128GB 已经够用了。\n\n通过 lsblk 命令，区分要安装 archlinux 的磁盘（通过观察磁盘的大小、已存在的分区情况等判断）并显示当前磁盘的分区情况：\n\nlsblk # 显示当前分区情况\n\n此处要分区和安装 archlinux 的磁盘即为 sda。请根据你的实际情况判断！\nℹ️ 提示\n为了模拟真实的环境，笔者手动创建了三个分区分别代表：\n\nsda1 —— EFI 分区\nsda2 —— win10 下的 C 盘（象征性的分了 1GB）\nsda3 —— win10 下的 D 盘（象征性的分了 1GB）\n\nℹ️ 提示\n注意此处并不会显出出未分配的磁盘空间！只有在使用 cfdisk 执行分区操作后才会显示出来。\nℹ️ 提示\n如果你的硬盘是 NVME 协议的固态硬盘，那么将不是 sdx 而是 nvmexn1。\n\n接下来使用 cfdisk 命令对磁盘分区（对于 SATA 协议的硬盘，x 为字母 a、b 或 c 等等；对于 NVME 协议的硬盘，x 为数字 0、1 或 2 等等，请根据实际情况判断）：\n\ncfdisk /dev/sdx # 对安装 archlinux 的磁盘分区\n\n进入 cfdisk 分区工具之后，你会看到如图所示的界面。通过方向键 ↑ 和 ↓ 可以在要操作磁盘分区或空余空间中移动；通过方向键 ← 和 → 在对当前高亮的磁盘分区或空余空间要执行的操作中移动。\n\n\n首先创建 Swap 分区。选中 Free space &gt; 再选中操作 [New] &gt; 然后按下回车 Enter 以新建 swap 分区（类似 Windows 的交换文件）\n\n\n按下回车后会提示输入 分区大小，Swap 分区建议为电脑内存大小的 60%，或者和内存大小相等 &gt; 然后按下回车 Enter\n\n\nℹ️ 提示\n单位可以自行输入，如 GB、MB 等等。\n\n\n默认新建的类型是 Linux filesystem，我们需要将类型更改为 Linux swap。选中操作 [Type] &gt; 然后按下回车 Enter &gt; 通过方向键 ↑ 和 ↓ 选中 Linux swap &gt; 最后按下回车 Enter\n\n\n我们再只需要一个分区即可（因为使用 Btrfs 文件系统，所以根目录和用户主目录在一个分区上），所以类似的：选中 Free space &gt; 再选中操作 [New] &gt; 然后按下回车 Enter 以新建分区\n\n\n\n\n输入 分区大小（默认是剩余的全部空间。请根据实际情况输入）&gt; 然后按下回车 Enter\n\n\n\n分区类型默认即可，无需更改。接下来选中操作 [Write] 并回车 Enter &gt; 输入 yes 并回车 Enter 确认分区操作\n\n\n\n⚠️ 注意\n只有写入了操作分区表才会更改。\n\n选中操作 [Quit] 并回车 Enter 以退出 cfdisk 分区工具\n\n\n☢️ 警告\n再次提醒！请仔细检查命令和操作的正确性，否则将出现不可预料的情况。最危险的是可能造成数据丢失！\n常见的错误包括不小心把 Windows 的分区删掉了 😥。\n\n分区完成后，使用 fdisk 或 lsblk 命令复查分区情况：\n\nfdisk -l # 复查磁盘情况\n\n\n\n# 7-2. 格式化并创建 Btrfs 子卷\n# 7-2-1. 格式化 Swap 分区\n通过以下命令格式化对应的 Swap 分区，请按照实际情况替换 x 和 n（下同）：\nmkswap /dev/sdxn\n\n\n# 7-2-2. 格式化 Btrfs 分区\n\n首先我们需要将整一个分区格式化为 Btrfs 文件系统。使用如下命令进行格式化：\n\nmkfs.btrfs -L myArch /dev/sdxn\n\n\n📑 命令参数说明：\n\n-L 选项后指定该分区的 LABLE，这里以 myArch 为例，也可以自定义，但不能使用特殊字符以及空格，且最好有意义\n\n\n\n\n为了创建子卷，我们需要先将 Btrfs 分区挂载到 /mnt 下：\n\nmount -t btrfs -o compress=zstd /dev/sdxn /mnt\n\n\n📑 命令参数说明：\n\n-t 选项后指定挂载分区文件系统类型\n-o 选项后添加挂载参数：\n\ncompress=zstd —— 开启透明压缩\n\n\n\n\n\n使用 df 命令复查挂载情况：\n\ndf -h # -h 选项会使输出以人类可读的单位显示\n\n\n# 7-2-3. 创建 Btrfs 子卷\n\n通过以下命令创建两个 Btrfs 子卷，之后将分别挂载到 / 根目录和 /home 用户主目录：\n\nbtrfs subvolume create /mnt/@ # 创建 / 目录子卷\nbtrfs subvolume create /mnt/@home # 创建 /home 目录子卷\n\n\n⚠️ 注意\n除非你清楚你的操作产生的后果，否则请保持子卷名称和结构与本指南一致，因为在后面我们会设置的快照工具 timeshift 只支持这种子卷布局。\n\n通过以下命令复查子卷情况：\n\nbtrfs subvolume list -p /mnt\n\n\n\n子卷创建好后，我们需要将 /mnt 卸载掉，以挂载子卷：\n\numount /mnt\n\n\n# 8. 挂载\n\n在挂载时，挂载是有顺序的，需要从根目录开始挂载。使用如下命令挂载子卷：\n\nmount -t btrfs -o subvol=/@,compress=zstd /dev/sdxn /mnt # 挂载 / 目录\nmkdir /mnt/home # 创建 /home 目录\nmount -t btrfs -o subvol=/@home,compress=zstd /dev/sdxn /mnt/home # 挂载 /home 目录\nmkdir -p /mnt/boot/efi # 创建 /boot/efi 目录\nmount /dev/sdxn /mnt/boot/efi # 挂载 /boot/efi 目录\nswapon /dev/sdxn # 挂载交换分区\n\n\n使用 df 命令复查挂载情况：\n\ndf -h\n\n\n\n使用 free 命令复查 Swap 分区挂载情况：\n\nfree -h # -h 选项会使输出以人类可读的单位显示\n\n\n# 9. 安装系统\n\n通过如下命令使用 pacstrap 脚本安装基础包：\n\npacstrap /mnt base base-devel linux linux-firmware\n\n\n📑 命令参数说明：\n\nbase-devel —— base-devel 在 AUR 包的安装过程中是必须用到的\nlinux —— 内核软件包，这里建议先不要替换为其它内核\n\n\n\n\n通过如下命令使用 pacstrap 脚本安装其它必要的功能性软件：\n\npacstrap /mnt iwd neovim sudo fish\n\n\n📑 命令参数说明：\n\nzsh —— zsh-completions 如果你是 bash 的爱好者，请把这两个包换成bash-completion\n如果你是第一次接触*nix 系统的新手，不建议换成 bash\n\n\n\n经过一系列安装时提示信息的刷屏，这些包就安装好了。\n⚠️ 注意\n在执行命令前，请仔细检查命令的拼写正确；同时注意不要漏装东西。\n很多人在后续的步骤中报错就是因为这里漏装了东西。\n如果报错，请检查拼写，同时请确保之前的步骤 更换国内软件仓库镜像源加快下载速度 中没有添加 archlinuxcn 源。\n# 10. 生成 fstab 文件\n\nfstab 用来定义磁盘分区。它是 Linux 系统中重要的文件之一。使用 genfstab 自动根据当前挂载情况生成并写入 fstab 文件：\n\ngenfstab -U /mnt &gt; /mnt/etc/fstab\n\n\n复查一下 /mnt/etc/fstab 确保没有错误：\n\ncat /mnt/etc/fstab\n\n\n若为 NVME 协议的硬盘，输出结果应该与此类似：\n# /dev/nvme0n1p6  /  btrfs  rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=256,subvol=/@,subvol=@ 0 0\nUUID=d01a3ca5-0798-462e-9a30-97065e7e36e1 /  btrfs  rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=256,subvol=/@,subvol=@  0 0\n\n# /dev/nvme0n1p1  /boot/efi vfat  rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro      0 2\nUUID=522C-80C6  /boot/efi vfat  rw,relatime,fmask=0022,dmask=0022,codepage=437,iocharset=ascii,shortname=mixed,utf8,errors=remount-ro 0 2\n\n# /dev/nvme0n1p6  /home btrfs rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=257,subvol=/@home,subvol=@home 0 0\nUUID=d01a3ca5-0798-462e-9a30-97065e7e36e1 /home btrfs rw,relatime,compress=zstd:3,ssd,space_cache,subvolid=257,subvol=/@home,subvol=@home 0 0\n\n# /dev/nvme0n1p5  none  swap  defaults  0 0\nUUID=8e40dbed-590f-4cb8-80de-5cef8343a9fc none  swap  defaults  0 0\n\n# 11. change root\n使用以下命令把系统环境切换到新系统下：\narch-chroot /mnt\n\n\n此时，原来安装盘下的 /mnt 目录就变成了新系统的 / 目录。同时，可以发现命令行的提示符颜色和样式也发生了改变。\n# 12. 设置主机名与时区\n\n首先在 /etc/hostname 设置主机名：\n\nvim /etc/hostname\n\n\n加入你想为主机取的主机名，这里比如叫 myarch。\nℹ️ 提示\n主机名不要包含特殊字符以及空格。\n\n接下来在 /etc/hosts 设置与其匹配的条目：\n\nvim /etc/hosts\n\n加入如下内容：\n127.0.0.1   localhost\n::1         localhost\n127.0.1.1   myarch.localdomain\tmyarch\n\n\nℹ️ 提示\n你可以使用 Tab 对齐。\nℹ️ 提示\n某些情况下如不设置主机名，在 KDE 下可能会存在网络情况变更时无法启动 GUI 应用的问题，在终端中出现形如 No protocol specified qt.qpa.xcb: could not connect to display 的错误。这种情况极为少见。\n但不管如何，即使没有问题，我们都应该设置好主机名。\n\n随后设置时区，在 /etc/localtime 下用 /usr 中合适的时区创建符号链接：\n\nln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n\n\n\n# 🍧 碎碎念\n不要找北京啦！这里没有北京，只有上海啦！🚀\n\nℹ️ 提示\n同时，你也可以使用其它时区：\n\n# 13. 硬件时间设置\n使用如下命令将系统时间同步到硬件时间：\nhwclock --systohc\n\n# 14. 设置 Locale\nLocale 决定了软件使用的语言、书写习惯和字符集。\n\n编辑 /etc/locale.gen，去掉 en_US.UTF-8 UTF-8 以及 zh_CN.UTF-8 UTF-8 行前的注释符号（#）：\n\nvim /etc/locale.gen\n\n\n\nℹ️ 提示\n有几个选项极具迷惑性，请不要取消注释错了。\n\n然后使用如下命令生成 locale：\n\nlocale-gen\n\n\n\n向 /etc/locale.conf 输入内容：\n\necho &#039;LANG=en_US.UTF-8&#039;  &gt; /etc/locale.conf\n\n⚠️ 注意\n不推荐在此设置任何中文 locale，会导致 tty 乱码。\n# 15. 为 root 用户设置密码\npasswd root\n\n\nℹ️ 提示\n根据提示操作即可。注意输入密码时不会显示哦，不要以为 ⌨ 键盘坏了。\n# 16. 安装微码\n通过以下命令安装对应芯片制造商的微码：\npacman -S intel-ucode # Intel\npacman -S amd-ucode # AMD\n\nℹ️ 提示\n🎉 恭喜你！这是你在新系统中第一次使用 pacman 软件包管理器安装软件！在这里一路回车完成安装即可。\n如果你不会使用，请参阅 这里。\n# 17. 安装引导程序\n如有需要可以参阅 archWiki 相关内容\n\n。\n\n安装相应的包：\n\npacman -S grub efibootmgr os-prober\n\n\n📑 命令参数说明：\n\n-S 选项后指定要通过 pacman 包管理器安装的包：\n\ngrub —— 启动引导器\nefibootmgr —— efibootmgr 被 grub 脚本用来将启动项写入 NVRAM\nos-prober —— 为了能够引导 win10，需要安装 os-prober 以检测到它\n\n\n\n\n\n安装 GRUB 到 EFI 分区：\n\ngrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=ARCH\n\n\n📑 命令参数说明：\n\n--efi-directory=/boot/efi —— 将 grubx64.efi 安装到之前的指定位置（EFI 分区）\n--bootloader-id=ARCH —— 取名为 ARCH\n\n\n\n\n接下来使用 vim 编辑 /etc/default/grub 文件：\n\nvim /etc/default/grub\n\n进行如下修改：\n\n去掉 GRUB_CMDLINE_LINUX_DEFAULT 一行中最后的 quiet 参数\n把 loglevel 的数值从 3 改成 5。这样是为了后续如果出现系统错误，方便排错\n加入 nowatchdog 参数，这可以显著提高开关机速度\n\n\n\n为了引导 win10，则还需要添加新的一行 GRUB_DISABLE_OS_PROBER=false\n\n# GRUB boot loader configuration\n\nGRUB_DEFAULT=0\nGRUB_TIMEOUT=5\nGRUB_DISTRIBUTOR=&quot;Arch&quot;\nGRUB_CMDLINE_LINUX_DEFAULT=&quot;loglevel=5 nowatchdog&quot;\nGRUB_CMDLINE_LINUX=&quot;&quot;\nGRUB_DISABLE_OS_PROBER=false\n...\n\n\n最后生成 GRUB 所需的配置文件：\n\ngrub-mkconfig -o /boot/grub/grub.cfg\n\n\n若引导了 win10，则输出应该包含倒数第二行：\n\nℹ️ 提示\n在某些主板安装完成后，你会发现没有启动条目。这是因为某些主板的 UEFI 固件在显示 UEFI NVRAM 引导条目之前，需要在特定的位置存放可引导文件，不支持自定义存放 efi 文件（如微星 Z170-A Gaming PRO）。解决方案是在默认启动路径下安装 GRUB。重新插入安装优盘，按原先顺序挂载目录（不需要再次创建文件夹了），chroot 到 /mnt，然后你可以直接把已经生成好的 efi 文件移动到默认目录下，如下命令所示。只有安装完成后你的主板不出现启动条目才需要尝试如下命令，正常安装无需执行。如有需要可以参考 archWiki 对应内容\n\n。\nmkdir -p /boot/efi/EFI/BOOT\nmv /boot/efi/EFI/GRUB/grubx64.efi /boot/efi/EFI/BOOT/BOOTX64.EFI\n\n# 18. 完成安装\n\n输入以下命令：\n\nexit # 退回安装环境\numount -R /mnt # 卸载新分区\nreboot # 重启\n\n\n注意，重启前要先拔掉优盘，否则你重启后还是进安装程序而不是安装好的系统。\nℹ️ 提示\n虚拟机直接重启即可。\n\n如图即为 GRUB 引导界面。\nℹ️ 提示\n若引导了 win10 也会显示出来。\nℹ️ 提示\n若 win10 分区使用了 🔐 Bitlocker 加密，则第一次从 GRUB 进入需要输入解锁密钥。\n你应该在步骤 5. 获取 Bitlocker 恢复密钥 中已经知晓了 Bitlocker 解锁密钥。\n若无法从 aka.ms 相关页面 获取解锁密钥，请尝试在 BIOS 中将 Windows Boot Manager 移动到启动顺序首位再尝试进入 win10。\n\n重启后使用 root 账户登录系统：\n\n\n\n设置开机自启并立即启动 dhcp 服务，即可连接网络：\n\nsystemctl enable --now dhcpcd # 设置开机自启并立即启动 dhcp 服务\nping www.bilibili.com # 测试网络连接\n\n\n\n若为无线连接，则还需要启动 iwd 才可以使用 iwctl 连接网络：\n\nsystemctl start iwd # 立即启动 iwd\niwctl # 和之前的方式一样，连接无线网络\n\n\nneofetch 可以将系统信息和发行版 logo 一并打印出来。通过 pacman 安装 neofetch：\n\npacman -S neofetch\n"},"A计科工程/主机运维/Linux/Arch/arch-tty-自动登陆":{"title":"arch tty 自动登陆","links":[],"tags":["TODO","tty"],"content":"起应是不想用 lightdm/gdm 之类的登录管理器\n我用的 zsh，先在用户的~/. zprofile 加入，如果是 bash 则是~/. bash_profile\nif [[ -z $DISPLAY ]] &amp;&amp; [[ $(tty) = /dev/tty1 ]]; then\n\texec startx\nfi\n然后编辑你的\n**/etc/systemd/system/getty. target. wants/ getty@tty1.service **\n[Service]\r\n# the VT is cleared by TTYVTDisallocate\r\n# The &#039;-o&#039; option value tells agetty to replace &#039;login&#039; arguments with an\r\n# option to preserve environment (-p), followed by &#039;--&#039; for safety, and then\r\n# the entered username.\r\n# 原来是\r\nExecStart=-/sbin/agetty -a &lt;user&gt; -o &#039;-p -- \\\\u&#039; --noclear %I $TERM\r\n# 改成，就是加一个 -a 参数，后面跟你的用户名\r\nExecStart=-/sbin/agetty -a &lt;user&gt; -o &#039;-p -- \\\\u&#039; --noclear %I $TERM\r\nType=idle\n\n然后执行\nsystemctl daemon-reload\r\n\r\n\r\nsystemctl start getty@tty1.service\n\n这样设置之后启动还需要输入一次密码，如果想跳过密码则\n编辑 /etc/pam. d/system-local-login\n#%PAM-1.0\r\n\r\n# 加入下面这一行，其中最后的 **c** 代表的是你的用户所在的用户组，一般创建用户的时候会自动创建一个同名的用户组\r\n\r\nauth sufficient pam_succeed_if.so user ingroup c\r\nauth      include   system-login\r\naccount   include   system-login\r\npassword  include   system-login\r\nsession   include   system-login\n"},"A计科工程/主机运维/Linux/Arch/archlinux-devtools":{"title":"archlinux devtools","links":["E临时笔记/truncate"],"tags":["archlinux","devtools"],"content":"Arch 包构建\n创建环境\nmakepkg 也可以打包，但是它使用的是本地的环境，无法验证相关依赖是否正确。\r\n使用devtools可以创建一个干净的虚拟环境。\n\n\n                  \n                  不再推荐使用以下方法 \n                  \n                \n\n建议直接使用 devtools 提供的快捷脚本\n\n\n# 定义环境变量\nCHROOT=$HOME/.chroot\nmkdir ~/.chroot\n \n# 创建初始环境\n# 在 btrfs 上，会创建一个新子卷，删除它 btrfs subvolume delete $CHROOT/root\n# @TODO：这里添加了 base 包，以确保后续更新环境正常\nmkarchroot $CHROOT/root base base-devel\n \n# 更新环境\narch-nspawn $CHROOT/root pacman -Syu\n打包\n在包含PKGBUILD文件目录下，运行：\nmakechrootpkg -c -r $CHROOT\nUsage: makechrootpkg [options] -r &lt;chrootdir&gt; [--] [makepkg args]\r\n...\r\n...\r\nDefault makepkg args: --syncdeps --noconfirm --log --holdver --skipinteg\r\n\r\nFlags:\r\n-h         This help\r\n-c         Clean the chroot before building\r\n-d &lt;dir&gt;   Bind directory into build chroot as read-write\r\n-D &lt;dir&gt;   Bind directory into build chroot as read-only\r\n-t &lt;dir[:opts]&gt;   Mount a tmpfs at directory\r\n-u         Update the working copy of the chroot before building\r\n           This is useful for rebuilds without dirtying the pristine\r\n           chroot\r\n-r &lt;dir&gt;   The chroot dir to use\r\n-I &lt;pkg&gt;   Install a package into the working copy of the chroot\r\n-l &lt;copy&gt;  The directory to use as the working copy of the chroot\r\n           Useful for maintaining multiple copies\r\n           Default: chauncey\r\n-n         Run namcap on the package\r\n-C         Run checkpkg on the package\r\n-T         Build in a temporary directory\r\n-U         Run makepkg as a specified user\n\n\n\n                  \n                  Note\n                  \n                \n\n这个虚拟的环境会复制本地系统的 pacman hook 文件\n\n\n\n\n                  \n                  Note\n                  \n                \n\n这些命令都是依靠底层的 makepkg ，需要传递参数给 makepkg，使用\r\ncommand -- [options]\n\n\n加速\n为了避免其他软件的依赖影响打包环境，arch 提供了 devtools 来配置干净的\r\n虚拟系统环境。\n\n安装 sudo pacman -Sy devtools\n\n每次重新准备干净 chroot 的过程特别慢，如何可以提速呢？\r\n可以考虑使用 truncate 做一个 btrfs 镜像挂载到 /var/lib/archbuild，\r\ndevtools 会自动使用 btrfs 来加速这个过程。参考制作过程：\nsudo truncate -s 100G /var/archbuild.img\nsudo mkfs.btrfs /var/archbuild.img\nsudo mount -o discard,compress=lzo,autodefrag /var/archbuild.img /var/lib/archbuild\necho &quot;/var/archbuild.img /var/lib/archbuild btrfs defaults,discard,compress=lzo,autodefrag 0 0&quot; | sudo tee /etc/fstab\n\n\n                  \n                  Note\n                  \n                \n\n如果本身就是 btrfs 文件系统，是否就不需要这个步骤了\r\n在创建 CHROOT 时，自动创建了一个子卷，应该就是用来加速的\n\n\n参考\n\nArchwiki: Building in a clean chroot\n在干净的环境里编译软件包\n"},"A计科工程/主机运维/Linux/Arch/问题":{"title":"问题","links":[],"tags":[],"content":"www.reddit.com/r/archlinux/comments/rqcg7v/every_single_patched_nerd_font_has_alignment/"},"A计科工程/主机运维/Linux/Boot-A-ISO":{"title":"Boot A ISO","links":["A计科工程/主机运维/Linux/systemd-boot"],"tags":["boot","linux","systemd-boot"],"content":"Boot a .iso directly using systemd-boot\n\nPretty self-explanatory.\nI’m using systemd-boot, and my esp is /boot.\nI want to run the official archlinux.iso directly from my /boot partition.\nSteps:\nmount archlinux.iso and copy &quot;vmlinux-linuz&quot; + &quot;initramfs-linux.img&quot; to a newly-created directory at /boot ( eg. /boot/live)\r\n\r\ncopy the archlinux.iso to /boot\r\n\r\ncreate the /boot/loader/entries/live.conf entry with:\n\ntitle Archlinux Live\n \nlinux /live/vmlinuz-linux\n \ninitrd /live/initramfs-linux.img\n \noptions img_dev=/dev/nvme0n1p1 img_loop=archlinux.iso copytoram\n(replace “nvme0n1p1” and “archlinux” above, accordingly)\nThis way, you can chroot into your system, at any given time, without the need of a bootable usb flash drive.\nRefferences\nwww.reddit.com/r/archlinux/comments/qy281v/boot_an_archlinux_iso_directly_from_my_boot_using/"},"A计科工程/主机运维/Linux/Linux-字体调教":{"title":"Linux 字体调教","links":[],"tags":["TODO","linux","font"],"content":"Linux 字体调教\n\n字体类型\n\n\n无衬线字体（sans-serif）\n\n\n衬线字体（serif）\n\n\n等宽字体（monospace）\n\n"},"A计科工程/主机运维/Linux/Linux-权限管理":{"title":"Linux 权限管理","links":[],"tags":["Linux","Doc","TODO"],"content":"Linux 权限管理\n首先，明确 Linux 中的一切都是文件，那么权限管理就是针对文件的管理。\r\n并且由于 Linux 本身是一款多用户的操作系统，所以他的权限管理十分完善。\n用户和用户组\nArch Linux 的用户和用户组管理工具来自于包shadow.\n用户管理\n查看所有用户：\ncat /etc/passwd\n新增用户：\nuseradd -m -G -s [login_shell] [user_name]\n-m / --create-home\r\n用户的家目录/home/[user_name], 家目录会被 /etc/skel/ 下的文件填充.\r\n-G / --groups\r\n用户所属用户组.\r\n-s / --shell\r\n用户的登录shell路径.\n\n\n                  \n                  如果需要登录，设置的登录 shell 必须包含在 /etc/shells,\n                  \n                \n\n否则 PAM 的 pam_shells 模块会拒绝登录请求。\n\n\n添加系统用户：\nuseradd --system -s /usr/bin/nologin [username]\n相关命令:\r\nuseradd, userdel, usermod\n用户组管理\n查看所有用户组：\ncat /etc/group\n文件属性和权限\n\nACL"},"A计科工程/主机运维/Linux/Linux-系统数据":{"title":"Linux 系统数据","links":[],"tags":["TODO"],"content":"Linux 系统数据收集与分析\nPrometheus\nPrometheus 是一款基于时序数据库的开源监控告警系统，负责收集和存储指标数据，支持表达式查询，和告警的生成。\n\n"},"A计科工程/主机运维/Linux/Linux-网络管理":{"title":"Linux 网络管理","links":["A计科工程/主机运维/Linux/systemd","E临时笔记/systemd-networkd","A计科工程/主机运维/Linux/Tools/iwd","A计科工程/主机运维/Linux/smartdns","A计科工程/主机运维/Linux/iproute2"],"tags":["doc","network","systemd","linux","dns","smartdns"],"content":"网络管理\nsystemd 目前正在统一 Linux, 并且多数发行版已采用 systemd 替代以前的 init ；\r\n当前的思路是采用最少的软件，最小依赖，并且官方支持的方案。\r\nLinux 将使用 systemd-networkd 管理网络，无线网配合 iwd 使用，本地配置 smartdns 作 DNS 缓存。\n\n\n                  \n                  Warning\n                  \n                \n\n这里主要介绍配置有线网络，以及无线网络的过程。在开始配置前，需要把正在使用的网络管理服务停止掉，以避免出现冲突。\n\n\n\n网络工具\niproute2\n有线网络\n有线网络主要配置时，考虑到可能使用手机 usb 连接共享收集的网络，为了保持命名的一致性，\r\n通过 bridge 来归一化所有有线连接。配置如下：\n-. 将所有有线连接都作为 br0 的底层设备\n# /etc/systemd/network/20-ethernet.network\n[Match]\nName=en*\nName=eth*\n \n[Network]\nBridge=br0\n\n\n                  \n                  &gt; en* 配以 en 开头的所有设备。\n                  \n                \n\n-. 定义 br0 设备\n# /etc/systemd/network/20-br0.netdev\n[NetDev]\nName=br0\nKind=bridge\n-. 配置 br0 的网络\r\n这里采用了 DHCP 的方式获取 ip，由于我采用了独立的 DNS 解析，这里配置不使用 DNS.\n# /etc/systemd/network/20-br0.network\n[Match]\nName=br0\n \n[Network]\nDHCP=yes\nIPForward=yes\nIPv6AcceptRA=yes\nIPv6PrivacyExtensions=no\n \n[DHCPv4]\nUseDNS=false\nRouteMetric=400\n \n[DHCPv6]\nUseDNS=false\nRouteMetric=400\n \n[Route]\nGateway=_dhcp4\n \n以上是有线网络的所有配置。\n无线网络\n接下来是无线网络的配置，无线网络采用 iwd 来管理 wifi。\n-. 安装 iwd\n# archlinux\nsudo pacman -S iwd\n-. 启动 iwd 服务\nsystemctl enable --now iwd.service\n-. 设置无线网络的配置\n# /etc/systemd/network/25-wireless.network\n[Match]\nName=wl*\n \n[Network]\nDHCP=yes\nIPForward=yes\nIPv6AcceptRA=yes\nIPv6PrivacyExtensions=no\n \n[DHCPv4]\nUseDNS=false\nRouteMetric=400\n \n[DHCPv6]\nUseDNS=false\nRouteMetric=400\n \n[Route]\nGateway=_dhcp4\n \n\n\n                  \n                  Note\n                  \n                \n\n有线网络和无线网络的 RouteMetric 的值是不同的，应该优先使用有线网络。\n\n\n启动服务\n使用 systemctl start systemd-networkd 启动服务，看配置是否生效，网络是否正常。\r\n在网络正常后，通过下面命令设置开机自启动，完成所有配置。\nsystemctl enable --now iwd.service\nsystemctl enable --now systemd-networkd.service\n\n\n                  \n                  Note\n                  \n                \n\n在 /usr/lib/systemd/system/systemd-networkd-wait-online.service 中 ExecStart 后面\r\n加上 --any。避免因为多个网络接口，导致其他服务延迟。\n\n\nDNS\nsmartdns\n-. 安装\n# archlinux\nsudo pacman -S smartdns\n-. 简单配置\n# 依赖 smartdns-china-list-git 包\n# （可选）引入额外的规则列表，用绝对路径\nconf-file /etc/smartdns/anti-ad-smartdns.conf\nconf-file /etc/smartdns/accelerated-domains.china.smartdns.conf\nconf-file /etc/smartdns/apple.china.smartdns.conf\nconf-file /etc/smartdns/google.china.smartdns.conf\n \n# 本地监听端口\nbind [::]:53\n \n# 启用测速\nspeed-check-mode ping,tcp:80,tcp:443\n \n# 完全禁用 IPv6\nforce-AAAA-SOA yes\n# 启用双栈优选\n#dualstack-ip-selection yes\n#dualstack-ip-selection-threshold 15\n \n# log\nlog-level info\nlog-size 512M\n \n# 缓存大小\n# cache-size 4096\n# 持久化缓存\ncache-persist yes\n# 缓存文件存放位置\ncache-file /var/cache/smartdns.cache\n# 缓存预获取\nprefetch-domain yes\n# 过期缓存\nserve-expired yes\n \n# server\n# 阿里\nserver-tls dns.alidns.com -group china\n# 腾讯\nserver-tls dot.pub -group china\n# 360\nserver-tls dot.360.cn -group china\n# Google\nserver-tls dns.google\n-. 启动\nsudo systemctl enable --now smartdns.service\nReferences\n使用 systemd-networkd 管理网络\r\nlinux.cn/lfs/LFS-BOOK-7.7-systemd/chapter07/network.html\r\nwiki.archlinux.org/title/Dnsmasq\r\nwiki.archlinux.org/title/Systemd-resolved\r\nwiki.archlinux.org/title/Systemd-networkd"},"A计科工程/主机运维/Linux/Linux-美化":{"title":"Linux 美化","links":[],"tags":[],"content":"\nCursor\n如果没有设置光标主题，默认使用 default,\n\n~/.local/share/icons/default/\n~/.icons/default/\n/usr/share/icons/default/ (system-wide)\n\nIcons\n默认图标是 hicolor\n/usr/share/icons/hicolor"},"A计科工程/主机运维/Linux/Linux-虚拟机":{"title":"Linux 虚拟机","links":["E临时笔记/kvm"],"tags":["TODO","qemu","kvm","Linux","Doc"],"content":"Linux 虚拟机\nQEMU/KVM 虚拟化\nQEMU/KVM 是目前最流行的虚拟化技术，它基于 Linux 内核提供的 kvm 模块，结构精简，性能损失小，而且开源免费，因此成了大部分企业的首选虚拟化方案。\n目前各大云厂商的虚拟化方案，新的服务器实例基本都是用的 KVM 技术。即使是起步最早，一直重度使用 Xen 的 AWS，从 EC2 C5 开始就改用了基于 KVM 定制的 Nitro 虚拟化技术。\n但是 KVM 作为一个企业级的底层虚拟化技术，却没有对桌面使用做深入的优化，因此如果想把它当成桌面虚拟化软件来使用，替代掉 VirtualBox/VMware，有一定难度。\n本文是我个人学习 KVM 的一个总结性文档，其目标是使用 KVM 作为桌面虚拟化软件。\n一、安装 QUEU/KVM\nQEMU/KVM 环境需要安装很多的组件，它们各司其职：\n\nqemu: 模拟各类输入输出设备（网卡、磁盘、USB 端口等）, 底层使用 kvm 模拟 CPU 和 RAM，比软件模拟的方式快很多。\nlibvirt: 提供简单且统一的工具和 API，用于管理虚拟机，屏蔽了底层的复杂结构。（支持 qemu-kvm/virtualbox/vmware）\novmf: 为虚拟机启用 UEFI 支持\nvirt-manager: 用于管理虚拟机的 GUI 界面（可以管理远程 kvm 主机）。\nvirt-viewer: 通过 GUI 界面直接与虚拟机交互（可以管理远程 kvm 主机）。\ndnsmasq vde2 bridge-utils openbsd-netcat: 网络相关组件，提供了以太网虚拟化、网络桥接、NAT 网络等虚拟网络功能。\n\ndnsmasq 提供了 NAT 虚拟网络的 DHCP 及 DNS 解析功能。\nvde2: 以太网虚拟化\nbridge-utils: 顾名思义，提供网络桥接相关的工具。\nopenbsd-netcat: TCP/IP 的瑞士军刀，详见 socat &amp; netcat，这里不清楚是哪个网络组件会用到它。\n\n\n\n安装命令：\n# archlinux without gui\nsudo pacman -S qemu-base\n安装完成后，还不能直接使用，需要做些额外的工作。请继续往下走。\n1. libguestfs - 虚拟机磁盘映像处理工具\nlibguestfs 是一个虚拟机磁盘映像处理工具，可用于直接修改/查看/虚拟机映像、转换映像格式等。\n它提供的命令列表如下：\n\nvirt-df centos.img: 查看硬盘使用情况\nvirt-ls centos.img /: 列出目录文件\nvirt-copy-out -d domain /etc/passwd /tmp：在虚拟映像中执行文件复制\nvirt-list-filesystems /file/xx.img：查看文件系统信息\nvirt-list-partitions /file/xx.img：查看分区信息\nguestmount -a /file/xx.qcow2(raw/qcow2都支持) -m /dev/VolGroup/lv_root --rw /mnt：直接将分区挂载到宿主机\nguestfish: 交互式 shell，可运行上述所有命令。\nvirt-v2v: 将其他格式的虚拟机 (比如 ova) 转换成 kvm 虚拟机。\nvirt-p2v: 将一台物理机转换成虚拟机。\n\n学习过程中可能会使用到上述命令，提前安装好总不会有错，安装命令如下：\n# opensuse\nsudo zypper install libguestfs\n \n# archlinux/manjaro，目前缺少 virt-v2v/virt-p2v 组件\nsudo pacman -S libguestfs\n \n# ubuntu\nsudo apt install libguestfs-tools\n \n# centos\nsudo yum install libguestfs-tools\n2. 启动 QEMU/KVM\n通过 systemd 启动 libvirtd 后台服务：\nsudo systemctl enable --now libvirtd.service\nsudo systemctl start libvirtd.service\n3. 让非 root 用户能正常使用 kvm\nqumu/kvm 装好后，默认情况下需要 root 权限才能正常使用它。为了方便使用，首先编辑文件 /etc/libvirt/libvirtd.conf:\n\nunix_sock_group = &quot;libvirt&quot;，取消这一行的注释，使 libvirt 用户组能使用 unix 套接字。\nunix_sock_rw_perms = &quot;0770&quot;，取消这一行的注释，使用户能读写 unix 套接字。\n\n然后新建 libvirt 用户组，将当前用户加入该组：\nsudo newgrp libvirt\nsudo usermod -aG libvirt $USER\n最后重启 libvirtd 服务，应该就能正常使用了：\nsudo systemctl restart libvirtd.service\n4. 启用嵌套虚拟化\n如果你需要在虚拟机中运行虚拟机（比如在虚拟机里测试 katacontainers 等安全容器技术），那就需要启用内核模块 kvm_intel 实现嵌套虚拟化。\n# 临时启用 kvm_intel 嵌套虚拟化\nsudo modprobe -r kvm_intel\nsudo modprobe kvm_intel nested=1\n# 修改配置，永久启用嵌套虚拟化\necho &quot;options kvm-intel nested=1&quot; | sudo tee /etc/modprobe.d/kvm-intel.conf\n验证嵌套虚拟化已经启用：\n$ cat /sys/module/kvm_intel/parameters/nested\nY\n至此，KVM 的安装就大功告成啦，现在应该可以在系统中找到 virt-manager 的图标，进去就可以使用了。virt-manager 的使用方法和 virtualbox/vmware workstation 大同小异，这里就不详细介绍了，自己摸索摸索应该就会了。\n\n\n如下内容是进阶篇，主要介绍如何通过命令行来管理虚拟机磁盘，以及 KVM。如果你还是 kvm 新手，建议先通过图形界面 virt-manager 熟悉熟悉，再往下继续读。\n\n二、虚拟机磁盘映像管理\n这需要用到两个工具：\n\nlibguestfs: 虚拟机磁盘映像管理工具，前面介绍过了\nqemu-img: qemu 的磁盘映像管理工具，用于创建磁盘、扩缩容磁盘、生成磁盘快照、查看磁盘信息、转换磁盘格式等等。\n\n# 创建磁盘\nqemu-img create -f qcow2 -o cluster_size=128K virt_disk.qcow2 20G\n\n# 扩容磁盘\nqemu-img resize ubuntu-server-cloudimg-amd64.img 30G\n\n# 查看磁盘信息\nqemu-img info ubuntu-server-cloudimg-amd64.img\n\n# 转换磁盘格式\nqemu-img convert -f raw -O qcow2 vm01.img vm01.qcow2  # raw =&gt; qcow2\nqemu-img convert -f qcow2 -O raw vm01.qcow2 vm01.img  # qcow2 =&gt; raw\n\n1. 导入 vmware 镜像\n直接从 vmware ova 文件导入 kvm，这种方式转换得到的镜像应该能直接用（网卡需要重新配置）：\nvirt-v2v -i ova centos7-test01.ova -o local -os /vmhost/centos7-01  -of qcow2\n\n也可以先从 ova 中解压出 vmdk 磁盘映像，将 vmware 的 vmdk 文件转换成 qcow2 格式，然后再导入 kvm（网卡需要重新配置）：\n# 转换映像格式\nqemu-img convert -p -f vmdk -O qcow2 centos7-test01-disk1.vmdk centos7-test01.qcow2\n# 查看转换后的映像信息\nqemu-img info centos7-test01.qcow2\n\n直接转换 vmdk 文件得到的 qcow2 镜像，启会报错，比如「磁盘无法挂载」。根据 Importing Virtual Machines and disk images - ProxmoxVE Docs 文档所言，需要在网上下载安装 MergeIDE.zip 组件，另外启动虚拟机前，需要将硬盘类型改为 IDE，才能解决这个问题。\n2. 导入 img 镜像\nimg 镜像文件，就是所谓的 raw 格式镜像，也被称为裸镜像，IO 速度比 qcow2 快，但是体积大，而且不支持快照等高级特性。如果不追求 IO 性能的话，建议将它转换成 qcow2 再使用。\nqemu-img convert -f raw -O qcow2 vm01.img vm01.qcow2\n\n三、虚拟机管理\n虚拟机管理可以使用命令行工具 virsh/virt-install，也可以使用 GUI 工具 virt-manager.\nGUI 很傻瓜式，就不介绍了，这里主要介绍命令行工具 virsh/virt-install\n先介绍下 libvirt 中的几个概念：\n\nDomain: 指代运行在虚拟机器上的操作系统的实例 - 一个虚拟机，或者用于启动虚拟机的配置。\nGuest OS: 运行在 domain 中的虚拟操作系统。\n\n大部分情况下，你都可以把下面命令中涉及到的 domain 理解成虚拟机。\n0. 设置默认 URI\nvirsh/virt-install/virt-viewer 等一系列 libvirt 命令，sudo virsh net-list –all 默认情况下会使用 qemu:///session 作为 URI 去连接 QEMU/KVM，只有 root 账号才会默认使用 qemu:///system.\n另一方面 virt-manager 这个 GUI 工具，默认也会使用 qemu:///system 去连接 QEMU/KVM（和 root 账号一致）\nqemu:///system 是系统全局的 qemu 环境，而 qemu:///session 的环境是按用户隔离的。另外 qemu:///session 没有默认的 network，创建虚拟机时会出毛病。。。\n因此，你需要将默认的 URI 改为 qemu:///system，否则绝对会被坑：\necho &#039;export LIBVIRT_DEFAULT_URI=&quot;qemu:///system&quot;&#039; &gt;&gt; ~/.bashrc\n1. 虚拟机网络\nqemu-kvm 安装完成后，qemu:///system 环境中默认会创建一个 default 网络，而 qemu:///session 不提供默认的网络，需要手动创建。\n我们通常使用 qemu:///system 环境就好，可以使用如下方法查看并启动 default 网络，这样后面创建虚拟机时才有网络可用。\n# 列出所有虚拟机网络\n$ sudo virsh net-list --all\n Name      State      Autostart   Persistent\n----------------------------------------------\n default   inactive   no          yes\n \n# 启动默认网络\n$ virsh net-start default\nNetwork default started\n \n# 将 default 网络设为自启动\n$ virsh net-autostart --network default\nNetwork default marked as autostarted\n \n# 再次检查网络状况，已经是 active 了\n$ sudo virsh net-list --all\n Name      State    Autostart   Persistent\n--------------------------------------------\n default   active   yes         yes\n也可以创建新的虚拟机网络，这需要手动编写网络的 xml 配置，然后通过 virsh net-define --file my-network.xml 创建，这里就不详细介绍了，因为暂时用不到…\n2. 创建虚拟机 - virt-intall\n# 使用 iso 镜像创建全新的 proxmox 虚拟机，自动创建一个 60G 的磁盘。\nvirt-install --virt-type kvm \\\n--name pve-1 \\\n--vcpus 4 --memory 8096 \\\n--disk size=60 \\\n--network network=default,model=virtio \\\n--os-type linux \\\n--os-variant generic \\\n--graphics vnc \\\n--cdrom proxmox-ve_6.3-1.iso\n \n# 使用已存在的 opensuse cloud 磁盘创建虚拟机\nvirt-install --virt-type kvm \\\n  --name opensuse15-2 \\\n  --vcpus 2 --memory 2048 \\\n  --disk opensuse15.2-openstack.qcow2,device=disk,bus=virtio \\\n  --disk seed.iso,device=cdrom \\\n  --os-type linux \\\n  --os-variant opensuse15.2 \\\n  --network network=default,model=virtio \\\n  --graphics vnc \\\n  --import\n其中的 --os-variant 用于设定 OS 相关的优化配置，官方文档强烈推荐设定，其可选参数可以通过 osinfo-query os 查看。\n3. 虚拟机管理 - virsh\n虚拟机创建好后，可使用 virsh 管理虚拟机：\n查看虚拟机列表：\n# 查看正在运行的虚拟机\nvirsh list\n \n# 查看所有虚拟机，包括 inactive 的虚拟机\nvirsh list --all\n使用 virt-viewer 以 vnc 协议登入虚拟机终端：\n# 使用虚拟机 ID 连接\nvirt-viewer 8\n# 使用虚拟机名称连接，并且等待虚拟机启动\nvirt-viewer --wait opensuse15\n启动、关闭、暂停 (休眠)、重启虚拟机：\nvirsh start opensuse15\nvirsh suuspend opensuse15\nvirsh resume opensuse15\nvirsh reboot opensuse15\n# 优雅关机\nvirsh shutdown opensuse15\n# 强制关机\nvirsh destroy opensuse15\n \n# 启用自动开机\nvirsh autostart opensuse15\n# 禁用自动开机\nvirsh autostart --disable opensuse15\n虚拟机快照管理：\n# 列出一个虚拟机的所有快照\nvirsh snapshot-list --domain opensuse15\n# 给某个虚拟机生成一个新快照\nvirsh snapshot-create &lt;domain&gt;\n# 使用快照将虚拟机还原\nvirsh snapshot-restore &lt;domain&gt; &lt;snapshotname&gt;\n# 删除快照\nvirsh snapshot-delete &lt;domain&gt; &lt;snapshotname&gt;\n删除虚拟机：\nvirsh undefine opensuse15\n迁移虚拟机：\n# 使用默认参数进行离线迁移，将已关机的服务器迁移到另一个 qemu 实例\nvirsh migrate 37 qemu+ssh://tux@jupiter.example.com/system\n# 还支持在线实时迁移，待续\ncpu/内存修改：\n# 改成 4 核\nvirsh setvcpus opensuse15 4\n# 改成 4G\nvirsh setmem opensuse15 4096\n虚拟机监控：\n# 待续\n修改磁盘、网络及其他设备：\n# 添加新设备\nvirsh attach-device\nvirsh attach-disk\nvirsh attach-interface\n# 删除设备\nvirsh detach-disk\nvirsh detach-device\nvirsh detach-interface\nVirtualBox\nVMware\n参考\n\nVirtualization Guide - OpenSUSE\nComplete Installation of KVM, QEMU and Virt Manager on Arch Linux and Manjaro\nvirtualization-libvirt - ubuntu docs\nRedHat Docs - KVM\n"},"A计科工程/主机运维/Linux/Linux-输入法":{"title":"Linux 输入法","links":[],"tags":["TODO","Fcitx5","ibus",""],"content":"\n\n                  \n                  只推荐常用的输入法，并且开发活跃的。目前输入法在 Linux 下属于薄弱项，兼容较差，Jetbrains 系无法正常使用。 \n                  \n                \n\nibus1\nibus 是 Gnome 桌面环境下默认的输入法框架，\nibus-libpinyin\nibus 下使用较多的中文输入法，颜值和词库都非常出色，支持云词库。\n配置环境变量：\nvim ~/.profile\nexport GTK_IM_MODULE=ibus\nexport XMODIFIERS=@im=ibus\nexport QT_IM_MODULE=ibus\n# 解决 Jetbrains 等中文输入问题\nexport LC_CTYPE=zh_CN.UTF-8\nibus-daemon -d -x\n# 不确定是否需要，但确实是安装后，重启 ibus，Jetbrains 可用\nsudo dnf install ibus-qt-devel ibus-qt\n\n\n                  \n                  Jetbrains 使用官方下载二进制压缩包安装。 \n                  \n                \n\ngithub.com/libpinyin/ibus-libpinyin/issues/289\n\n\n                  \n                  当前正在使用的输入法，也是 Gnome 默认的中文输入法。 \n                  \n                \n\nfcitx52\nfcitx5-chinese-addons\ngithub.com/RikudouPatrickstar/JetBrainsRuntime-for-Linux-x64\n使用较多的中文输入法，颜值和词库都非常出色。\n安装：\n# Fedora\nsudo dnf install fcitx5 fcitx5-chinese-addons fcitx5-configtool fcitx5-autostart\nfcitx5-rime\n目前输入法已经转移到 fcitx5-rime, 主要原因是备份用户词库简单。随着使用时间的推移，词库会越来越适合自己。虽然配置文件比较复杂，但是网上有比较完善的成品方案，后续可以慢慢地修改，使其达到完美。\nFootnotes\n\n\nibus 详细介绍-archwiki ↩\n\n\nfcitx5 详细介绍-archwiki ↩\n\n\n"},"A计科工程/主机运维/Linux/Linux-透明代理":{"title":"Linux 透明代理","links":["A计科工程/主机运维/Linux/nftables","A计科工程/主机运维/Linux/smartdns"],"tags":["proxy","linux","net","clash","nftables"],"content":"Linux 透明代理\n使用 Arch Linux 已经有一段时间了，浏览器使用 Pac 来控制代理确实简单方便，但是有很多软件没办法方便地设置代理。\n主要使用的软件：clash-meta, nftables, smartdns\n\nclash-meta 配置\n# 安装\nsudo pacman -S clash-meta\n \n# 启动服务\nsudo systemctl enable --now clash-meta\n \n# 编辑配置\nsudo vim /etc/clash-meta/config.yaml\n系统路由\nip rule add fwmark 1 table 100\nip route add local 0.0.0.0/0 dev lo table 100\n启用透明代理 clash 所需要的配置\nrouting-mark: 1\nsniffer:\n  enable: true\n  sniffing:\n    - tls\n    - http\ntproxy-port: 7893\ndns:\n  enable: true\n  listen: &quot;0.0.0.0:1053&quot;\n  enhanced-mode: redir-host\n  default-nameserver:\n    - 8.8.8.8\n  nameserver:\n    -\n  fallback:\n    -\n  fallback-filter:\n    geoip: true\n    geoip-code: CN\n    ipcidr:\n      - 240.0.0.0/4\nnftables 配置\n获取 chnroute\nchina_ip_list\ncurl &#039;ftp.apnic.net/apnic/stats/apnic/delegated-apnic-latest&#039; | awk -F\\| &#039;/CN\\|ipv4/ { printf(&quot;%s/%d\\n&quot;, $4, 32-log($5)/log(2)) }&#039;| sed &#039;:label;N;s/\\n/, /;b label&#039;|sed &#039;s/$/&amp; }/g&#039;|sed &#039;s/^/define chnroute_ipv4 = { &amp;/g&#039; &gt; ipv4-chnroute.nft\ncurl &#039;raw.githubusercontent.com/misakaio/chnroutes2/master/chnroutes.txt&#039; | awk &#039;NR &gt; 2 {printf&quot;%s,\\n&quot;, $1}&#039; | sed &#039;:label;N;s/\\n/ /;b label&#039;|sed &#039;s/$/&amp; }/g&#039;|sed &#039;s/^/define chnroute_ipv4 = { &amp;/g&#039; &gt; ipv4-chnroute.nft\nnftables 规则\n#!/usr/bin/nft -f\n \nflush ruleset\n \n# include &quot;/etc/nftables.d/ipv4-whitelist.nft&quot;\ninclude &quot;/etc/nftables.d/ipv4-private.nft&quot;\ninclude &quot;/etc/nftables.d/ipv4-chnroute.nft&quot;\n \ndefine DIRECT-IPV4 = {\n    $whitelist_ipv4,\n    $private_ipv4,\n    $chnroute_ipv4,\n}\n \ntable inet firewall {\n  chain input {\n    type filter hook input priority 0; policy drop;\n \n    udp dport dhcpv6-client accept\n \n    # loopback interface\n    iif &quot;lo&quot; accept comment &quot;Accept any localhost traffic&quot;\n    iif != &quot;lo&quot; ip daddr 127.0.0.0/8 counter packets 0 bytes 0 drop comment &quot;drop connections to loopback not coming from loopback&quot;\n    ct state invalid log prefix &quot;Invalid-Input: &quot; level info flags all counter packets 0 bytes 0 drop comment &quot;Drop invalid connections&quot;\n \n    # icmp\n    icmp type echo-request limit rate 20 bytes/second burst 500 bytes counter packets 0 bytes 0 accept comment &quot;No ping floods&quot;\n    icmp type echo-request drop comment &quot;No ping floods&quot;\n    ct state { established, related } counter packets 0 bytes 0 accept comment &quot;Accept traffic originated from us&quot;\n    icmp type { destination-unreachable, router-advertisement, router-solicitation, time-exceeded, parameter-problem } accept comment &quot;Accept ICMP&quot;\n    ip protocol igmp accept comment &quot;Accept IGMP&quot;\n \n    # open tcp ports: sshd (22), httpd (80)\n    tcp dport { ssh } ct state new limit rate 15/minute log prefix &quot;New SSH Connection: &quot; counter accept comment &quot;Avoid brute force on SSH&quot;\n    tcp dport { 80, 443 } ct state new accept comment &quot;Accept web service&quot;\n  }\n}\n \ntable inet clash {\n    chain clash-tproxy {\n        # debug\n        # meta l4proto { tcp, udp } meta nftrace set 1\n \n        meta l4proto { tcp, udp } meta mark set 1 tproxy to :7893 accept\n    }\n \n    chain clash-mark {\n        meta mark set 1\n    }\n \n    chain mangle-output {\n        type route hook output priority mangle; policy accept;\n        fib daddr type { unspec, local, anycast, multicast } accept\n        ip daddr $DIRECT-IPV4 accept\n        meta l4proto { tcp, udp } th dport 1-1024 mark != 1 ct direction original jump clash-mark\n    }\n \n    chain mangle-prerouting {\n        type filter hook prerouting priority mangle; policy accept;\n        meta l4proto { tcp, udp } th dport 53 accept\n        fib daddr type { unspec, local, anycast, multicast } accept\n        ip daddr $DIRECT-IPV4 accept\n        # dport 1-1024 避免BT走代理\n        iif { lo } meta l4proto { tcp, udp } th dport 1-1024 ct direction original jump clash-tproxy\n    }\n}"},"A计科工程/主机运维/Linux/Raspi/树莓派折腾记录":{"title":"树莓派折腾记录","links":[],"tags":["TODO"],"content":"\n安装系统\ndd bs=4M if=/path/to/os.img of=/dev/sda\n \n# 挂载 boot 分区后，创建 ssh 文件\n# mount /dev/sda1 /mnt\ntouch ssh\n \n# wifi(2.5G) 自动连接，创建 wpa_supplicant.conf，内容如下\nctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev\nupdate_config=1\n \nnetwork={\n  ssid=&quot;WIFI 名&quot;\n  psk=&quot;WIFI 密码&quot;\n}\n \nnetwork={\n  ssid=&quot;WIFI 名&quot;\n  psk=&quot;WIFI 密码&quot;\n}"},"A计科工程/主机运维/Linux/Tools/SMB":{"title":"SMB","links":[],"tags":[],"content":"apt install samba\n\n配置\n推荐备份原配置文件，然后新建。\nmv /etc/samba/smb.conf /etc/samba/smb.conf.bak\r\n\r\nvim /etc/samba/smb.conf\r\n\n"},"A计科工程/主机运维/Linux/Tools/ZFS":{"title":"ZFS","links":[],"tags":[],"content":"# debian\r\nsudo apt install zfsutils-linux\r\n\r\n\r\n# 创建池\r\nzpool create [pool_name] /dev/sda\n"},"A计科工程/主机运维/Linux/Tools/dd":{"title":"dd","links":[],"tags":[],"content":"Ubuntu 使用 dd 命令制作 U 盘系统启动盘\n【dd 命令是比较推荐的一种 Linux 环境中制作 U 盘启动盘的方式，无需安装额外的工具，基本上所有 Linux 发行版都集成了这个命令。】\n制作方法示例：\n1.查看 U 盘设备号，本例使用了 8G 的 U 盘，并且知道计算机安装了两块硬盘，那么 U 盘设备号就可以根据大小和硬盘数量很容易的分辨出来”/dev/sdc”\nroot :~$ sudo fdisk -l\r\nDisk /dev/sdc: 8011 MB, 8011120640 bytes\n\n2.如果 U 盘被自动挂载，请使用 U 盘设备号先 umount\nroot :~$ sudo umount /dev/sdc*\n\n3.准备好一个 iso 文件，使用 dd 命令将这个 iso 写入 u 盘\nroot :~$ sudo dd if=~/ubuntu-16.04-desktop-amd64.iso of=/dev/sdc\r\n# if=后面跟要刻录到u盘的iso文件路径\r\n# of=后面是u盘设备号（不需要带分区号）\r\n# 写入过程是没有数据显示的，只要输出和输入路径没错，耐心等待即可，根据U盘读写速度以及iso文件大小，一般需要5~10分钟左右\n\n因为是使用 dd 命令直接将将 iso 文件数据写入 U 盘，所以 U 盘不包含一个标准的分区表，从而导致系统无法正常的识别其大小，也无法正常使用，使用它安装系统后，如果不需要 U 盘安装盘了，可以使用下面的方法来恢复 U 盘。\n恢复 U 盘示例：\n#操作前请用sudo fdisk -l  查看U盘分区号，请谨慎操作，不要误写硬盘分区，本例U盘分区号是/dev/sdc\r\n\r\n#1.使用dd命令，将0写入U盘的前512字节（代表主引导记录中的引导代码和分区表）\r\n\r\nsudo dd count=1 bs=512 if=/dev/zero of=/dev/sdc\r\n\r\n# count=1，写入一次\r\n# bs=512，写入的大小512（byte）\r\n# if=/dev/zero，从系统0生成器读取0\r\n# of=/dev/sdc，写入到U盘中\r\n\r\n#2.使用fdisk分区（最好先使用p查看一下还有没有分区，如果第一步操作无误，p将查看不到分区，如果还保留着原有分区，则删除现有分区，重新创建分区），例如只重新划分了一个分区sdc1\r\n\r\nsudo fdisk /dev/sdc\r\n\r\n#查看现有分区，如果第一步成功，下面将看不到分区\r\n\r\n命令(输入 m 获取帮助)： p\r\n\r\nDisk /dev/sdc: 8019 MB\r\n\r\n#创建新分区，一路默认回车\r\n\r\n命令(输入 m 获取帮助)： n\r\n#将分区更改成NTFS类型，以便Win系统也能识别\r\n\r\n[size=1em]\r\n21\r\n命令(输入 m 获取帮助)： t\r\n\r\n[size=1em]\r\n22\r\nSelected partition 1\r\n\r\n[size=1em]\r\n23\r\nHex code (type L to list codes): 7\r\n\r\n[size=1em]\r\n24\r\nChanged system type of partition 1 to 7 (HPFS/NTFS/exFAT)\r\n\r\n#保存\r\n\r\n命令(输入 m 获取帮助)： w\r\n#3.重新将U盘拔出插入，如果分区自动挂载，请先卸载，然后对该分区进行格式化，格式化成fat是为了让Windows也能识别（mkfs格式化ntfs非常慢，如果想要格式化成ntfs的，可以用mkfs.ntfs替换）\r\n\r\nroot :~$ sudo umount /dev/sdc1\r\n\r\nroot :~$ sudo mkfs.fat /dev/sdc1\n\nPs：dd 命令直接将 Linux 的 iso 写入 U 盘就能开机引导的原因是，这些 Linux 的 iso 自带了引导文件。"},"A计科工程/主机运维/Linux/Tools/dmesg":{"title":"dmesg","links":[],"tags":[],"content":"dmesg 命令用于显示系统开机信息，可用于诊断系统故障。\n内核会将系统开机信息存储在 ring buffer 中，可以使用 dmesg 命令来查看，开机信息保存在/var/log/dmesg文件中。\n命令语法\ndmesg [options]\n选项说明\n-c  #显示信息后，清除 ring buffer 中的内容\n-s&lt;缓冲区大小&gt;  #默认值为 8196，刚好等于 ring buffer 的大小\n-n  #设置记录信息的层级\n-D  #禁用打印消息到控制台\n-E  #启用打印消息到控制台\n-h  #打印帮助文本并退出\n-k  #打印内核消息\n-n  #设置将消息记录到控制台的级别\n-r  #打印原始消息缓冲区\n-s  #使用多少大小的缓冲区来查询内核环缓冲区。默认情况下为 16392\n-T  #打印人类可读时间戳\n-t  #不打印内核的时间戳\n-u  #打印用户空间消息\n-V  #输出版本信息并退出\n-x  #将设施和级别（优先级）编号解码为可读的前缀\n应用举例\n查看前 20 行开机信息\r\ndmesg | head -n 20\n[root@centos7 ~]# dmesg | head -n 20\n[    0.000000] Initializing cgroup subsys cpuset\n[    0.000000] Initializing cgroup subsys cpu\n[    0.000000] Initializing cgroup subsys cpuacct\n[    0.000000] Linux version 3.10.0-1127.18.2.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) ) #1 SMP Sun Jul 26 15:27:06 UTC 2020\n[    0.000000] Command line: BOOT_IMAGE=/vmlinuz-3.10.0-1127.18.2.el7.x86_64 root=/dev/mapper/centos-root ro crashkernel=auto spectre_v2=retpoline rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet LANG=en_US.UTF-8\n[    0.000000] Disabled fast string operations\n[    0.000000] e820: BIOS-provided physical RAM map:\n[    0.000000] BIOS-e820: [mem 0x0000000000000000-0x000000000009ebff] usable\n[    0.000000] BIOS-e820: [mem 0x000000000009ec00-0x000000000009ffff] reserved\n[    0.000000] BIOS-e820: [mem 0x00000000000dc000-0x00000000000fffff] reserved\n[    0.000000] BIOS-e820: [mem 0x0000000000100000-0x000000003fedffff] usable\n[    0.000000] BIOS-e820: [mem 0x000000003fee0000-0x000000003fefefff] ACPI data\n[    0.000000] BIOS-e820: [mem 0x000000003feff000-0x000000003fefffff] ACPI NVS\n[    0.000000] BIOS-e820: [mem 0x000000003ff00000-0x000000003fffffff] usable\n[    0.000000] BIOS-e820: [mem 0x00000000f0000000-0x00000000f7ffffff] reserved\n[    0.000000] BIOS-e820: [mem 0x00000000fec00000-0x00000000fec0ffff] reserved\n[    0.000000] BIOS-e820: [mem 0x00000000fee00000-0x00000000fee00fff] reserved\n[    0.000000] BIOS-e820: [mem 0x00000000fffe0000-0x00000000ffffffff] reserved\n[    0.000000] NX (Execute Disable) protection: active\n[    0.000000] SMBIOS 2.4 present.\n查看与内存相关的开机信息\r\ndmesg | grep -i memory\n[root@centos7 ~]# dmesg | grep -i memory\n[    0.000000] Base memory trampoline at [ffff9102c0098000] 98000 size 24576\n[    0.000000] crashkernel=auto resulted in zero bytes of reserved memory.\n[    0.000000] Early memory node ranges\n[    0.000000] PM: Registered nosave memory: [mem 0x0009e000-0x0009efff]\n[    0.000000] PM: Registered nosave memory: [mem 0x0009f000-0x0009ffff]\n[    0.000000] PM: Registered nosave memory: [mem 0x000a0000-0x000dbfff]\n[    0.000000] PM: Registered nosave memory: [mem 0x000dc000-0x000fffff]\n[    0.000000] PM: Registered nosave memory: [mem 0x3fee0000-0x3fefefff]\n[    0.000000] PM: Registered nosave memory: [mem 0x3feff000-0x3fefffff]\n[    0.000000] Memory: 972140k/1048576k available (7784k kernel code, 524k absent, 75912k reserved, 5958k data, 1980k init)\n[    0.000000] please try &#039;cgroup_disable=memory&#039; option if you don&#039;t want memory cgroups\n[    0.755288] Initializing cgroup subsys memory\n[    1.619645] x86/mm: Memory block size: 128MB\n[    3.669071] Freeing initrd memory: 20628k freed\n[    3.933907] Non-volatile memory driver v1.3\n[    3.935079] crash memory driver: version 1.1\n[    4.000261] Freeing unused kernel memory: 1980k freed\n[    4.001692] Freeing unused kernel memory: 396k freed\n[    4.003171] Freeing unused kernel memory: 540k freed\n[    5.956205] [drm] Max dedicated hypervisor surface memory is 0 kiB\n[    5.956206] [drm] Maximum display memory size is 32768 kiB\n[    5.968934] [TTM] Zone  kernel: Available graphics memory: 497842 kiB\n查看与磁盘相关的开机信息\r\ndmesg | grep -i disk\n[root@centos7 ~]# dmesg | grep -i disk\n[    0.000000] RAMDISK: [mem 0x357a7000-0x36bcbfff]\n[    3.738914] VFS: Disk quotas dquot_6.5.2\n[    4.013333] systemd[1]: Running in initial RAM disk.\n[    6.295432] sd 0:0:0:0: [sda] Attached SCSI disk\n[root@centos7 ~]# dmesg | grep -i sda\n[    6.291698] sd 0:0:0:0: [sda] 41943040 512-byte logical blocks: (21.4 GB/20.0 GiB)\n[    6.291830] sd 0:0:0:0: [sda] Write Protect is off\n[    6.291831] sd 0:0:0:0: [sda] Mode Sense: 61 00 00 00\n[    6.292032] sd 0:0:0:0: [sda] Cache data unavailable\n[    6.292033] sd 0:0:0:0: [sda] Assuming drive cache: write through\n[    6.294046]  sda: sda1 sda2\n[    6.295432] sd 0:0:0:0: [sda] Attached SCSI disk\n[   15.843965] XFS (sda1): Mounting V5 Filesystem\n[   16.778908] XFS (sda1): Starting recovery (logdev: internal)\n[   16.801659] XFS (sda1): Ending recovery (logdev: internal)"},"A计科工程/主机运维/Linux/Tools/fd":{"title":"fd","links":[],"tags":["linux"],"content":"FD\nFd 是一个在你文件系统中查找条目的程序。它是一个简单、快速、友好的 find 替代品。虽然它的目标不是支持 find 的所有强大功能，但它为大多数的使用情况提供了合理的（有意见的）默认值。\n安装\n# Windows\nwinget install sharkdp.fd\n \n参考链接"},"A计科工程/主机运维/Linux/Tools/iptables":{"title":"iptables","links":[],"tags":[],"content":"53 → 9053\niptables -t nat -A PREROUTING -p tcp --dport 53 -j REDIRECT --to-ports 9053\niptables -t nat -A PREROUTING -p udp --dport 53 -j REDIRECT --to-ports 9053"},"A计科工程/主机运维/Linux/Tools/iwd":{"title":"iwd","links":[],"tags":["TODO","network","linux"],"content":"IWD\n\nwiki.archlinux.org/title/Iwd"},"A计科工程/主机运维/Linux/Tools/lsof":{"title":"lsof","links":[],"tags":["linux"],"content":"LSOF 简易教程\nLsof(list open files) 是一个查看当前系统文件的工具。在 linux 环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，该文件描述符提供了大量关于这个应用程序本身的信息。\nlsof 打开的文件可以是：\n\n普通文件\n目录\n网络文件系统的文件\n字符或设备文件\n(函数) 共享库\n管道，命名管道\n符号链接\n网络文件（例如：NFS file、网络 socket，unix 域名 socket）\n还有其它类型的文件\n\n\n命令参数\n\n-a 列出打开文件存在的进程\n-c&lt;进程名&gt; 列出指定进程所打开的文件\n-g 列出 GID 号进程详情\n-d&lt;文件号&gt; 列出占用该文件号的进程\n+d&lt;目录&gt; 列出目录下被打开的文件\n+D&lt;目录&gt; 递归列出目录下被打开的文件\n-n&lt;目录&gt; 列出使用 NFS 的文件\n-i&lt;条件&gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip）\n-p&lt;进程号&gt; 列出指定进程号所打开的文件\n-u 列出 UID 号进程详情\n-h 显示帮助信息\n-v 显示版本信息\n\nHelp Information\nlsof: illegal option character: -\nlsof: -e not followed by a file system path: &quot;lp&quot;\nlsof 4.98.0\n latest revision: github.com/lsof-org/lsof\n latest FAQ: github.com/lsof-org/lsof/blob/master/00FAQ\n latest (non-formatted) man page: github.com/lsof-org/lsof/blob/master/Lsof.8\n usage: [-?abhHKlnNoOPRtUvVX] [+|-c c] [+|-d s] [+D D] [+|-E] [+|-e s] [+|-f[gG]]\n [-F [f]] [-g [s]] [-i [i]] [+|-L [l]] [+m [m]] [+|-M] [-o [o]] [-p s]\n [+|-r [t]] [-s [p:s]] [-S [t]] [-T [t]] [-u s] [+|-w] [-x [fl]] [--] [names]\nDefaults in parentheses; comma-separated set (s) items; dash-separated ranges.\n  -?|-h list help          -a AND selections (OR)     -b avoid kernel blocks\n  -c c  cmd c ^c /c/[bix]  +c w  COMMAND width (9)    +d s  dir s files\n  -d s  select by FD set   +D D  dir D tree *SLOW?*   +|-e s  exempt s *RISKY*\n  -i select IPv[46] files  -K [i] list|(i)gn tasKs    -l list UID numbers\n  -n no host names         -N select NFS files        -o list file offset\n  -O no overhead *RISKY*   -P no port names           -Q allow failed search\n  -R list paRent PID       -s list file size          -t terse listing\n  -T disable TCP/TPI info  -U select Unix socket      -v list version info\n  -V verbose search        +|-w  Warnings (+)         -X skip TCP&amp;UDP* files\n  -H human readable size   -- end option scan\n  -E display endpoint info              +E display endpoint info and files\n  +f|-f  +filesystem or -file names     +|-f[gG] flaGs\n  -F [f] select fields; -F? for help\n  +|-L [l] list (+) suppress (-) link counts &lt; l (0 = all; default = 0)\n                                        +m [m] use|create mount supplement\n  +|-M   portMap registration (-)       -o o   o 0t offset digits (8)\n  -p s   exclude(^)|select PIDs         -S [t] t second stat timeout (15)\n  -T fqs TCP/TPI Fl,Q,St (s) info\n  -g [s] exclude(^)|select and print process group IDs\n  -i i   select by IPv[46] address: [46][proto][@host|addr][:svc_list|port_list]\n  +|-r [t[m&lt;fmt&gt;]] repeat every t seconds (15);  + until no files, - forever.\n       An optional suffix to t is m&lt;fmt&gt;; m must separate t from &lt;fmt&gt; and\n      &lt;fmt&gt; is an strftime(3) format for the marker line.\n  -s p:s  exclude(^)|select protocol (p = TCP|UDP) states by name(s).\n  -u s   exclude(^)|select login|UID set s\n  -x [fl] cross over +d|+D File systems or symbolic Links\n  names  select named files or files on named file systems\nOnly root can list all files; /dev warnings disabled; kernel ID check disabled.\n实例\n\n\n查找某个文件的进程\r\nlsof [file]\n\n\n列出某个用户打开的文件信息\r\nlsof -u [username]\n\n\n列出某个进程打开的所有文件信息\r\nlsof -c [process]\n\n\n列出所有网络连接\r\nlsof -i\n\n\n查看某个端口被谁占用\r\nlsof -i:[port]\n\n\n参考文档\nLSOF Source Code\r\nLSOF 教程"},"A计科工程/主机运维/Linux/Tools/mpv":{"title":"mpv","links":[],"tags":[],"content":"安装\nmpv player for Windows"},"A计科工程/主机运维/Linux/Tools/podman":{"title":"podman","links":[],"tags":[],"content":"常用命令\n\n搜索镜像：podman search alpine\n下载镜像：podman pull alpine\n查看镜像：podman images\n查看已运行的容器：podman ps\n运行停止的容器：podman start [con_name]\n\n配置镜像源\nvim /etc/containers/register.conf\n配置内容：\nunqualified-search-registries = [&quot;docker.io&quot;]\r\n\r\n[[registry]]\r\nprefix = &quot;docker.io&quot;\r\nlocation = &quot;9gzrq6w1.mirror.aliyuncs.com&quot;\n"},"A计科工程/主机运维/Linux/Tools/ripgrep":{"title":"ripgrep","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/Tools/screen":{"title":"screen","links":[],"tags":[],"content":"tmux\n语法\nscreen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s &lt;shell&gt;][-S &lt;作业名称&gt;]\r\n\r\n**参数说明**：\r\n\r\n-   -A 　将所有的视窗都调整为目前终端机的大小。\r\n-   -d&lt;作业名称&gt; 　将指定的screen作业离线。\r\n-   -h&lt;行数&gt; 　指定视窗的缓冲区行数。\r\n-   -m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。\r\n-   -r&lt;作业名称&gt; 　恢复离线的screen作业。\r\n-   -R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。\r\n-   -s&lt;shell&gt; 　指定建立新视窗时，所要执行的shell。\r\n-   -S&lt;作业名称&gt; 　指定screen作业的名称。\r\n-   -v 　显示版本信息。\r\n-   -x 　恢复之前离线的screen作业。\r\n-   -ls或--list 　显示目前所有的screen作业。\r\n-   -wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。\n\n实例\n创建 screen 终端\r\n\r\n# screen //创建 screen 终端\r\n\r\n创建 screen 终端 并执行任务\r\n\r\n# screen vi ~/main.c //创建 screen 终端 ，并执行 vi命令\r\n\r\n离开 screen 终端\r\n\r\n# screen vi ~/main.c //创建 screen 终端 ，并执行 vi命令 #include main () { } &quot;~/mail.c&quot; 0,0-1 在 screen 终端 下 按下 Ctrl+a d 重新连接离开的 screen 终端\r\n\r\n# screen -ls  //显示已创建的screen终端\r\nThere are screens on:\r\n\t\t2433.pts-3.linux (2013年10月20日 16时48分59秒) (Detached)\r\n\t\t2428.pts-3.linux (2013年10月20日 16时48分05秒) (Detached)\r\n\t\t2284.pts-3.linux (2013年10月20日 16时14分55秒) (Detached)\r\n\t\t2276.pts-3.linux (2013年10月20日 16时13分18秒) (Detached)\r\n4 Sockets in /var/run/screen/S-root.\r\n# screen -r 2276 //连接 screen_id 为 2276 的 screen终端\n"},"A计科工程/主机运维/Linux/Tools/tmux":{"title":"tmux","links":[],"tags":[],"content":"Tmux\n会话 (Session)\n窗口 (Window)\n窗格 (Pane)"},"A计科工程/主机运维/Linux/Wireshark":{"title":"Wireshark","links":[],"tags":["TODO"],"content":"Wireshark 教程\n安装配置\n# archlinux\nsudo pacman -S wireshark-qt\n将用户添加到 wireshark 用户组，避免使用 root 运行。\nsudo usermod -aG wireshark $USER\nReferences\n\nwiki.archlinux.org/title/Wireshark\nwiki.wireshark.org/CaptureSetup/CapturePrivileges#most-unixes\n"},"A计科工程/主机运维/Linux/bees":{"title":"bees","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/btrfs":{"title":"btrfs","links":["写时复制","Bees"],"tags":["linux","doc","TODO","btrfs"],"content":"Btrfs\nBTRFS 是一种现代的写时复制（COW）Linux 文件系统，致力于实现一些高级功能，\r\n同时着重于容错性、修复性以及易于管理性。\n\n特性\n子卷 (subvolue)\n分区方案\n挂载\n推荐删除 ssd,discard=async,space_cache=v2,subvolid=xxx 等这些由系统自动决定的挂载选项，\r\n保留 rw,relatime,compress=zstd:3,subvol=@xxx 等以及其他你认为需要保留的挂载选项。\n快照\n工具推荐：btrfs-assistant, snapper\n\n\n                  \n                  Btrfs 的快照功能不能取代备份，它相当于 Git 版本控制。同一份文件只会存在一份在硬盘。 \n                  \n                \n\n因此，需要备份的时候需要保存到其他硬盘。\n备份\n\n简单备份\n\nbtrfs send /root_backup | btrfs receive /backup\n\n增量备份\n\nbtrfs send -p /root_backup /root_backup_new | btrfs receive /backup\nroot_backup 快照名，backup 存放文件夹，root_backup_new 增量快照名\n去重\nBees 是一款专用于 btrfs 文件系统的去重工具。\nReferences\n\nbtrfs.readthedocs.io/en/latest/index.html\nwiki.archlinux.org/title/Btrfs\n"},"A计科工程/主机运维/Linux/cgit-搭建":{"title":"cgit 搭建","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/dnsmasq":{"title":"dnsmasq","links":[],"tags":["TODO","DNS","Linux","Doc"],"content":"Dnsmasq\n1 基础配置\n要在单台计算机上将 dnsmasq 设置为 DNS 缓存守护程序，请指定 listen-address 指令，添加本地主机 IP 地址：\nlisten-address=::1,127.0.0.1\n2 进阶配置"},"A计科工程/主机运维/Linux/fdisk":{"title":"fdisk","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/fish":{"title":"fish","links":[],"tags":["fish","shell","linux","arch"],"content":"\nFish 作为 login shell\n当 fish 作为登陆 shell 时，环境变量无法传到 firefox, 导致 fcitx5 无法使用，需要在 /etc/environment 添加相关变量。\n\n\n                  \n                  Note\n                  \n                \n\n原因其实就是我的 wayfire 是在登陆 shell 时自动启动的，但是环境相关的变量在启动 wayfire 的后面，导致变量无法传递。\n\n"},"A计科工程/主机运维/Linux/flatpak":{"title":"flatpak","links":[],"tags":[],"content":"安装\nsudo dnf install flatpak"},"A计科工程/主机运维/Linux/freedos":{"title":"freedos","links":["E临时笔记/qemu"],"tags":["qemu","dos","Doc","TODO","freedos","linux"],"content":"Freedos\nqemu 安装\n前往官网下载最新的镜像。Freedos\n# create freedos.img\nqemu-img create -f raw freedos.img 200M\n \n# setup\nqemu-system-i386 -rtc base=localtime -hda freedos.img -cdrom FD12CD.iso -boot d\n \n# boot\nqemu-system-i386 -rtc base=localtime -hda freedos.img\n第一次安装时，需要先对磁盘分区，分区完成后，重新进入安装步骤。\n\n\n                  \n                  Note\n                  \n                \n\n镜像的格式不要选择 qcow 等其他格式。镜像大小为 100-500M, 如果要安装全部软件和游戏，至少要 500M 以上，否则会安装失败。\n\n\nfreedos 安装过程\nyoutu.be/xXkmOwLPpcg\n安装软件\nReferences\nen.wikibooks.org/wiki/QEMU/FreeDOS"},"A计科工程/主机运维/Linux/gnome-keyring":{"title":"gnome-keyring","links":[],"tags":["TODO"],"content":"参考\ngnome-keyring-archwiki"},"A计科工程/主机运维/Linux/iproute2":{"title":"iproute2","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/nftables":{"title":"nftables","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/smartdns":{"title":"smartdns","links":[],"tags":["TODO","dns","smartdns"],"content":"SMARTDNS\n"},"A计科工程/主机运维/Linux/steam-游戏平台":{"title":"steam 游戏平台","links":[],"tags":["TODO"],"content":""},"A计科工程/主机运维/Linux/systemd-boot":{"title":"systemd-boot","links":[],"tags":[],"content":""},"A计科工程/主机运维/Linux/systemd":{"title":"systemd","links":[],"tags":["TODO","linux"],"content":""},"A计科工程/主机运维/Linux/wayland-使用指南":{"title":"wayland 使用指南","links":[],"tags":["TODO","wayland","wayfire","x11","electron"],"content":"虽然 wayland 发展迅速，替换 x11 已是板上钉钉，但是目前还是存在很多问题，而且离不开 wayland。\n在尝试一段时间的 pure wayland 后，我当前遇到的问题有两个：\n\nelectron 应用无法使用输入法（应用相当多，无法舍弃）\njetbrains 系软件无法使用（牺牲体验，可替换）\n\nxwayland\nxwayland 缩放\n\n使用依云打包的 xwayland（xorg-xwayland-lily-git/xorg-xwayland-hidpi-git）\nelectron 应用使用 --force-device-scale-factor=2 强制设置缩放\n"},"A计科工程/主机运维/Linux/搭建私人Gitlab":{"title":"搭建私人Gitlab","links":[],"tags":["TODO"],"content":"试用 gitlab-ce 搭建私人 git 管理服务器。\r\n内存要求&gt;4GB\npodman run --detach --hostname git.52bilibili.com --publish 8883:443 --publish 8880:80 --publish 8882:22 --name gitlab --restart always --volume /srv/gitlab/config:/etc/gitlab --volume /srv/gitlab/logs:/var/log/gitlab --volume /srv/gitlab/data:/var/opt/gitlab gitlab/gitlab-ce:latest\n\n"},"A计科工程/主机运维/Rsync":{"title":"Rsync","links":[],"tags":["TODO","rsync"],"content":"Rsync\nRsync 是一个提供快速增量文件传输的开源实用程序。\n\n参考链接"},"A计科工程/主机运维/Scrapy":{"title":"Scrapy","links":[],"tags":[],"content":"简单入门\n第一步新建一个项目：\nscrapy startproject tutorial\n然后就会生成一个 tutorial 的目录，包含以下内容：\ntutorial/\r\n    scrapy.cfg            # deploy configuration file\r\n\r\n    tutorial/             # project&#039;s Python module, you&#039;ll import your code from here\r\n        __init__.py\r\n\r\n        items.py          # project items definition file\r\n\r\n        middlewares.py    # project middlewares file\r\n\r\n        pipelines.py      # project pipelines file\r\n\r\n        settings.py       # project settings file\r\n\r\n        spiders/          # a directory where you&#039;ll later put your spiders\r\n            __init__.py\n\nScrapy"},"A计科工程/主机运维/Truenas-Scale":{"title":"Truenas Scale","links":[],"tags":[],"content":"emby 开心版 硬解\n进入 emby 容器命令行，chmod 777 /dev/dri/renderD128"},"A计科工程/主机运维/Windows-subsystem-Linux":{"title":"Windows subsystem Linux","links":[],"tags":[],"content":"管理员运行：\nEnable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux\n \n \nwsl --set-default-version 2"},"A计科工程/主机运维/Windows/MSVC-环境搭建":{"title":"MSVC 环境搭建","links":[],"tags":["TODO","msvc","windows"],"content":"MSVC 环境搭建\n为了避免安装 Visual Studio 这样的庞然大物，选择安装  Visual Studio 20xx Build Tools, 并且可以独立安装。VS 默认安装位置为 Program Files ，BT 安装位置为 Program Files (x86)\n\n下载\n下载 Visual Studio Tools - 免费安装 Windows、Mac、Linux (microsoft.com) → 用于 Visual Studio 的工具 → Visual Studio 20xx 生成工具\n安装\n\n参考链接"},"A计科工程/主机运维/Windows/WSL":{"title":"WSL","links":[],"tags":["TODO","windows","wsl"],"content":"WSL\n安装\nwsl --update\n配置\nWSL 发行版的配置文件在/etc/wsl.conf,\n网络配置\nWSL 子系统 SSH 服务配置\n\n在 Linux 子系统中安装 SSH 服务器并启动\nWindows 宿主机配置端口转发\n防火墙配置\n\n\n参考链接"},"A计科工程/主机运维/Windows/Windows-笔记":{"title":"Windows 笔记","links":[],"tags":["TODO","dns"],"content":"Windows 笔记\n\n后台运行\n新建 bat 文件，并在开头加入以下代码：\nif &quot;%1&quot;==&quot;hide&quot; goto CmdBegin\nstart mshta vbscript:createobject(&quot;wscript.shell&quot;).run(&quot;&quot;&quot;%~0&quot;&quot; hide&quot;,0)(window.close)&amp;&amp;exit\n:CmdBegin\nDNS 缓存\nipconfig /displaydns\nipconfig /flushdns\nGet-DnsClientCache\nClear-DnsClientCache\nAMD 右键菜单\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Classes\\PackagedCom\\Package\nAdvancedMicroDevicesInc-2.AMDRadeonSoftware_ → server\n删除 ApplicationId 的值\nFontlink 字体映射\nFontlink 是 Windows 采用的一种类似虚拟字体的技术。使用 Fontlink 时，某个字体可以和多个其它的字体建立连接关系。连接后，该字体通常被称作主字体，而其它那些与之连接的字体称作连接字体。例如我们将主字体 Fira Code 映射一个连接字体方正兰亭黑，在输出英文时会以主字体 Fira Code 显示；而在输出中文时，Windows 在主字体 Fira Code 中没有找到支持中文的字体信息，那么会在连接字体方正兰亭黑中继续搜索，显然方正兰亭黑是支持中文的，所以输出中文时会以方正兰亭黑显示，美观多了。\nHKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\FontLink\\SystemLink\n参考链接"},"A计科工程/主机运维/Yolo":{"title":"Yolo","links":[],"tags":[],"content":"环境搭建\nWindows\nYOLOv8 Dataset\n\ntest\n\nimages\nlabels\n\n\ntrain\n\nimages\nlabels\n\n\nval\n\nimages\nlabels\n\n\n"},"A计科工程/主机运维/cgit":{"title":"cgit","links":[],"tags":[],"content":"cgit\nCgit 是一个 git 仓库的前端服务，使用 C 编写。内核的仓库就是用的这个。\nnote: 将 cgit 仓库所有者设置为 git:www-data, 需要检查文件夹\r\n用户组的读写权限，如果没有写权限的话，git push 的时候会发生\r\nerror: remote unpack failed: unable to create temporary object directory 的错误。"},"A计科工程/主机运维/luks":{"title":"luks","links":[],"tags":["TODO"],"content":"LUKS 硬盘加密\n"},"A计科工程/主机运维/ubuntu":{"title":"ubuntu","links":[],"tags":[],"content":"安装输入法\nsudo apt install ibus-rime\n \nsudo apt install librime-data-double-pinyin\n \n配置文件\n更换内核\nsudo add-apt-repository ppa:cappelikan/ppa\n \nsudo apt update\n \nsudo apt install mainline\n中文字体显示异常\n sudo vim /etc/fonts/conf.d/64-language-selector-prefer.conf\n该文件配置了 Noto Sans CJK 的优先级。\n&lt;?xml version=&quot;1.0&quot;?&gt;\r\n&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;\r\n&lt;fontconfig&gt;\r\n        &lt;alias&gt;\r\n                &lt;family&gt;sans-serif&lt;/family&gt;\r\n                &lt;prefer&gt;\r\n                        &lt;family&gt;Noto Sans CJK SC&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans CJK JP&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans CJK KR&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans CJK TC&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans CJK HK&lt;/family&gt;\r\n                        &lt;family&gt;Lohit Devanagari&lt;/family&gt;\r\n                &lt;/prefer&gt;\r\n        &lt;/alias&gt;\r\n        &lt;alias&gt;\r\n                &lt;family&gt;serif&lt;/family&gt;\r\n                &lt;prefer&gt;\r\n                        &lt;family&gt;Noto Serif CJK SC&lt;/family&gt;\r\n                        &lt;family&gt;Noto Serif CJK JP&lt;/family&gt;\r\n                        &lt;family&gt;Noto Serif CJK KR&lt;/family&gt;\r\n                        &lt;family&gt;Noto Serif CJK TC&lt;/family&gt;\r\n                        &lt;family&gt;Lohit Devanagari&lt;/family&gt;\r\n                &lt;/prefer&gt;\r\n        &lt;/alias&gt;\r\n        &lt;alias&gt;\r\n                &lt;family&gt;monospace&lt;/family&gt;\r\n                &lt;prefer&gt;\r\n                        &lt;family&gt;Noto Sans Mono CJK SC&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans Mono CJK JP&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans Mono CJK KR&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans Mono CJK TC&lt;/family&gt;\r\n                        &lt;family&gt;Noto Sans Mono CJK HK&lt;/family&gt;\r\n                &lt;/prefer&gt;\r\n        &lt;/alias&gt;\r\n&lt;/fontconfig&gt;\n"},"A计科工程/主机运维/windwos":{"title":"windwos","links":[],"tags":[],"content":"终端\n\n终端清屏：cls\nnetstat\n"},"A计科工程/主机运维/域名":{"title":"域名","links":[],"tags":[],"content":""},"A计科工程/位运算":{"title":"位运算","links":[],"tags":["TODO","bit"],"content":"位运算\n位运算就是基于整数的二进制表示进行的运算。由于计算机内部就是以二进制来存储数据，位运算是相当快的。\n基本的位运算共 6 种，分别为按位与、按位或、按位异或、按位取反、左移和右移。\n\n运算\n与 或 异或\n与、或、异或都是将两个整数作为二进制数，对二进制表示中的每一位逐一运算。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算运算符数学符号表示解释与&amp;\\&amp;、and只有两个对应位都为 1 时才为 1或||、or只要两个对应位中有一个 1 时就为 1异或^\\oplus、xor只有两个对应位不同时才为 1\n异或运算的逆运算是它本身，也就是说两次异或同一个数最后结果不变，即 a\\oplus{b}\\oplus{b}=a\n\n\n                  \n                  Note\n                  \n                \n\n注意区分逻辑与（对应的数学符号为\\wedge）和按位与、逻辑或 (\\vee）和按位或的区别。络中的资料中使用的符号多有不规范之处，以上下文为准。\n\n\n取反\n取反是对一个数 num 进行的位运算，即单目运算。\n取反暂无默认的数学符号表示，其对应的运算符为 ~。它的作用是把 num 的二进制补码中的 0 和 1 全部取反 (0 变为 1，1 变为 0）。有符号整数的符号位在 ~ 运算中同样会取反。\n补码：在二进制表示下，正数和 0 的补码为其本身，负数的补码是将其对应正数按位取反后加一。\n左移 右移\nnum &lt;&lt; i 表示将 num 的二进制表示向左移动 i 位所得的值。\nnum &gt;&gt; i 表示将 num 的二进制表示向右移动 i 位所得的值。\n应用\n参考链接"},"A计科工程/操作系统/Freertos/Freertos":{"title":"Freertos","links":[],"tags":["TODO","freertos","rtos"],"content":"Freertos\n\n任务调度\n调度器就是使用相关的调度算法来决定当前需要执行哪个任务。\nFreeRTOS 支持三种任务调度方式\n\n抢占式: 主要针对优先级不同的任务，每个任务都有一个优先级，高优先级的任务会抢占低优先级任务。（数值越大优先级越高）\n时间片: 主要针对优先级相同的任务，当多个任务的优先级相同时，任务调度器会在每一次系统时钟节拍到的时候切换任务。\n协程式:\n\n任务状态\n\n运行态：正在执行的任务，处于运行态\n就绪态：已经能够被执行，但当前还未被执行\n阻塞态：任务因延时或等待外部事件发生，处于柱塞态\n挂起态：类似暂停，调用函数 vTaskSuspend() 进入挂起态，需要调用解挂函数 vTaskResume() 才可以进入就绪态\n\n除了运行态，其他三种任务状态的任务都有其对应的任务状态列表。\n四种任务状态之间的转换图：\r\n\n参考链接\nwww.freertos.org/"},"A计科工程/操作系统/Linux/信号":{"title":"信号","links":[],"tags":["TODO","linux","signal","kernel"],"content":"信号\n信号是一种软中断，信号机制是进程间通信的一种方式，采用异步通信方式。\n\n深入理解 Linux 内核——signals\n信号很早就在 unix 系统中出现了，它用于用户进程之间的交互，几十年以来，变化都不大。信号是一个发送给进程或者进程组的消息，它只是一个数字，没有参数或者其他辅助的信息。以 SIG 为前缀的宏定义表示着这些不同的信号数字。进程的信号主要有 2 个目的：\n\n告知进程一个特定的事件产生了\n触发进程去执行程序代码中处理信号的 signal handler\n\n信号的最大特点是它是异步的，也就是在进程执行的任意时刻信号都可能产生，此时进程的状态是不可知的。发送给进程的信号如果没有被执行，就会由内核将它保存起来，直到进程被唤醒开始执行。如果某个信号被进程配置为屏蔽，那么这个信号就会一直被挂起而不会被触发，直到它被 unblock。\nLinux 内核对信号传递过程中的 2 个阶段进行了区分：\n\nsignal generation：产生信号，此时由内核在目标进程中的对应数据结构中更新信号的状态，也就是挂个名先\nsignal delivery：信号被进程响应，内核将进程的执行流转到信号触发的 signal handler 中\n\n信号在进程中已经生成，不过还没有被响应的情况，我们称之为 pending signal。同一个类型的信号只会存在一个被挂起的情况，所以也就是在信号没有被响应前，重复发送多次的信号，进程也最终也只会响应一次。通常情况下，一个信号会被阻塞多久时间是不可知的，所以需要考虑信号的这些特点：\n\n进程只有在处于运行状态的时候才能够响应信号\n发送给进程的信号可能被进程主动选择屏蔽，这种情况下进程将不会响应这个信号\n一个进程在执行信号处理函数时，通常会将这个信号屏蔽直到处理结束，这样保证了不会同时响应相同的信号，信号的处理函数也就不必要求是可重入的\n\n进程对一个信号的响应存在下面 3 种情况：\n\n显式地忽略\n执行默认的流程，每个信号都有一个默认的处理方式，它们可能是：terminate、dump（终止并生成 core file）、ignore、stop、continue\n捕获信号，执行程序设定好的处理流程\n\n信号被 block 和 ignore 是不一样的，blocked 是进程没有收到信号，而 ignore 是收到了信号，而没有做任何处理。类似于一个人收到了信，不过直接将它丢进了垃圾桶，那就是 ignore，而如果直接拒收那份信，就是 blocked。\nSIGKILL &amp; SIGSTOP 是不能被 ignore、capture、block 的，它们的默认流程必须被执行，那就是杀死这个进程。\n按照 POSIX 要求，信号在多线程进程中的特性如下：\n\n信号应该被进程中的所有线程共享，不过每个线程有自己独有的 mask，用于配置 block 哪些信号\nkill() &amp; sigqueue() 库函数是对所有的线程发送信号，而不是特定的信号\n信号只会被其中一个线程响应，这个线程是所有没有屏蔽此信号的线程中的任意一个\n如果是致命信号，那么所有的线程都会被杀死\n\n实时信号\n除了 Linux 中使用的 1～31 的常规信号，POSIX 标准还定义了一个实时信号集，它们在 Linux 中的编号是 32～64。实时信号相比较于常规的信号，差别是常规的信号在同一时间同一类型的信号只允许触发一次，也就是重复发多次信号，进程只响应一次。而实时信号则是可以多个相同的信号在队列中排队，也就是重复发多少次信号，进程就会想要多少次。Linux 系统不使用实时信号，不过它通过一些特殊的系统调用来满足 POSIX 的标准。\n信号相关的数据结构\n下面这张图列出了信号相关的数据之间的关系：\n\n从图中可以看到，一个进程的信号等待队列有 2 个，一个是所有线程组共享的，存放在 signal 的 shared_pending 队列中，另一个则是私有的，存放在进程的 pending 队列中。之所以采用 2 个队列，是因为有的系统调用是给一个所有的线程发信号，比如 kill() &amp; rt_sigqueueinfo()，有的则是给指定的特定进程发送信号，比如 tkill() &amp; tgkill()。\n信号的产生\n许多的内核函数能够产生信号，它们通过修改进程描述符中关于信号相关的数据实现，剩下进程如何响应这个信号，它们不管。根据不同的信号类型，内核会选择是否立即唤醒进程并执行信号处理流程。不管信号是由内核生成还是由其他进程发起，都是内核调用相关的信号生成的函数，用于产生信号的函数很多：\n\nsend_sig\nsend_sig_info\nforce_sig\nforce_sig_info\nsys_tkill\nsys_tgkill\n\n我们追踪 send_sig 这个函数，看信号生成的实现细节，它大概的调用流程如下图所示：\n\n从系统调用 sys_kill 看用户空间向一个进程发送信号时，信号的产生过程：\nstatic inline void prepare_kill_siginfo(int sig, struct kernel_siginfo *info)\n{\n    clear_siginfo(info);\n    info-&gt;si_signo = sig;\n    info-&gt;si_errno = 0;\n    info-&gt;si_code = SI_USER;\n    info-&gt;si_pid = task_tgid_vnr(current);\n    info-&gt;si_uid = from_kuid_munged(current_user_ns(), current_uid());\n}\n \n/**\n *  sys_kill - send a signal to a process\n *  @pid: the PID of the process\n *  @sig: signal to be sent\n */\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n    struct kernel_siginfo info;\n \n    prepare_kill_siginfo(sig, &amp;info);\n \n    return kill_something_info(sig, &amp;info, pid);\n}\n首先，这里通过 prepare_kill_siginfo 填充 kernel_siginfo 这个结构体，这里面包含的是发送这个信号的一些信息，比如发送的来源、发起进程的 pid/uid 等。kill_something_info 中根据 pid 参数的值来确定它的操作：\n\npid &gt; 0，发送信号给对应这个 pid 的进程\npid = 0，发送信号给当前进程组中的所有进程\npid = -1，发送给当前用户拥有权限的所有进程（init 进程除外）\npid &lt; -1，发送信号给当前进程组中对应 -pid 的进程\n\n最终，都是调用 send_signal 这个函数，根据以上 pid 参数不同的值，选择 send_signal 函数不同的输入参数。主要是选择是对哪个 task 进行信号操作，以及这个 pid 所代表的 type，也就是信号的作用范围是怎样的，下面就是 pid 几种类型，信号传递的范围按照这个类型由小及大：\nenum pid_type\n{\n    PIDTYPE_PID,\n    PIDTYPE_TGID,\n    PIDTYPE_PGID,\n    PIDTYPE_SID,\n    PIDTYPE_MAX,\n};\n在 __send_signal 中，通过 __sigqueue_alloc 创建一个信号队列元素，然后添加到 pending 队列中，如果是 PIDTYPE_PID，就使用前面提及的私有的 pending 队列，否则就使用共享的 pending 队列。signalfd_noftify 则是通知 signalfd 文件，有信号发送过来了（signalfd 是将信号通过一个文件描述符进行接受，然后就可以在 select 这样的接口中监控它，具体信息请查看）。\nsigpending 的数据结构如下：\nstruct sigpending {\n    struct list_head list;\n    sigset_t signal;\n};\n第一项 list 就是信号等待队列的头，而第二项 signal 则是一个 64bit 的一个数据，它的每一个 bit 代表着对应编号的一个信号。如果对应的 bit 位被置位，那么就表示对应进程收到了这个序号的信号。__send_signal 中的 sigaddset 就是操作 signal，在对应的 bit 位上写 1。\ncomplete_signal 通过 signal_wake_up 在需要接受信号的 task 中设置标志位 TIF_SIGPENDING，完成信号的产生。如果是一个致命信号，那么这个线程所在的所有线程都需要被杀死，所以这个进程中的每一个进程都会被标记 TIF_SIGPENDING。\n信号的响应\n内核在每次跳转到用户空间之前，都会检查一下当前这个 task 的标志状态，如果前面所说的 TIF_SIGPENDING 标志被置位，那么就说明当前这个 task 有信号需要处理，内核就会开始进行信号的响应处理。下面是内核跳转到用户空间前的汇编代码 ret_to_user：\n/*\n * Ok, we need to do extra processing, enter the slow path.\n */\nwork_pending:\n    mov    x0, sp                // &#039;regs&#039;\n    bl    do_notify_resume\n#ifdef CONFIG_TRACE_IRQFLAGS\n    bl    trace_hardirqs_on        // enabled while in userspace\n#endif\n    ldr    x1, [tsk, #TSK_TI_FLAGS]    // re-check for single-step\n    b    finish_ret_to_user\n/*\n * &quot;slow&quot; syscall return path.\n */\nret_to_user:\n    disable_daif\n    gic_prio_kentry_setup tmp=x3\n    ldr    x1, [tsk, #TSK_TI_FLAGS]\n    and    x2, x1, #_TIF_WORK_MASK\n    cbnz    x2, work_pending\nfinish_ret_to_user:\n    enable_step_tsk x1, x2\n#ifdef CONFIG_GCC_PLUGIN_STACKLEAK\n    bl    stackleak_erase\n#endif\n    kernel_exit 0\nand x2, x1, #_TIF_WORK_MASK 这条指令判断当前的 task 判断标志，如果有需要处理的标志，那么就跳转到 work_pending，在这里判断如果有收到信号，那么就调用 do_signal 进行信号的响应。在 do_signal 函数定义前的注视说的比较清楚：\n/*\n * Note that &#039;init&#039; is a special process: it doesn&#039;t get signals it doesn&#039;t\n * want to handle. Thus you cannot kill init even with a SIGKILL even by\n * mistake.\n *\n * Note that we go through the signals twice: once to check the signals that\n * the kernel can handle, and then we build all the user-level signal handling\n * stack-frames in one go after that.\n */\nstatic void do_signal(struct pt_regs *regs)\ninit 进程是不接受信号的，所以它是杀不死的。do_signal 中会扫描看哪些信号是内核中就可以处理的，这样就需要为跳转到用户空间而创建一个处理信号用的用户空间栈帧。下面是它的调用流程：\n\n内核中对于信号的响应，主要做了 2 件事情，第一个是将本次响应的信号从队列中移除，另一个则是为用户空间的信号处理准备好环境。\nget_signal 中就是从队列中将信号取出，将它存储到一个 ksignal 的结构数据中：\nstruct ksignal {\n    struct k_sigaction ka;\n    kernel_siginfo_t info;\n    int sig;\n};\n这里面就包含了我们在响应信号时所需要的 3 个信息：信号编号、信号的处理方式、发送信号的附加信息。__dequeue_signal 从队列中移除此次信号，其中 sigdelset 是对标示信号的比特位进行清零操作（如果是实时信号，则可能不需要进行清空，因为运行多个相同的信号存在队列中），__sigqueue_free 则是对队列元素进行释放。完成了出队操作后，则通过 recalc_sigpending 来判断此进程是否还有在等待响应的信号，如果没有了，那么就清除 进程的 TIF_SIGPENDING 标志。\nhandle_signal 则是为用户空间准备好处理信号的环境。这个环境包含 3 个部分：一是保存进程被信号打断时的位置，这样以便信号处理完成后继续程序的执行；二是将进程的执行点转移到信号处理流程中，进行真正的信号响应；三是等用户空间的信号处理完毕后，它需要再次回到内核空间，让内核再把用户进程切换到信号中断前的位置处。当然许多的信号响应不需要进入用户空间进行处理，因为很多默认为 ignore 行为的信号直接在 get_signal 阶段就完成了，还有一下致命信号，直接就由内核去处理终止流程了。\n没当进程从用户空间进入内核空间的时候，用户空间当前的寄存器状态就会被保存在内核空间的栈中（这个是由异常处理入口处的汇编指令完成入栈），在内核中就是通过一个名为 pt_regs 结构数据指示着用户空间在进入内核前的寄存器。在信号处理响应流程中，当进程第一个从用户空间进入内核空间时，pt_regs 就包含着进程被信号打断前的上下文。而当内核回到用户空间的时候，这个上下文就会丢失，因为每次由用户空间进入内核空间的时候，内核的栈都是清空状态的。所以被信号打断前的硬件上下文就需要保存在用户空间的堆栈中，也就是我们准备环境的第一个部分，这部分的处理流程由 setup_sigframe完成。\n对于第二和第三部分的环境准备则是通过 setup_return 完成（下面是 ARM64 架构的实现）：\nstatic void setup_return(struct pt_regs *regs, struct k_sigaction *ka,\n             struct rt_sigframe_user_layout *user, int usig)\n{\n    __sigrestore_t sigtramp;\n \n    regs-&gt;regs[0] = usig;\n    regs-&gt;sp = (unsigned long)user-&gt;sigframe;\n    regs-&gt;regs[29] = (unsigned long)&amp;user-&gt;next_frame-&gt;fp;\n    regs-&gt;pc = (unsigned long)ka-&gt;sa.sa_handler;\n \n    if (ka-&gt;sa.sa_flags &amp; SA_RESTORER)\n        sigtramp = ka-&gt;sa.sa_restorer;\n    else\n        sigtramp = VDSO_SYMBOL(current-&gt;mm-&gt;context.vdso, sigtramp);\n \n    regs-&gt;regs[30] = (unsigned long)sigtramp;\n}\n信号中断前的硬件上下文已经通过 setup_sigframe 保存到了 user→subframe 中，所以在这个函数中，我们通过修改 pt_regs 来改变跳转到用户空间时的执行流。首先看 pc 寄存器被设置为了用户的信号处理函数，栈寄存器 sp 从 sigframe 开始。regs[0] 存储信号编号，按照 ARM64 的 ABI，它将作为信号处理函数的第一个输入参数。regs[29] 是 ARM64 栈帧指针，regs[30] 则是 LR 寄存器，也就是函数执行完毕后的返回地址，这里指向 VDSO 中的 rt_sigreturn 系统调用（定义在 arch/arm64/kernel/vdso/sigreturn.S 文件中）。也即是，用户执行完信号处理流程就会通过 rt_sigreturn 系统调用重新回到内核空间，再由内核调用 restore_sigframe 将用户进程的执行流程恢复到被信号中断时的状态。整个信号的处理流程入下图所示：\n\n前面我们说过 setup_sigframe 函数对用户的栈增加了一个栈帧用于保存恢复信号中断前的状态，接下来我们就看看这个栈帧的结构。这个新增栈帧的结构由 get_sigframe 函数规划，其结构通过结构体 rt_sigframe_user_layout 存储：\nstruct rt_sigframe_user_layout {\n    struct rt_sigframe __user *sigframe;\n    struct frame_record __user *next_frame;\n \n    unsigned long size;    /* size of allocated sigframe data */\n    unsigned long limit;    /* largest allowed size */\n \n    unsigned long fpsimd_offset;\n    unsigned long esr_offset;\n    unsigned long sve_offset;\n    unsigned long extra_offset;\n    unsigned long end_offset;\n};\n在 ARM64 架构上，signal frame 的结构如下图所示：\n\n参考链接\nwushifublog.com/2020/05/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%E5%86%85%E6%A0%B8%E2%80%94%E2%80%94signals/"},"A计科工程/正则表达式":{"title":"正则表达式","links":[],"tags":["TODO","regex","Doc"],"content":"运算优先级\n正则表达式与数学表达式的不同在于，数学表达式执行数学运算，而正则表达式执行字符运算；相同的是，它们都按一定的优先级进行运算。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n运算符操作\\转义符()捕获、匹配、断言[]字符类*+?限定符{}范围^$位置和顺序|或\nReferences\n\ndeerchao.cn/tutorials/regex/regex.html\ni.linuxtoy.org/docs/guide/ch26s03.html\n"},"A计科工程/现代化命令行":{"title":"现代化命令行","links":[],"tags":["TODO"],"content":"现代化命令行\n记录常用的 Linux 命令行工具的现代化替代品。重新设计、编写的\r\n工具能减少历史的缺陷和不合理。\n\nfd\nfd 是一个在你文件系统中查找条目的程序。它是一个简单、快速、友好的 find 替代品。虽然它的目标不是支持 find 的所有强大功能，但它为大多数的使用情况提供了合理的（opinionated）默认值。\n参考链接"},"A计科工程/硬件工程/ESP32":{"title":"ESP32","links":["A计科工程/Clion"],"tags":["TODO","esp32","clion","linux","platformio"],"content":"ESP32\n\nPlatformIO\nClion 安装 PlatformIO 插件。\nLinux\narchlinux 安装 platformio-core 包\n权限：\r\nsudo usermod -aG uucp $USER\nWindows\n需要\n\npython\n\npython get-platformio.py\n\n\n                  \n                  python 需要系统级的，conda 提供的不行 \n                  \n                \n\nESP32 的控制台波特率默认为 115200。\n在 Clion 控制台中可能乱码，需要在 platformio.ini 设置波特率 monitor_speed = 115200\r\n\n参考链接"},"A计科工程/硬件工程/lwip":{"title":"lwip","links":[],"tags":[],"content":""},"A计科工程/编程语言/ASM/汇编学习":{"title":"汇编学习","links":[],"tags":["Linux","asm"],"content":"基础知识\n\n机器语言是机器指令的集合。\n汇编语言：\n\n汇编指令：机器码的助记符，有对应的机器码。\n伪指令：无对应的机器码，由编译器执行。\n其他符号：如+、-、*、/ 等，由编译器识别，无对应的机器码。\n\n\n"},"A计科工程/编程语言/ASM/汇编实验":{"title":"汇编实验","links":[],"tags":["nasm","Linux","freedos"],"content":"汇编语言实验\n实验一：DEBUG 查看内存"},"A计科工程/编程语言/C++/C++-笔记":{"title":"C++ 笔记","links":[],"tags":[],"content":"变量"},"A计科工程/编程语言/C/C-笔记":{"title":"C 笔记","links":[],"tags":["TODO","c"],"content":"C 学习笔记\n\n概述\n一个简单的 C 程序。\n#include &lt;stdio.h&gt;\n \nint main(int argc, char *argv[]) {\n    printf(&quot;Hello World!\\n&quot;);\n    return 0;\n})\n \n函数指针"},"A计科工程/编程语言/Go/Golang-笔记":{"title":"Golang 笔记","links":["E临时笔记/constraint","override","prune.project"],"tags":[],"content":"Go 是一门开源的、表现力强的、简洁的、静态编译型语言。它在语言级别支持协程（Coroutine），让你轻松的编写并发性代码。Go 新颖的类型系统便于构建灵活的、模块化的应用程序。Go 能够快速的编译为机器码，同时支持垃圾回收（并发标记清除）、运行时反射等现代语言特性。\n多年来系统级编程语言没有出现新成员，然而计算领域发生重大的变化：\n\n\n计算机的速度极大的增快了，而软件开发速度的变化不大\n\n\n当今的软件开发中，依赖管理是一项重要的工作。C 风格语言的基于头文件的依赖难以进行清晰的依赖分析\n\n\n传统静态类型语言，例如 Java、C++ 笨重的类型系统让人反感，很多团队转而使用动态类型语言，例如 Python、JavaScript\n\n\n流行的系统级语言不支持垃圾回收、并行计算等基础概念\n\n\nGo 致力于解决解决上面几点中提及的问题，它能保证大型程序的快速编译、简化依赖管理、完全支持垃圾回收和并行计算。\nGo 提供了一个运行时，此运行时作为每个 Go 应用程序的一部分，提供语言的基础服务，例如垃圾回收、并发、栈管理。这个运行时更像是 libc 而非 JVM，Go 运行时不提供虚拟机。\n编程元素\n变量\n使用关键字 var 可以定义一个变量，或者变量的列表。变量可以定义在包级别、函数级别：\n// 包级别的变量列表声明\nvar c, python, java bool\n \n// 声明并赋值\nvar gender bool = false;\n \nfunc main() {\n    // 函数内的单个变量声明\n    var i int\n    fmt.Println(i, c, python, java)\n}\n变量的初始化\n你可以在变量列表声明之后紧跟着初始化列表：\n// 数量必须一致\nvar i, j int = 1, 2\n// 变量类型可以省略，从初始化表达式中推导\nvar c, python, java = true, false, &quot;no!&quot;\n短声明变量\n使用 := 操作符，可以在函数体内部声明变量并初始化，而不需要 var 关键字和变量类型说明（自动推导）：\nc, python, java := true, false, &quot;no!&quot;\n这种语法不能用在函数体外，函数外的每个语句都必须以关键字开头（例如 var、func）。\n块级作用域\nGo 支持块级作用域，可以覆盖父块的变量声明：\nx := 1\nfmt.Println(x)     // 打印 1\n{\n    fmt.Println(x) // 使用父作用域的变量，打印 1\n    x := 2         // 在子作用域重新声明变量\n    fmt.Println(x) // 打印 2\n}\nfmt.Println(x)     // 打印 1，看不到子作用域的变量\n变量的重复声明\n单个变量不能重复声明：\ni := 0\ni := 1 // 错误\n但是多变量声明时，只要其中一个是新变量，就可以重复声明：\n// 重复声明 i\ni, j := 1, 0  \n零值\n如果变量在定义时没有明确的初始化，则自动初始化为零值：数值类型初始化为 0；字符串类型初始化为&quot;&quot;；布尔型初始化为 false；interface/map/func/slice/chan 初始化为 nil。\n字符串不能赋值为 nil，它的零值只能是空串：\nvar x string = nil // 出错\n你可以向零值的 slice 中添加元素：\nvar s []int\ns = append(s,1)\n但是不能向零值的 map 添加键值对。\n类型转换\n使用语法 T(v) 可以将 v 转换为 T 类型：\ni := 42\nf := float64(i)\nu := uint(f)\n需要注意的是，Go 语言在不同的类型之间进行赋值时，需要显式的类型转换。\n类型推导\n当定义变量而不显式指定其类型时，变量的类型由赋值符号右侧的子表达式推导：\nvar i = 0          // 推导为 int\nj := i             // 推导为 int\nf := 3.142         // float64\ng := 0.867 + 0.5i  // complex128\n基本类型\nGo 作为强类型语言, 隐式的类型转换是不被允许的。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n类型说明bool布尔型，取值 true / falsestring字符串，双引号包围多行字符串使用反引号包围定长整数对应不同的位数（1、2、4、8 字节）：有符号类型：int8 int16 int32 int64无负号类型：uint8 uint16 uint32 uint64rune字面意思是“符文”，实际上是 int32 的别名，代表一个 Unicode 代码点（Code Point）代码点和字符唯一性的对应，例如 U+2318（十六进制 2318）对应字符⌘rune 的直接量语法和 Java 中的 char 类型一致：var r rune = ’⌘‘fmt.Printf (“%v %c %x”, r, r, r)  // 8984 ⌘ 2318 不定长整数int、uint、uintptr 在 32bit 的系统上通常为 32 位；在 64bit 的系统上通常为 64 位浮点数float32、float64复数complex64、complex128示例：var z complex128 = cmplx.Sqrt (-5 + 12i)const f = “%T (%v)\\n”fmt.Printf (f, z, z)  // complex128 ((2+3i))\n常量\n常量类似于变量，但是使用 const 关键字声明，常量不支持 := 语法：\nconst Pi = 3.14\nconst World = &quot;Hello&quot;\nconst Truth = true\n字符串\nGo 字符串的本质是一个 byte 切片（以及一些额外的属性）。字符串是不可变的。如果需要修改字符串的某个字符，可以使用 byte 切片：\nx := &quot;text&quot;\nxbytes := []byte(x)\nxbytes[0] = &#039;T&#039;\nstring(xbytes)\n但是需要注意，单个字符可能存放在多个 byte 中。因此更新一段字符串，使用 rune 的 slice 可能更好，尽管单个字符也可能占用多个 rune（例如包含重音符号的字符）。\n和 byte 切片的转换\n当字符串转换为 byte 切片，或者 byte 切片转换为字符串时，你都会得到原始数据的拷贝。这和通常的 Cast 语义不同。\n获取长度\nlen () 调用获取的是字符串包含的 byte 数量。要获取字符数量，可以：\nimport &quot;unicode/utf8&quot;\nutf8.RuneCountInString(data)\n实际上 RuneCountInString 获取的是 rune 而非 char 数量，包含重音符号的字符，可能占据两个 rune。\n获取字符\n对字符串进行[]操作，得到的是 byte 而非 rune。要获得 rune，可以使用 for range 操作，或者利用 unicode/utf8、golang. org/x/exp/utf8string 等包：\nimport &quot;golang.org/x/exp/utf8string&quot;\nstr := utf8string.NewString(&quot;你好&quot;)\nstr.At(0)\n不一定是 UTF8\n// 可以使用转义序列引入任意数据\ndata := &quot;A\\xfeC&quot;\nutf8.ValidString(data) // false\n函数\nGo 的函数可以接收 0-N 个参数：\nfunc add(x int, y int) int {\n    return x + y\n}\n可以注意到，变量的类型、函数的返回值类型，都是后置声明的。这种与众不同的语法风格，在进行复杂声明时能够保持可读性。\n如果连续多个形参的类型相同，则可以仅仅为最后一个声明类型：func add(x, y int) int {}\n多值返回\nGo 函数可以返回多个值：\npackage main\n \nimport &quot;fmt&quot;\n// 声明多个返回值时，需要用括号包围\nfunc swap(x, y string) (string, string) {\n    return y, x\n}\n \nfunc main() {\n    // 短声明，只能在函数体内使用\n    a, b := swap(&quot;Wong&quot;, &quot;Alex&quot;)\n    fmt.Println(a, b)  // Alex Wong\n}\n返回值命名\n一般语言的返回值只能声明类型，Go 的返回值还可以具有名称：\npackage main\n \nimport (\n    &quot;fmt&quot;\n    &quot;strings&quot;\n)\n                        // 返回值具有名称，相当于定义了局部变量\nfunc split(name string) (first, last string) {\n    na := strings.Split(name,&quot; &quot;)\n    // 直接为返回值赋值\n    first = na[0]\n    last = na[1]\n    // 空白的 return 语句意味着依次返回，相当于 return first, last\n    return\n}\n \nfunc main() {\n    fmt.Println(split(&quot;Alex Wong&quot;))\n}\n作为值使用\n函数可以像任何值一样，被传递来传递去：\n// 函数作为形参，不需要声明其参数、返回值的名字\nfunc add(x, y int, adder func(int, int) int) int {\n    return adder(x, y)\n}\nfunc main() {\n    // 函数作为变量\n    adder := func(x, y int) int {\n        return x + y\n    }\n    // 函数作为实参\n    fmt.Println(add(1, 2, adder))\n}\n闭包\n所谓闭包，是指一个函数值（作为值的函数，Function Value）引用其外部作用域的变量。这导致即使外部作用域生命周期结束，被引用的变量仍然存活。\nfunc genCounter() func() int {\n    count := 0\n    return func() int {\n        count++ // 每次调用导致被封闭的变量值增加\n        return count\n    }\n}\nfunc main() {\n    counter := genCounter();\n    for i := 0; i &lt; 10; i += 1 {\n        fmt.Println(counter())\n    }\n}\n可变参数\nGo 函数支持不定数量的参数，例如：\nimport &quot;fmt&quot;\n \nfunc print(args ...interface{}) {\n    for index, value := range args {\n        fmt.Printf(&quot;%v = %T %v\\n&quot;, index, value, value)\n    }\n    // 0 = int 1\n    // 1 = int 2\n    // 2 = string 一\n}\nfunc main() {\n    print(1, 2, &quot;一&quot;)\n}\n切片可以展开为可变参数列表：\nfunc printAll(strs ...string) {\n    for _, str := range strs {\n        fmt.Printf(&quot;%s &quot;, str)\n    }\n}\nfunc main() {\n    printAll([]string{&quot;A&quot;, &quot;B&quot;, &quot;C&quot;}...) // 展开\n}\n指针\nGo 语言支持指针，指针保存变量的地址。取地址、解引用的操作符也被支持：\nvar i int = 10\n// 取地址，获得变量的指针\nvar ip *int = &amp;i\n// 解引用\n// 通过指针来写变量\n*ip = 5\n// 通过指针来读变量\nfmt.Print(*ip) // 5\n但是，Go 语言不支持指针的运算。\n注意：返回局部变量的指针是安全的，函数返回后此变量仍然存活，这和 C 语言不同。\n传值和传引用\n如果函数的入参是结构，而非结构的指针，则实际传递的是结构的副本，所有字段均被浅拷贝。\n通过**make、new、&amp;**获得的对象，你不需要担心拷贝副本的开销或修改无效。也就是说，传递“引用”的类型包括切片、map、通道、指针、函数。string 类型是不可变的，也按引用传递。数字、bool、结构等都是按值传递。\n数组本身是传值的，作为函数参数时，你通常使用切片而非数组。\n结构体\nGo 语言支持结构体，也就是字段的集合：\ntype Vector3 struct {\n    X int\n    Y int\n    Z int\n}\n \nfunc main() {\n    fmt.Print(Vector3{1, 2, 3}) // {1 2 3}\n}\n要访问结构中的字段，使用点号：\nv := Vector3{1, 2, 3}\nfmt.Print(v.X)\n可以通过结构的指针来访问字段，语法和上面一样：\nv := Vector3{1, 2, 3}\npv := &amp;v\nfmt.Print(pv.X)\n声明结构的不同方式：\n// 列出所有字段\nv1 := Vector3{1, 2, 3}\n// 不列出任何字段\nv2 := Vector3{}\n// 仅仅列出部分字段\nv3 := Vector3{Z: 3}\n// 对直接量取地址\npv4 := &amp;Vector3{Z: 3}\nfmt.Printf(&quot;%v %v %v %v&quot;, v1, v2, v3, *pv4)\n// {1 2 3} {0 0 0} {0 0 3} {0 0 3}\n字段标签\n使用标签（Tag）你可以为结构的字段添加元数据。这些元数据可以通过反射调用获得。在决定如何存储结构到数据库，或者串行化为 JSON/XML 等格式时，常常利用字段标签。\n字段标签通常是 key1:&quot;value1&quot; key2:&quot;value2&quot; 这种形式的键值对，例如：\ntype User struct {\n    Name string `json:&quot;userName&quot; xml:&quot;user-name&quot;`\n}\n如果值部分包含更多信息，可以使用逗号分隔：\nName string `json:&quot;name,omitempty&quot;`\n经常使用的标签键包括：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n标签键说明json包 encoding/json 使用此键，具体查看 json.Marshal ()xml包 encoding/xml 使用此键，具体查看 xml.Marshal ()bson包 gobson 使用此键，具体查看 bson.Marshal ()protobuf包 github. com/golang/protobuf/proto 使用此键yaml包 gopkg. in/yaml. v2 使用此键，具体查看 yaml.Marshal ()db包 github. com/jmoiron/sqlx 使用此键orm包 github. com/astaxie/beego/orm 使用此键valid包 github. com/asaskevich/govalidator 使用此键schema包 github. com/gorilla/schema 使用此键csv包 github. com/gocarina/gocsv 使用此键\n空结构\nstruct{} 的特点是占用内存空间为零：\nvar s struct{}\nfmt.Println(unsafe.Sizeof(s)) // 0\n因此可以用它作为占位符：\nchan struct{}        // 仅仅用来传递信号，而非读写数据\nmap[string]struct{}  // 实现 Set 结构 \n数组\n类型 [n]T 表示具有 n 个元素的 T 类型的数组。数组的长度是其类型的组成部分，这和 C 语言类似：\nvar a [2]string\nfmt.Println(a[0], a[1]) //  空白\na[0] = &quot;Hello&quot;\na[1] = &quot;World&quot;\nfmt.Println(a[0], a[1]) //  Hello World\nfmt.Println(a)          //  [Hello World]\n \n//  直接量语法\na = [2]string{&quot;Hello&quot;,&quot;World&quot;}\n \n// 只初始化指定的索引\narray := [10]int{1:3,3:1}\n// 自动推断数组长度\narray:=[...]int{1,2,3,4,5}\n \n// 遍历数组的两种方式\nfor i:=0; i&lt;len(array); i++{\n    fmt.Println(array[i])\n}\nfor index,value := range array{\n    ...\n}\n \n// 指针的数组\n \nvar ia [10]*int{9:new(int)}  // 为索引 9 分配内存\n*ia[9] = 10   // 解引用并赋值，已经分配内存的索引才能被赋值\n关于数组，需要注意它的长度是一定的，这和切片不同**。元素类型相同、长度也相同的数组，它们的类型才是一样的**。\n你可以对数组元素进行取地址操作：\n// 避免复制\ncontainer := &amp;dep.Spec.Template.Spec.Containers[0]\n数组在传参、赋值时是传值，不过参数通常都会用切片。\n数组是数值\n在 C++ 中，数组即指针。函数的入参是数组时，函数内外引用的是相同内存区域。\n但是在 Go 中，数组是值，向函数传递数组时，函数得到的是原数组的拷贝。也就是说你无法修改原始数组。如果需要修改原始数据，则需要传递其指针：\nx := [3]int{1,2,3}\n \nfunc(arr *[3]int) {\n  // 解引用\n  (*arr)[0] = 0\n}()\n或者，你可以使用切片。尽管切片本身是传值的，但是其底层数组在函数内外共享：\nx := []int{1,2,3}\nfunc(arr []int) {\n  arr[0] = 7\n}(x)\n但需注意，这种方法不能用于增加切片元素，因为其底层数组可能被换掉。\n切片\n[]T 表示类型为 T 的切片。切片类似于数组，实际上它的底层存储就是数组。切片可以用来实现动态长度的数组。\n切片是一个很简单的数据结构，它包括三个成员：指向底层数组的指针；切片长度；切片容量。\n// 直接量语法\ns := []int{1, 2, 3, 4, 5}\n// 切片具有长度、容量两个属性\n// 长度是切片包含元素的数量\nfmt.Println(len(s))   // 5\nfmt.Println(s[4])     // 5\n// 容量则是切片的底层数组的长度\nfmt.Printlkn(cap(s))  // 5\n \n// 通过 make 函数创建切片，长度 5，底层数组长度（容量）10\ns := make([]int, 5, 10)\n \n// 切片也支持仅初始化指定索引的值\ns := []int{3:4}\n切片元素可以是任何类型，包括切片：\nmatrix := [][]int{\n    []int{1, 2, 3},\n    []int{4, 5, 6}, // 如果花括号写在下一行，这此行尾部需要有逗号\n}\nfor i := 0; i &lt; len(matrix); i++ {\n    row := matrix[i]\n    for j := 0; j &lt; len(row); j++ {\n        fmt.Printf(&quot;%v &quot;, row[j])\n    }\n    fmt.Println()\n}\nGo 支持类似于 Python 的切片操作，s[lo:hi] 表示产生从索引 lo（包含）到 hi（不包含）的新切片。需要注意，进行切片操作后，新产生的切片会共享底层数组：\ns := []int{1, 2, 3, 4, 5}\nfmt.Println(s[2:3])  // [3]\n// 省略 hi 则切到尾部\nfmt.Println(s[2:]) // [3 4 5]\n \nvar a [10]int\n# 以下表达式等价\na[0:10]\na[:10]\na[0:]\na[:]\n要构造切片，可以调用 make 函数：\n// 构造初始长度为 10，容量为 100 的切片\ns := make([]int, 10, 100)\nfmt.Print(len(s)) // 10\n切片的零值是 nil，nil 切片的长度、容量皆为 0。另外空切片的长度容量也都是 0：\n// nil 切片，底层数组的指针为 nil\nvar nilSlice []int\n// 空切片，底层数组的指针为一个地址\nslice:=[]int{}\n要向切片的尾部添加元素，可以调用 append 函数。这个函数有可能导致创建新的底层数组。\n// 向切片 s 添加 1-N 个元素，返回包含 s 的原元素和所有新元素的切片\n// 如果 s 的底层数组太小，会自动分配一个大的数组，返回的切片会指向这个新数组\nfunc append(s []T, vs ...T) []T\n \ns := []int{1}\ns1 := append(s, 2, 3, 4)\nfmt.Print(s1) // [1 2 3 4]\n在创建新切片时，最好让切片的长度和容量一致，这样 append 操作总会产生新的底层数组，这可以避免因为共享底层数组导致的奇怪问题。\nfor… range 格式的循环，可以用来迭代切片（以及 map）：\ns := []int{1, 2, 3, 4, 5}\n//  索引，值\nfor i, v := range s {\n    fmt.Printf(&quot;%d=%d &quot;, i, v)\n}\n// 如果不希望迭代索引或值，可以用 _ 代替之\nfor i, _ := range s {\n    fmt.Printf(&quot;%d&quot;, i)\n}\n// 如果不希望迭代值，可以直接省略 _\nfor v := range s {\n    fmt.Printf(&quot;%d&quot;, v)\n}\n \n// 注意，值是拷贝出来的，不支持引用，要修改切片元素本身，需要\nfor i,_ := range s {\n    e := &amp;s[i]\n    e.field = value\n}\n包\n任何 Go 应用程序都是由包构成：\n\n\n程序的执行入口必须是 main 包，在构建时 go 自动为 main 包创建可执行程序\n\n\n程序可以导入一个或者多个包\n\n\n包的名字通常和导入路径的最后一个目录名一致，也就是 go 源文件中声明的包名和文件所在目录名一样\n\n\n包可以包含多个源文件\n\n\n代码示例：\n// 声明当前所属包\npackage main\n \n// 导入包，以便使用其中的成员\nimport (\n    &quot;fmt&quot;\n    &quot;math/rand&quot;\n    &quot;time&quot;\n)\n// 除了用圆括号一起导入多个包，还可以多次使用 import 语句分别导入单个包\nimport &quot;fmt&quot;\nimport &quot;math/rand&quot;\n \nfunc main() {\n    rand.Seed( time.Now().UnixNano())\n    fmt.Println(&quot;Random number: &quot;, rand.Intn(100))\n}\n名称导出\n包中的任何名称 —— 定义在全局作用域下的变量或者函数，只要以大写字母开始，即为导出名称（Exported names）。\n只有导出名称才能够在包外部（import 包的地方）访问。对于A.B 这样的表达式，只有 A 被导出了 B 才可能被包外部访问。\n没有导出的名称，只能在包内访问，各源文件都可以自由访问其它源文件中定义的名称。\n包导入\n要使用一个包，必须使用 import 关键字将其导入。Go 在根据导入路径查找包时，遵循以下优先级：\n\n\n首先在 $GOROOT 下寻找\n\n\n然后在 $GOPATH 下寻找\n\n\n仍然找不到，尝试进行远程包下载、导入\n\n\n在导入包的时候，可以赋予其别名，例如：import util &quot;gmem.cc/util&quot;。如果想导入包但又不使用其 export 出的成员，可以将其别名为 _，这种用法仅仅为了执行包中的 init 函数。\ninit 函数\n每个源文件都可以定义 init 函数（因此一个包可以有多个 init 函数），进行必要的状态初始化。init 函数的执行时机是：\n\n\ninit 所在源文件所有导入的包被初始化后\n\n\n包中声明的所有变量的初始化式被估算后\n\n\n如果目标包中有多个 init 函数，则根据init 所在源文件的名称的字典序，依次执行\n\n\n例如下面这个源文件：\nfunc init() {\n    fmt.Println(&quot;Initializing...&quot;)\n}\n \nfunc IsBlank(str string) bool {\n    return len(strings.Trim(str, &quot; &quot;)) == 0\n}\n只要其所在的包被使用（如果是 main 包则一定被使用），则 init 函数一定会执行，并且肯定在 IsBlank 被调用之前。\n一个较为复杂的 Go 程序中，包初始化顺序如下：\n  go run *.go\n# ├── 主包被执行\n# ├── 初始化所有导入包\n# |  ├── 初始化自己之前，初始化所有导入的包\n# |  ├── 然后初始化自己的变量\n# |  └── 然后调用自己的 init\n# └── 主包初始化\n#    ├── 初始化全局变量\n#    └── 按源文件名称依次执行 init 函数\n迭代\n不管是切片，还是数组、映射，for range 操作获取的都是元素的拷贝。要想修改集合元素，需要使用索引：\nfor i,_ := range data {\n    data[i] *= 10\n}\n如果元素存放的是指针则可以直接解引用并修改。\n映射\ntype LatLng struct {\n    Lat, Lng int\n}\n \nfunc main() {\n    // 声明一个映射：map[KeyType]ValueType\n    var locations map[string]LatLng;\n \n    // 使用 make 函数实例化\n    locations = make(map[string]LatLng)\n \n    // PUT 操作\n    locations[&quot;Alex&quot;] = LatLng{38, 100}\n \n    // GET 操作\n    fmt.Println(locations[&quot;Alex&quot;].Lat)\n \n    // 测试键是否存在，如果不存在第一个返回值为零值，第二个 false\n    ll, exist := locations[&quot;Alex&quot;]\n    fmt.Printf(&quot;%v %v&quot;, ll, exist) // {38 100} true\n \n    // DEL 操作\n    delete(locations, &quot;Alex&quot;)\n \n    // 直接量语法\n    locations = map[string]LatLng{\n        &quot;Alex&quot;: LatLng{38, 100},\n        &quot;Meng&quot;: LatLng{38, 110},\n    }\n    // for...range 循环。注意，遍历的顺序没有任何保证\n    for key,value := range locations{\n        fmt.Println(key,value)\n    }\n}\n支持的键类型\n布尔值、数字、字符串、指针、通道、接口类型、结构，以及这些类型的数组，都可以作为映射的键。切片、映射、函数不可以作为映射的键。\n不像 Java，Go 的 map 不支持自定义 equals/hashCode。两个键是否相等，规则如下：\n\n\n指针：当指针指向同一变量时它们相等，nil 指针是相等的\n\n\n通道：两个通道是由同一次 make 调用产生的，则它们相等，nil 通道是相等的\n\n\n接口：具有相同的运行时类型，且运行时对象是相等的，则接口相等\n\n\n结构：如果两个结构的，相同名称的非空字段都相等，则结构相等\n\n\n数组：如果每个元素都相等\n\n\n线程安全\n注意，Go 中 map 的操作不是原子的，原因是 map 的典型应用场景下不牵涉到跨 Goroutine 的安全访问。\n要保证操作的原子性，建议使用 Goroutine+Channel，或者使用 sync 包。\n不支持对值取地址\n注意：不支持对映射的值进行取地址操作：\nusers := map[string]User{\n    &quot;Alex&quot;: User{&quot;Alex&quot;},\n}\nalex := &amp;users[&quot;Alex&quot;] // 编译错误 \n迭代时删除\n注意：在迭代映射的过程中删除键值是安全的：\nfor key := range m {\n    if key.expired() {\n        delete(m, key)\n    }\n} \n方法\n尽管没有类（Class）的概念，Go 却支持为类型定义方法。Go 不支持方法重载，这意味着两个方法不得具有相同的名字。\n方法是一种函数，它具有特殊的接收者（Receiver）参数：\nfunc (receiver Receiver) methodName(args Args) rv ReturnValues{}\n \n \ntype LatLng struct {\n    latitude, longitude float64\n}\n// 接收者位于 func 关键字和方法名之间，不和普通的方法参数放在一个列表中\nfunc (ll LatLng) isNorthHemisphere() bool {\n    return ll.latitude &gt; 0;\n}\nfunc (ll LatLng) isEastHemisphere() bool {\n    return ll.longitude &gt; 0;\n}\n \nfunc main() {\n    jazxPos := LatLng{39.9601241068, 116.4405512810}\n    fmt.Println(jazxPos.isEastHemisphere())\n}\n注意：方法仅仅是具有接收者的函数而已。\n你也可以为其它（非 struct）类型定义方法，但是你只能为当前包中声明的类型定义方法：\n// 类似于 C 语言的 typedef\ntype Float float64\n \nfunc (f Float) Abs() Float {\n    // 注意下面这种在 Float 和 float64 之间转换的语法\n    return Float(math.Abs(float64(f)))\n}\nfunc main() {\n    f := Float(-100)\n    fmt.Println(f.Abs())\n}\n值作为接收者\n这种情况下，你无法修改源对象，因为传入的是拷贝。\n指针作为接收者\n可以为指针定义方法，也就是将指针作为方法的接收者。接收者声明为*T 也是为 T 类型定义方法，但是 T 本身不能是指针。\n基于指针接收者定义方法，你就可以修改接收者的状态，这种行为类似于 C 语言。\n// 传值\nfunc (ll LatLng) isEastHemisphere() bool {\n    // 此修改对于调用者不可见\n    ll.longitude = 0\n    return ll.longitude &gt; 0;\n}\n// 传引用\nfunc (ll *LatLng) isEastHemisphere() bool {\n    // 此修改对调用者可见\n    ll.longitude = 0\n    return ll.longitude &gt; 0;\n}\n由于指针修改接收者状态的能力，第二种形式的方法定义要常用的多，此外第二种形式还避免了不必要的值拷贝。一般来说，一个类型上的方法，通常都使用指针接收者，或者值接收者，而不会混用。\n调用方法时，你不需要对接收者进行取地址操作，这和普通函数调用不一样。普通函数的参数如果要求指针，则你必须传入指针。\nT 支持的方法集是：以T 为接收者的方法集 + 以 T 为接收者的方法集。因此*T 支持的方法可能比 T 多。\n接口\n接口是 Go 中进行方法动态绑定（多态）的唯一途径。针对结构或者其它具体类型的方法调用，其绑定都发生在编译时。\n接口这种类型定义一组方法签名：\ntype GeoOps interface {\n    // 接口中的方法不需要 func 关键字\n    IsNorthHemisphere() bool\n    isEastHemisphere() bool\n}\n可以将实现了接口中定义了的方法的类型赋值给接口：\n// 以接口类型声明值（Interface Value）\nvar gops GeoOps\n// 是否需要取地址，取决于实现方法的是 T 还是*T\ngops = &amp;jazxPos\nfmt.Println(gops.IsNorthHemisphere())\n实现接口\nGo 语言不需要显式的 implements 声明，类型只需要实现接口中规定的方法即可（鸭子类型识别）。这种设计让接口和它的实现完全解耦。\n需要注意：\n\n\n实际类型以值接收者实现接口的时候，不管是实际类型的值，还是实际类型值的指针，都实现了该接口\n\n\n实际类型以指针接收者实现接口的时候，只有指向这个类型的指针才被认为实现了该接口\n\n\nnil 接口值\n如果接口值指向 nil 变量，调用方法时，接收者是 nil。在很多语言中，调用 nil 的方法会导致空指针异常，但是在 Go 语言中，你可以优雅的实现如何处理 nil 值的逻辑。\n注意 nil 接口值和指向 nil 变量的接口值：\nvar gops GeoOps;\n \n// nil 接口值（未赋值给实际变量）导致运行时错误\ngops.isEastHemisphere() // panic: runtime error: invalid memory address or nil pointer dereference\n \n// 但是让接口值指向 nil 变量则不会出现上述问题\nvar ll LatLng\ngops = &amp;ll\ngops.isEastHemisphere()\n还有一个陷阱需要注意：\nvar e *E = nil\nvar ei error = e\nvar ni error = nil\nprintln(e == nil)  // true    nil\nprintln(ei == nil) // false   (error, nil)   这三个都是判断变量本身是不是 nil，即使将 nil 变量赋值给指针，指针也不是 nil，因为它获得了类型信息\nprintln(ni == nil) // true    nil\n需要注意：\n\n\n如果指针实现了接口，则这种指针的零值，可以赋值给接口 ——这个赋值过程赋予了接口 type 和 value\n\n\n尽管可以将零值赋给接口，但是接口变量 != nil。\n\n\n第 2 点很容易造成问题，当将指针类型的变量传递给形参类型为接口的方法时，判断 nil 值很容易出现问题。这种反直觉行为的原因是，接口本质上是(type, value) 对，当你将接口和 nil 指针比较时，自然不相等。\n解决办法：\n\n如果知道接口的 type，可以进行类型断言，再判断 nil：\n\nif i.(bool) == nil {\n} \n\n否则，可以通过反射：\n\nif reflect.ValueOf(i).IsNil() {\n}\n空接口\n定义了零个方法的接口被称为空接口：interface{}\n任何类型的变量都可以赋值给空接口，因为任何类型都实现它的全部方法。空接口用于处理未知类型的值。例如标准库中的 fmt. Println 方法：\nfunc Println(a ...interface{}) (n int, err error) {\n    return Fprintln(os.Stdout, a...)\n}\n一些实践\n如果一个包仅暴露一个接口，可以将此接口直接命名为 Interface：\npackage user\n \ntype Interface interface {\n    GetName() string\n}\n不要将接口的指针作为入参，只需要使用接口本身：\nfunc sayHelloTo(user *user.Interface) { // NOT OK\n    println((*user).GetName())\n}\n要避免拷贝，只需要让类型的指针作为接口方法的接收者即可。\n子接口类型的实参，可以传递给父接口类型的形参。所谓父子接口，就是体现在方法集的包含关系上。\n操作符\n自增自减\n仅仅支持 i++，不支持++i。而且你不能在表达式中使用自增自减操作符：\n++i       // 错误\ndata[i++] // 错误\n位操作\n^ 作为一元操作符，按位取反，作为二元操作符，异或。\nvar a uint8 = 0x82\nvar b uint8 = 0x02\nfmt.Printf(&quot;%08b [A]\\n&quot;, a) // 10000010 [A]\nfmt.Printf(&quot;%08b [B]\\n&quot;, b) // 00000010 [B]\nfmt.Printf(&quot;%08b (NOT B)\\n&quot;, ^b) // 11111101 (NOT B)\nfmt.Printf(&quot;%08b ^ %08b = %08b [B XOR 0xff]\\n&quot;, b, 0xff, b^0xff) // 00000010 ^ 11111111 = 11111101 [B XOR 0xff]\nfmt.Printf(&quot;%08b ^ %08b = %08b [A XOR B]\\n&quot;, a, b, a^b) // 10000010 ^ 00000010 = 10000000 [A XOR B]\nfmt.Printf(&quot;%08b &amp; %08b = %08b [A AND B]\\n&quot;, a, b, a&amp;b) // 10000010 &amp; 00000010 = 00000010 [A AND B]\nfmt.Printf(&quot;%08b &amp;^%08b = %08b [A &#039;AND NOT&#039; B]\\n&quot;, a, b, a&amp;^b) // 10000010 &amp;^00000010 = 10000000 [A &#039;AND NOT&#039; B]\nfmt.Printf(&quot;%08b&amp;(^%08b)= %08b [A AND (NOT B)]\\n&quot;, a, b, a&amp;(^b)) // 10000010&amp;(^00000010)= 10000000 [A AND (NOT B)]\n类型断言\n使用下面的语法可以进行类型断言，将接口类型强制转换为真实类型，或者将接口转换为另外一个接口：\nll := LatLng{39, 100}\nvar gops GeoOps = &amp;ll\n// 语法：t,ok = i.(T)\nllp := gops.(*LatLng)\n \ntype IstioObject interface { ... }\nvar object interface{} = ...\nitem, ok := object.(IstioObject)\n如果指定两个变量来接收返回值，则：\n\n\n如果断言成功，t 为真实类型变量，ok 为 true\n\n\n如果断言失败，t 为真实类型的 nil 值，ok 为 false\n\n\n如果指定单个变量来接收返回值，则断言失败会导致 panic\nswitch 语法\n这种语法支持在 switch 语句中进行多次断言，直到类型匹配：\nswitch val := gops.(type) {\n    case *LatLng:\n        // 执行到这里则 val 是 *Latlng\n    default:\n \n}\nnew/make\nGo 支持两种变量分配原语：new、make，二者都是内置函数。\nnew\nnew 仅仅用于分配内存，将其置零，但是不初始化变量，仅仅返回指向零值的指针：\n// 为类型 SyncedBuffer 分配对应大小的内存并清零，然后返回一个 * SyncedBuffer\np := new(SyncedBuffer)\n不同类型的零值具有不同含义：例如：\n\n\nsync. Mutex 的零值表示解锁状态\n\n\nbytes. Buffer 的零值表示空白的缓冲区。\n\n\nmake\n用于创建切片（slice）、映射（map）和通道（chan），并且返回已初始化的目标类型（而非指针）。这种设计的原因是，这三个类型必须在它们引用的数据结构被初始化后才能使用\n空白标识符\n你可以声明任何类型的空白标识符，也可以将任何表达式赋值给空白标识符。空白标识符使用符号 _ 表示，可用来无害的丢弃某些值。\n空白标识符可以用在多赋值的表达式中，忽略不关心的那些值：\nif _, err := os.Stat(path); os.IsNotExist(err) {\n    // ...\n}\n导入包，但是仅仅执行其 init 函数而不使用其导出的成员：\nimport _ &quot;net/http/pprof&quot;\n检查是否实现了指定的接口：\nif _, ok := val.(json.Marshaler); ok {\n    fmt.Printf(&quot;value %v of type %T implements json.Marshaler&quot;, val, val)\n}\n类型嵌入\nGo 没有提供典型的、类型驱动的子类化机制。但是，你可以通过在结构、接口内部嵌入其它类型，来达到类似于子类化的效果。\n注意类型嵌入和子类化的不同：\n\n\n被内嵌类型的方法成为外部类型的方法，这个行为和子类化相同\n\n\n当方法被调用时，其接收者是被内嵌类型（即方法所来自的那个类型），而不是外部类型，这个行为和子类化不同\n\n\n被嵌入类型，对自己被嵌入这件事情毫无感知。因此从被嵌入类型中调用外部类型定义的方法是不可能的\n\n\n嵌入到接口\ntype Reader interface {\n    Read(p []byte) (n int, err error)\n}\n \ntype Writer interface {\n    Write(p []byte) (n int, err error)\n}\n \n// 嵌入：ReadWriter 是 Reader、Writer 接口的联合\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n注意，只有接口才能被嵌入到接口中。\n嵌入到结构\ntype Writer struct {\n}\n \nfunc (w *Writer) write() {}\n \ntype Reader struct {\n}\n \nfunc (r *Reader) read() {}\n \ntype ReaderWriter struct {\n    *Writer\n    *Reader\n}\n \nfunc main() {\n    // 就像普通字段一样，内嵌的类型也需要初始化，如果不指定，则为零值\n    rw := ReaderWriter{&amp;Writer{}, &amp;Reader{}}\n    // 可以直接调用内嵌接口的方法\n    rw.write()\n    rw.read()\n}\n结构可以同时包含普通字段、内嵌结构：\ntype Job struct {\n    Command string\n    *log.Logger\n}\n \njob := &amp;Job{command, log.New(os.Stderr, &quot;Job: &quot;, log.Ldate)}\n如果需要直接引用内嵌类型，可以使用其类型名：\n//  使用类型名引用，不要导入包前缀\njob.Logger.Logf(&quot;%q: %s&quot;,...)\n注意，结构也可以内嵌接口：\ntype Registry struct {\n    ClusterID string\n    model.Controller  // 类型名 Controller\n}\n结构嵌入接口的意义是，相当于加了个“缺省适配”，结构不必须实现任何方法，仅仅“覆盖”自己关注的方法即可。\n引用内嵌字段\n内嵌的接口、结构，可以命名，也可以不命名（匿名内嵌）。不命名时，直接以其类型名引用：\naggregate.Registry{\n    ClusterID:        clusterID,\n    Controller:       kubectl,   // 直接通过类型名 Controller 引用\n} \n名字冲突问题\n嵌入可能导致接口/结构的成员名冲突（同名），Go 基于以下规则解决此冲突：\n\n\n越靠嵌套层次外部的成员优先级越高。例如上面的 Job 内嵌了 Logger，如果 Logger 有一个字段 Command，则此字段被 Job. Command 隐藏\n\n\n同一层次下出现重名，通常是一个错误。例如上面的 Job 内嵌了 Logger，它不应该同时有一个名为 Logger 的方法或者字段。即便如此，冲突的名称只要没有在类型定义外部被引用，就不会导致错误\n\n\n嵌入指针还是值\n根据实际情况：\n\n\n如果外层对象以值的形式传来传去，而你需要的内层对象的方法是定义在指针上的，则嵌入指针\n\n\n如果外层对象以指针的形式传来传去，则内层对象可以嵌入值，没有问题，你仍然可以访问内层对象的指针方法\n\n\n如果内层对象的方法均是值接收者，则嵌入值\n\n\n如果对象很小，可以考虑嵌入值，这样可以减少内存分配次数，并实现局部访问（内存中比较靠近）。\n别名和类型定义\n别名\n下面的语法是定义别名，两个类型是完全一样的，可以任意替换：\ntype nodeName = string\n类型定义\n下面的语法是定义一个新类型，两个类型不一样，必须强制转换：\ntype nodeName string\n \nvar n nodeName = string(&quot;xenon&quot;)\nstr := string(n) \n对现有非接口类型进行类型定义，新的类型不会继承原有类型的方法：\ntype myMutex sync.Mutex\n \nvar mtx myMutex\nmtx.Lock() // 错误\n要想继承，可以使用匿名嵌套：\ntype myMutex struct {  \n    sync.Mutex\n}\n \nvar mtx myMutex\nmtx.Lock() // OK\n但是，对于接口类型进行类型定义，方法则会被继承。\n流程控制\nfor\nGo 仅仅支持 for 这一种循环结构：\n// 不得使用圆括号包围（初始化语句; 条件表达式; 后置语句），但是循环体必须使用花括号包围\nfor i := 0; i &lt; 10; i++ {\n    fmt.Printf(&quot;%v&quot;, i)\n}\n// 初始化语句和后置语句是可选的\ni := 0\nfor ; i &lt; 10; {\n    fmt.Printf(&quot;%v&quot;, i)\n    i += 1\n}\n \n// 上段代码的前后分号可以省略，效果类似于 C 语言的 while\ni := 0\nfor i &lt; 10 {\n    fmt.Printf(&quot;%v&quot;, i)\n    i += 1\n}\n \n// 死循环写法\nfor {\n}\n循环变量取地址\n不要尝试取循环变量的地址！\n在 Go 语言中，for 语句引入的变量在整个迭代过程中是重用的，也就是说，也就是说，每次迭代中进行取地址，总是会指向同一个地址：\nvar items []NodeProblemSolverConfig\n \nfor idx, solverConfig := range items {\n    println(&amp;solverConfig)\n    createSolver(&amp;solverConfig)\n}\n \n// 打印\n0xc00055eea0\n0xc00055eea0\n0xc00055eea0\n在上面的例子中，期望创建出三个不同配置的 Solver 对象，而实际上它们引用的 Config 完全一致。\n解决此问题的方法有两个：\n\n如果希望得到值副本的指针：\n\ncopied := solverConfig\n&amp;copied\n\n如果希望得到原始值的指针：\n\n&amp;solverConfig[idx] \n循环和闭包\n下面的代码有问题，所有 Goroutine 打印的都是 data 最后一个元素的值：\ndata =[]int{1,2,3,4,5}\nfor _,v := range data {\n    go func() {\n        fmt.Println(v)  // 5 5 5 5 5\n    }()\n    \n    go v.print()    // 同样的问题，但是更加隐蔽\n}\n解决办法是在循环体内定义局部变量：\nfor _,v := range data {\n    v := v // 每个闭包引用的不是同一变量，这种同名覆盖变量虽然奇怪，在 Go 里面是惯用法\n    go func() {\n        fmt.Println(vc)\n    }()\n} \n或者直接传参给 Goroutine：\nfor _,v := range data {\n    go func(v V) {\n        fmt.Println(vc)\n    }(v)\n}\n再次强调：整个循环过程中，for 语句引入的迭代变量是的内存地址是不变的，也就是说，整个迭代过程中只有一个变量，每次都在修改同一变量的值，在循环体内**，传递此变量的地址是危险的，特别注意闭包这种隐晦的传递地址的形式**\nif\n类似于循环控制语句，分支控制语句也可以包含一个初始化语句：\n// 圆括号、花括号规则和 for 相同\n// 注意可以在条件表达式之前置一个语句\nif i := 0; i &lt; 1 {\n    fmt.Print(i)\n}\n \ni := 0;\nif i &lt; 1 {\n    fmt.Print(i)\n}\n \n// if - else if - else\nif true {\n    \n} else if false {\n \n} else {\n \n}\nswitch\n需要注意，Go 中 switch 语句的 case，默认行为是 break，而其它很多语言的默认行为是进入下一个 case 继续判断、执行（注意 C 语言中，没有 break 的情况下，一旦某个 case 匹配，后续所有其它 case/default 都会执行）：\n// 同样可以具有前置的初始化表达式\nswitch os := runtime.GOOS; os {\ncase &quot;darwin&quot;:\n    fmt.Println(&quot;OS X&quot;)\ncase &quot;linux&quot;:\n    fmt.Println(&quot;Linux&quot;)\n    // fallthrough 则继续执行下一个分支\n    fallthrough\ndefault:\n}\n \n// switch 也可以不带任何条件，用来编写简洁的 if-then-else 结构：\nt := time.Now()\nswitch {\ncase t.Hour() &lt; 12:\n    fmt.Println(&quot;上午好&quot;)\ncase t.Hour() &lt; 17:\n    fmt.Println(&quot;下午好&quot;)\ndefault:\n    fmt.Println(&quot;晚上好&quot;)\n}\n \n// case 合并：\nswitch pod.Status.Phase {\ncase v1.PodPending, v1.PodRunning: ...\n}\ndefer\n这个关键字可以让后面的语句延迟执行：\nfunc main() {\n    defer fmt.Println(&quot; World&quot;)\n    fmt.Println(&quot;Hello&quot;)\n}\n// Hello World\n直到包围语句的函数（而非代码块）返回之前才执行，因此在循环体中通过 defer 来进行清理是不可以的。解决办法是把循环体封装为函数。\n连续使用 defer 时，会形成 defer 栈，先入栈的语句后执行：\nfunc main() {\n    for i := 0; i &lt; 10; i += 1 {\n        defer fmt.Print(i)   // 不能用这种方式实现每元素迭代后清理\n    }\n    // 9876543210\n}\n需要注意，defer 的表达式求值发生在声明时，而非实际执行时：\nvar i int = 1\ndefer fmt.Println(&quot;result =&gt;&quot;,func() int { return i * 2 }())  // 打印 2 而非 4\ni++ \ndefer 的陷阱\ndefer 函数调用时机\n\n\n包裹 defer 的函数返回时\n\n\n包裹 defer 的函数执行到末尾时\n\n\n所在的 goroutine 发生 panic 时\n\n\n资源清理先判断 err 再 defer\n如果资源没有获取成功，即没有必要也不应该再对资源执行释放操作：\nresp, err := http.Get(url)\n// 先判断操作是否成功\nif err != nil {\n    return err\n}\n// ...\n// 如果操作成功，再进行 Close 操作\ndefer resp.Body.Close()\ndefer 函数参数估算时机\ndefer 后面需要跟着函数调用，但是其入参可以是任何表达式。这些表达式的估算时机，是正常执行流（非 Defer 栈）执行到 Defer 语句的时候：\nvar buf bytes.Buffer\nPrintln(buf.Len())                 // 0\nbuf.Write(make([]byte, 10))  \nPrintln(buf.Len())                 // 10\ndefer Println(buf.Len())           // 10\nbuf.Write(make([]byte, 10))                          \nPrintln(buf.Len())                 // 20\n上面的例子中，defer 语句真正执行时使用的 buf 长度，是第 3 行 write 后的长度，而非第 6 行。\n换一种写法：\nvar buf bytes.Buffer\nPrintln(buf.Len())                 // 0\nbuf.Write(make([]byte, 10))\nPrintln(buf.Len())                 // 10\ndefer func() {\n    defer Println(buf.Len())       // 20\n}()\nbuf.Write(make([]byte, 10))\nPrintln(buf.Len())                 // 20\n这样就可以获得最终 buf 的长度，因为对 buf.Len () 的函数调用不会提前发生。\n调用 os. Exit 时 defer 不会被执行\n当发生 panic 时，所在 goroutine 的所有 defer 会被执行，但是当调用 os.Exit () 方法退出程序时，defer 并不会被执行：\nfunc deferExit() {\n    defer func() {\n        fmt.Println(&quot;defer&quot;)\n    }()\n    os.Exit(0)\n}\n上面的 defer 不会执行。\n标签\n可以用于 goto 跳转、for switch、for select 跳转：\nloop:\n    for {\n        switch {\n        case true:\n            break loop\n        }\n    }\ngoto\n可以实现无条件转移：\n    goto label\nlabel:\n    x := 1\n常用库\n标准库列表\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n标准库说明archive/tar对 Tar 归档格式的支持archive/zip对 Zip 归档格式的支持bufio装饰 io. Reader/io. Writerbytes操控[]byte，也就是字节切片compress/bzip2实现 bzip2 解压缩算法compress/flate实现 DEFLATE 压锁算法compress/gzip支持读写 gzip 格式compress/lzw支持读写 lzw 格式{“userName”: “Alex”,“userAge”: 31}compress/zlib支持读写 zlib 格式container/heap为任何实现了 heap 接口的类型提供“堆”操作。堆（heap）是实现优先级队列的一种方式container/list实现双向链表container/ring实现环形列表context定义 Context 类型crypto/*加解密相关包database/sql为 SQL 数据库提供一般性接口database/sql/driver定义数据库驱动程序需要实现的接口debug/*调试相关的包encoding编解码（Marshaler/Unmarshaler）相关的通用接口encoding/base64支持 Base64 编码格式：// 编码base64.StdEncoding.EncodeToString ([]byte{})encoding/hex支持 Hex 编码格式encoding/json支持 JSON 格式encoding/xml支持 XML 格式encoding/binary在[]byte 和数字之间进行转换：errors包含操控 error 的函数flag实现命令行选项解析的功能fmt格式化输入输出，类似于 C 语言的 printf/scanfhash/*实现散列算法html用于处理 HTML 的转义html/template实现事件驱动的、生成 HTML 的模板，支持防代码注入image/*2D 图形库，支持 gif/jpeg/png 等图像格式index/suffixarray基于内存中的 suffix array 实现对数复杂度的子串搜索io提供 IO 操作原语io/ioutil包含一些 IO 工具函数log一个简单的日志包glogGoogle 内部 C++ 日志框架的复制品log/syslog提供访问系统日志服务的功能math包含基本的常量和数学函数math/big支持任意精度的算术运算math/bits支持按位的计算math/cmplx支持复数的计算math/rand支持伪随机数mime实现了部分 MIME 规范mine/multipart支持 MIME Multipart 解析net提供可移植的网络 IO 接口，包括 TCP/IP、UDP、Unix 域套接字、DNS 解析net/http提供 HTTP 客户端和服务器实现net/http/cgi提供 CGI 实现net/http/fcgi实现 FastCGI 协议net/http/httptest提供用于 HTTP 测试的工具net/http/httptrace在 HTTP 客户端请求内部追踪事件net/http/httputilHTTP 相关工具函数net/http/pprof收集 HTTP 服务器运行时信息，供 pprof 分析net/mail电子邮件解析/extend-kubernetes-with-custom-resourcesnet/smtpSMTP 协议支持net/rpc支持跨越网络来访问对象导出的方法net/rpc/jsonrpc实现基于 JSON-RPC 1.0 的服务器/客户端编码方式net/url解析 URLos平台独立的操作系统功能函数os/exec运行外部命令os/signal支持访问发送到当前进程的信号os/user根据名称或者 ID 来查找 OS 用户path操控基于 / 的路径path/filepath操控文件名路径reflect实现了运行时反射，允许程序操控任何类型的对象regexp提供正则表达式支持runtime包含用于和 Go 运行时系统进行交互的操作，例如控制 Goroutinesort提供排序切片或者用户定义集合的原语strconv为基本数据类型提供到/从字符串展现的转换// bool 转换为字符串strconv.FormatBool (v)// 字符串转换为 intstrconv.Atoi (“1”)strings提供操控基于 UTF-8 的字符串的函数sync提供基本的同步原语，例如互斥量sync/atomic提供低级别的原子内存原语，用于设计同步算法syscall支持低级别的系统调用testing用于支持 Go 包的自动化测试time操控和访问时间unicode提供对 Unicode 的支持unsafe用于绕开 Go 的类型安全机制\nbuilt-in\ntrue/false\n这两个在 Go 语言中是常量，其声明如下：\nconst (\n    true  = 0 == 0\n    false = 0 != 0\n)\niota\n用在多常量声明中，其值为当前常量值的索引：\nconst (\n    x = 100\n    a = iota\n    b = iota\n    c\n    d\n)\n \nfunc main() {\n    fmt.Printf(&quot;%v %v %v %v %v&quot;, x, a, b, c, d) // 100 1 2 3 4\n}\nnil\n预定义的标识符，表示指针、通道、函数、接口、映射或者切片的零值。\nappend\n函数签名：func append(slice []Type, elems ...Type) []Type\n将元素附加到切片的尾部，如果切片容量足够，它被重切已满足新元素。如果容量不足，底层数组被重新分配\n支持把字符串添加到[]byte 切片中：\nslice = append([]byte(&quot;hello &quot;), &quot;world&quot;)\ncap\n函数签名：func cap(v Type) int\n获取数组、数组指针（指向的数组）、切片、缓冲通道的容量。\nclose\n用于关闭通道\ncomplex\n函数签名：func complex(r, i FloatType) ComplexType\n用于创建复数\n函数 func imag(c ComplexType) FloatType 返回复数的虚数部分\n函数 func real(c ComplexType) FloatType 返回复数的实数部分\ncopy\n函数签名：func copy(dst, src []Type) int\n从源切片拷贝元素到目标切片，也可以用来拷贝字符串到[]byte。返回实际拷贝的元素个数。\ndelete\n函数签名：func delete(m map[Type]Type1, key Type)\n用于从映射中删除条目。\nlen\n函数签名：func len(v Type) int\n返回数组、数组指针、切片、字符串（字节数）、缓冲通道的元素个数。如果 v 为 nil 则返回 0\nmake\n函数签名：func make(t Type, size ...IntegerType) Type\n为切片、映射、通道分配内存空间并且初始化。\nnew\n函数签名：func new(Type) *Type\n为指定的类型分配内存\npanic\n此内置函数用于产生一个运行时异常，通常会导致程序停止运行。此函数接收一个任意类型的参数，参数的字符串形式会被打印到控制台上。\nrecover\n当 panic 被调用时，不管是否显式调用，当前函数的执行会立即停止，并 Unwind 调用栈，调用 defer 函数。如果 Unwinding 到达 Goroutine 的栈顶，则程序终止。\n使用内置函数 recover 可以从 Unwinding 中重新获得程序控制权，恢复正常执行流。recover 函数终止 Unwind 并捕获 panic 的参数作为返回值，它仅仅能在 defer 函数体内调用。\ntype Request struct {\n}\n \nfunc (request *Request) process() {\n    panic(&quot;Request process failed.&quot;)\n}\n \nfunc Worker(req *Request) {\n    // 必须在 defer 中调用，recover 类似于 Java 中的 catch\n    defer func() {\n        // 如果当前没有 panic，则 recover 返回 nil\n        if err := recover(); err != nil {\n            fmt.Println(err)\n        }\n    }()\n    req.process()\n}\nprint/println\n内置的打印函数：\nfunc print(args ...Type)\nfunc println(args ...Type)\nuintptr\n一个整数类型，足够大以存放任何位模式的指针。\nerror\n这是一个内置的接口：\ntype error interface {\n    Error() string\n}\nfmt 包在打印时，会检测变量是否实现了该接口。\n很多函数都会返回 error 值，调用者应该检查该值是否为 nil，从而判断调用是否成功：\ni, err := strconv.Atoi(&quot;one&quot;)\n// 非零值表示调用失败\nif err != nil {\n    fmt.Printf(&quot;%v\\n&quot;, err)\n    return\n}\nfmt.Println(i)\nflag\n解析命令行参数，支持短参数（-h）和长参数（—help），支持默认值、命令帮助：\nimport &quot;flag&quot;\n \nvar (\n    masterURL string\n    help      bool\n)\n \nfunc main() {\n    // 注册命令行参数：存放到的目标变量的指针、参数名、默认值、帮助信息\n    flag.StringVar(&amp;masterURL, &quot;masterURL&quot;, &quot;&quot;, &quot;URL of kubernetes master&quot;)\n    flag.Parse() // 解析\n    if help {\n        flag.Usage() // 打印帮助\n    }\n} \nlog\n该包提供了基本的日志记录功能。示例用法：\nlog.Printf(&quot;Process id is %v&quot;, os.Getpid())\nlog.Fatalf(&quot;Parent PID is %v&quot;, os.Getppid())  // 打印信息并执行 panic() 抛出恐慌\nlog.Fatal(&quot;Fatal error&quot;)                      // 打印信息并执行 os.Exit(1)\n输出内容比 fmt. Printf 多了当前时间的前缀。要配置输出格式，可以：\n// 前缀日期和代码位置\nfunc init(){\n    log.SetFlags(log.Ldate | log.Lshortfile)\n}\n// 2016/08/05 application.go:10: Process id is 10147\n \n// 所有可用的标记：\nconst (\n    Ldate = 1 &lt;&lt; iota //日期，示例 2017/01/01\n    Ltime //时间，示例 08:08:08\n    Lmicroseconds //微秒\n    Llongfile //绝对路径和行号\n    Lshortfile //文件和行号\n    LUTC //日期时间，UTC 时间\n    LstdFlags = Ldate | Ltime\n)\nreflect\n该包为 Go 语言提供了反射功能。\n分类识别\n例如判断对象是不是一个指针：\nif reflect.ValueOf(req).Kind() != reflect.Ptr {\n  \n} \n类型识别\ntype User struct {\n    Name string\n    Age  uint8\n}\n \nvar alex interface{}\nalex = User{&quot;Alex&quot;, 31}\n \n// 获取任意对象的具体类型\nalexType := reflect.TypeOf(alex)\nintType := reflect.TypeOf(1)\nfmt.Println(alexType, intType) // main.User int\n值识别\nValue 是一个结构，它保存任何一个对象的全部信息。\n调用 reflect.ValueOf ()可以将任意对象转换为 reflect. Value\nalexValue := reflect.ValueOf(alex)\nfmt.Printf(&quot;%T=%v\\n&quot;, alexValue, alexValue) // reflect.Value={Alex 31}\n \n// 下面的调用返回零值\nValueOf(nil)\n要从 Value 获得**原始对象，可以调用 Value.Interface ()**方法：\n// 获得原始对象 interface{} 然后将其 Cast 为真实类型\nalex, _ = alexValue.Interface().(User)\nfmt.Printf(&quot;%T=%v\\n&quot;, alex, alex)           // main.User={Alex 31} \n要判断一个值是否为零值，使用下面的代码：\nfunc IsZero(v reflect.Value) bool {\n    // 零值是无效值，但是这样判断不足够，还需要将  当前值      和   类型的零值    进行比较\n    return !v.IsValid() || reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface())\n}\n获取分类\nfmt.Println(alexType.Kind())  // struct\nfmt.Println(alexValue.Kind()) // struct\n \n// 底层分类列表\nconst (\n    Invalid Kind = iota\n    Bool\n    Int\n    Int8\n    Int16\n    Int32\n    Int64\n    Uint\n    Uint8\n    Uint16\n    Uint32\n    Uint64\n    Uintptr\n    Float32\n    Float64\n    Complex64\n    Complex128\n    Array\n    Chan\n    Func\n    Interface\n    Map\n    Ptr\n    Slice\n    String\n    Struct\n    UnsafePointer\n)\n读写字段\n// 遍历字段\nfor i := 0; i &lt; alexType.NumField(); i++ {\n    fmt.Println(alexType.Field(i).Name)\n}\n写入结构的字段：\ntype User struct {\n    Name string\n    Age  uint8\n}\n \nalex := User{&quot;Alex&quot;, 31}\n \n// 为了修改对象的字段，必须传递指针（可寻址）\nalexPtrValue := reflect.ValueOf(&amp;alex)\n \n// Elem() 返回 interface 包含的 Value、或者指针指向的 Value\nalexValue := alexPtrValue.Elem()\nif alexValue.Kind() == reflect.Struct {\n    nameField := alexValue.FieldByName(&quot;Name&quot;)\n    // 可设置的前提是：字段已经导出、对象可寻址\n    if nameField.CanSet() {\n        nameField.SetString(&quot;Alex Wong&quot;)\n    }\n}\n \nfmt.Println(alex) // {Alex Wong 31}\n写入基本类型：\nage := 31\nreflect.ValueOf(&amp;age).Elem().SetInt(32)\nfmt.Println(age) // 32\n调用方法\n要调用方法，首先需要获取方法的 Value 对象：\nalexPtrValue := reflect.ValueOf(&amp;alex)\nsayHelloMthd := alexPtrValue.MethodByName(&quot;SayHello&quot;)\nMethodByName 根据名称来检索一个 Value（它必须是接口、结构等支持方法的对象）的方法，方法也是 Value 对象，但是它可被调用：\nargs := []reflect.Value{\n    reflect.ValueOf(&quot;Meng&quot;),\n}\n \nif sayHelloMthd.IsValid() {\n    rets := sayHelloMthd.Call(args)\n    println ( rets[0].Interface().(string))\n}\n总之，方法、方法的参数、方法的返回值，都是 Value。Value 和实际接口/结构之间可以转换。\n读取字段标签\nalex := User{&quot;Alex&quot;, 31}\ntag := reflect.TypeOf(alex).Field(0).Tag\nfmt.Println(tag) // json:&quot;userName&quot;\n很多现有的包都会利用字段标签，例如：\njson, _ := json.Marshal(alex)\nfmt.Printf(&quot;%v&quot;, string(json))\n// {&quot;userName&quot;:&quot;Alex&quot;,&quot;userAge&quot;:31}\nunsafe\n使用该包可以绕过 Go 的内存安全机制，直接对内存进行读写。\nSizeof\n此函数返回一个类型占用的内存空间大小：\nfmt.Println(unsafe.Sizeof(1))        // 8\nfmt.Println(unsafe.Sizeof(&#039;1&#039;))      // 4\nfmt.Println(unsafe.Sizeof(&quot;1&quot;))      // 16\nfmt.Println(unsafe.Sizeof(new(int)))    // 8\n注意返回值仅仅和类型有关，和值没有任何关系。\nAlignof\n此函数返回一个类型的对齐系数（对齐倍数）：\nvar b bool\nvar i8 int8\nvar i16 int16\nvar i64 int64\nvar f32 float32\nvar s string\nvar m map[string]string\nvar p *int32\nfmt.Println(unsafe.Alignof(b))       // 1\nfmt.Println(unsafe.Alignof(i8))      // 1\nfmt.Println(unsafe.Alignof(i16))     // 2\nfmt.Println(unsafe.Alignof(i64))     // 8\nfmt.Println(unsafe.Alignof(f32))     // 4\nfmt.Println(unsafe.Alignof(s))       // 8      \nfmt.Println(unsafe.Alignof(m))       // 8\nfmt.Println(unsafe.Alignof(p))       // 8\n对齐倍数都是 2 的幂，一般不会超过 8。你也可以基于反射来获取对齐倍数：\nreflect.TypeOf(x).Align()\nOffsetof\n此函数用于获取结构中字段相对于结构起始内存地址的偏移量：\ntype User struct {\n    age  uint8\n    name string\n}\nalex := User{}\nfmt.Println(unsafe.Offsetof(alex.age))   // 0\nfmt.Println(unsafe.Offsetof(alex.name))  // 8\n你也可以基于反射来获取偏移量：\nreflect.TypeOf(u1).Field(i).Offset\nPointer\nunsafe. Pointer 是一种特殊的指针，它可以指向任何的类型，类似于 C 语言中的 void*\n不同具体类型的指针是无法相互转换的：\nvar uip *uint8 = new(uint8)\nvar fip *float32 = new(float32)\nuip = fip  // cannot use fip (type *float32) as type *uint8 in assignment\n但是 unsafe. Pointer 却可以和任何指针类型相互转换，包括 uintptr：\nvar uip *uint8 = new(uint8)\nvar fip *float32 = new(float32)\n*fip = 3.14\nuip = (*uint8)(unsafe.Pointer(fip))\nfmt.Println(*uip)\n*T 不支持算术运算，但是 uintptr 却可以。利用 unsafe. Pointer 作为媒介，我们可以获得精确控制内存的能力：\ntype User struct {\n    age  uint8\n    name string\n}\nuser := new(User)\n \npage := (*uint8)(unsafe.Pointer(user))\n*page = 31\n \nos := unsafe.Offsetof(user.name)\n// 为了进行指针算术运算，必须使用 uintptr\nbase := uintptr(unsafe.Pointer(user))\npname := (*string)(unsafe.Pointer(base + os))\n*pname = &quot;Alex&quot;\n \nfmt.Println(*user) \nencoding/json\n// 序列化，缩进 4 空格\nb, _ := json.Marshal(result)\nvar out bytes.Buffer\njson.Indent(&amp;out, b, &quot;&quot;, &quot;    &quot;)\nout.WriteTo(writer)\n// 序列化，缩进 4 空格\njson.MarshalIndent(data, &quot;&quot;, &quot; &quot;)\n对通过 HTTP 传递来的字节流解码为 JSON，数字的真实类型可能是 float64：\nres := make(map[string]interface{})\nerr = json.Unmarshal(respBytes, &amp;res)\n// id 虽然是 909，但是实际上是 float64\nid := res[&quot;id&quot;]\ntask.testId = int(id.(float64)) \ntime\nn := time.Now()\n// 格式化，注意 layout 中的时间值不能改\nFMT := &quot;2006-01-02 15:04:05&quot;\nprintln(n.Format(FMT))          // 2018-02-11 18:16:47\nprintln(n.Format(&quot;2006/1/2&quot;))   // 2018/2/11\nprintln(n.Format(&quot;2006/01/02&quot;)) // 2018/02/11\nprintln(n.Format(&quot;15:04:05&quot;))   // 18:17:13\n \n// 解析\nn, _ = now.Parse(&quot;2018-01-02 18:16:47&quot;)\n \nprintln(n.Format(FMT)) // 2018-01-02 00:00:00\n \n// 指定解析使用的格式\ntime.Parse(&quot;2006-01-02T15:04:05.999999Z&quot;, str)\ntime.Parse(&quot;2006-01-02T15:04:05Z07:00&quot;, str)\n \n// 转换为整数\nprintln(n.Unix())               // UNIX 纪元，秒\nprintln(n.UnixNano() / 1000000) // UNIX 纪元，毫秒\n \n// 获取各字段 2018 January 2 18 16 47\nfmt.Printf(&quot;%v %v %v %v %v %v &quot;, n.Year(), n.Month(), n.Day(), n.Hour(), n.Minute(), n.Second())\n \n// ProtoBuf 时间戳\ntime := protobuf.Timestamp{Seconds: n.Unix()}\ntime. Duration 表示一个时间长度：\n// 解析，可以使用 s、m、h 等单位\nd, _ := time.ParseDuration(&quot;1s&quot;)\n它的本质就是纳秒数：\ntype Duration int64\n \nconst (\n    Nanosecond Duration = 1\n    Microsecond = 1000 * Nanosecond\n    Millisecond = 1000 * Microsecond\n    Second = 1000 * Millisecond\n    Minute = 60 * Second\n    Hour = 60 * Minute\n)\n你可以将 Duration 和整数进行算术运算：\nvar d1 time.Duration = (60 * 1000) * time.Millisecond\nvar d2 time.Duration = 2 * time.Minute\n也可以计算两个时间点之间的差距：\nvar duration time.Duration = endingTime.Sub(startingTime)\nmath/rand\n提供伪随机数的支持。\n注意随机数不随机的问题：\nglog.Info(rand.Intn(10))\nglog.Info(rand.Intn(10))\n以上代码无论运行多少次，都输出 1、7。原因是使用的“源”是固定的。因此，要产生每次调用都不一样的随机数，需要每次使用不同的源：\nsource := rand.NewSource(time.Now().Unix())\ngen := rand.New(source)\nglog.Info(gen.Intn(1000))\n \n// 或者，更简单的，你可以为默认源设置新的种子\nrand.Seed(time.Now().UnixNano())\nrand.Intn(100)\nos/exec\n执行一段 Bash 脚本：\nctx, _ := context.WithTimeout(context.TODO(), s.actionTimeout)\n// 支持超时控制\ncmd := exec.CommandContext(ctx, s.shellPath, script)\n// 可以设置环境变量\ncmd.Env = os.Environ()\nfor key, val := range vars {\n    cmd.Env = append(cmd.Env, fmt.Sprintf(&quot;%s=%s&quot;, key, val))\n}\n// 执行\ncmd.Run()\n输入输出\ncmd := exec.Command(&quot;tr&quot;, &quot;a-z&quot;, &quot;A-Z&quot;)\n// 提供输入\ncmd.Stdin = strings.NewReader(&quot;some input&quot;)\n// 指定输出缓冲\nvar out bytes.Buffer\ncmd.Stdout = &amp;out\nerr := cmd.Run()\n也可以直接将标准输出/标准错误一起作为返回值：\ncmd := exec.Command(&quot;sh&quot;, &quot;-c&quot;, &quot;echo stdout; echo 1&gt;&amp;2 stderr&quot;)\n// 执行并收集标准输出 + 标准错误\nstdoutStderr, err := cmd.CombinedOutput()\n// 执行并收集标准输出\nstdout, err := cmd.Output()\n非阻塞\n要非阻塞的启动命令，但是不等待其返回，可以：\ncmd := exec.Command(&quot;sleep&quot;, &quot;5&quot;)\nerr := cmd.Start()\n你可以稍后等待其结束：\ncmd.Wait()\nos/signal\n支持访问发送到当前进程的信号，示例代码：\n/* 将接收到的 SIGINT、SIGTERM 信号中继给 chan os.Signal */\nrelayCh := make(chan os.Signal, 2)\nsignal.Notify(relayCh, os.Interrupt, syscall.SIGTERM)\ngo func() {\n    &lt;-relayCh\n    close(stopCh) // stopCh 供应用中其它协程读取\n    &lt;-relayCh\n    // 再次收到信号，强制退出进程\n    os.Exit(1)\n}()\n// 协程可以循环执行逻辑，直到 stopCh 关闭\nwait.Until(ctrl.runWorker, time.Second, stopCh)\nstrconv\n为基本数据类型提供到/从字符串展现的转换，主要函数：\n// 将布尔值转换为字符串 true 或 false\nfunc FormatBool(b bool) string\n// 将字符串转换为布尔值\n// 接受真值：1, t, T, TRUE, true, True\n// 接受假值：0, f, F, FALSE, false, False\n// 其它任何值都返回一个错误。\nfunc ParseBool(str string) (bool, error)\n \n// 将整数转换为字符串形式。base 表示转换进制，取值在 2 到 36 之间\n// 结果中大于 10 的数字用小写字母 a - z 表示\nfunc FormatInt(i int64, base int) string\nfunc FormatUint(i uint64, base int) string\n// 将字符串解析为整数，ParseInt 支持正负号，ParseUint 不支持正负号\n// base 表示进位制（2 到 36），如果 base 为 0，则根据字符串前缀判断\n// 前缀 0x 表示 16 进制，前缀 0 表示 8 进制，否则是 10 进制\n// bitSize 表示结果的位宽（包括符号位），0 表示最大位宽\nfunc ParseInt(s string, base int, bitSize int) (i int64, err error)\nfunc ParseUint(s string, base int, bitSize int) (uint64, error)\n \n// 将整数转换为十进制字符串形式。即：FormatInt(i, 10)\nfunc Itoa(i int) string\n// 将字符串转换为十进制整数。即：ParseInt(s, 10, 0)\nfunc Atoi(s string) (int, error)\n \n \n// FormatFloat 将浮点数 f 转换为字符串形式\n// f：要转换的浮点数\n// fmt：格式标记（b、e、E、f、g、G）\n// prec：精度（数字部分的长度，不包括指数部分）\n// bitSize：指定浮点类型（32:float32、64:float64），结果会据此进行舍入\n//\n// 格式标记：\n// &#039;b&#039; (-ddddp±ddd，二进制指数)\n// &#039;e&#039; (-d.dddde±dd，十进制指数)\n// &#039;E&#039; (-d.ddddE±dd，十进制指数)\n// &#039;f&#039; (-ddd.dddd，没有指数)\n// &#039;g&#039; (&#039;e&#039;:大指数，&#039;f&#039;:其它情况)\n// &#039;G&#039; (&#039;E&#039;:大指数，&#039;f&#039;:其它情况)\n//\n// 如果格式标记为 &#039;e&#039;，&#039;E&#039;和&#039;f&#039;，则 prec 表示小数点后的数字位数\n// 如果格式标记为 &#039;g&#039;，&#039;G&#039;，则 prec 表示总的数字位数（整数部分 + 小数部分）\n// 参考格式化输入输出中的旗标和精度说明\nfunc FormatFloat(f float64, fmt byte, prec, bitSize int) string\n// 将字符串解析为浮点数，使用 IEEE754 规范进行舍入\n// bigSize 取值有 32 和 64 两种，表示转换结果的精度\n// 如果有语法错误，则 err.Error = ErrSyntax\n// 如果结果超出范围，则返回 ±Inf，err.Error = ErrRange\nfunc ParseFloat(s string, bitSize int) (float64, error)\n代码示例：\nstrconv.ParseInt(&quot;FF&quot;, 16, 0)  // 255\nstrconv.ParseInt(&quot;0xFF&quot;, 0, 0) // 255\nencoding/binary\n在[]byte 和数字之间进行转换：\nvar a []byte = []byte{0, 1, 2, 3}\nfmt.Println(binary.BigEndian.Uint32(a))\nfmt.Println(binary.LittleEndian.Uint32(a))\nglog\nGoogle 内部 C++ 日志框架的 Go 语言复制品：\n\n\nInfo/Warning/Error/Fatal 函数，以及 Infof 等格式化版本\n\n\nV 风格的日志控制（使用命令行选项-v 和-vmodule=file=2）\n\n\n代码示例：\nglog.Fatalf(&quot;执行失败: %s&quot;, err)\nif glog.V(2) {\n    glog.Info(&quot;执行成功&quot;)\n}\nglog.V(2).Infoln(&quot;处理了&quot;, nItems, &quot;个条目&quot;)\n日志被缓冲，并周期性的 Flush，程序退出前你应该手工调用 Flush。默认情况下，所有日志被写入到临时目录的文件中。\n你可以通过命令行选项来改变 glog 的行为，flag. Parse 应该在任何日志打印函数调用前调用：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n命令行选项示例说明—logtostderr=false日志被输出到标准错误而非文件—alsologtostderr同时输出到文件和标准错误—stderrthreshold=ERROR输出到标准错误的最低严重级别—log_dir=&quot;&quot;日志输出目录—v=0输出日志的最低冗余级别-vmodule=gopher*=3对于 gopher 开头的 Go 文件，其最低冗余级别设置为 3\nencoding/json\n支持 JSON 的串行化、反串行化。下面的代码示例将 JSON 字符串反串行化为 map：\nimport (\n    &quot;encoding/json&quot;\n    &quot;github.com/sanity-io/litter&quot;\n    &quot;io/ioutil&quot;\n)\n \nfunc main() {\n    data, _ := ioutil.ReadFile(&quot;configdump.json&quot;)\n    config := make(map[string]interface{})\n    // 转换 JSON 为 MAP\n    json.Unmarshal(data, &amp;config)\n    litter.Dump(config)\n}\ngopkg. in/yaml. v2\n支持 YAML 格式的串行化、反串行化。下面的代码示例将 map 串行化为 YAML：\nimport (\n    &quot;gopkg.in/yaml.v2&quot;\n    &quot;io/ioutil&quot;\n    &quot;os&quot;\n)\n \nfunc main() {\n    config := make(map[string]interface{})\n    // 转换 MAP 为 YAML\n    data, _ := yaml.Marshal(config)\n    ioutil.WriteFile(&quot;configdump.yaml&quot;, data, os.ModePerm)\n}\n基本工具库\nhuandu/xstrings\n包含各种各样的字符串处理函数。\nelliotchance/pie\n专门用于切片成立，专注于类型安全、性能、不可变性。\n包含一些内置的类型定义，不需要 go generate 即可使用：\ntypeStrings[]string\ntypeFloat64s[]float64\ntypeInts[]int\n \n \n// 示例\npackage main\n \nimport (\n    &quot;fmt&quot;\n    &quot;strings&quot;\n \n    &quot;github.com/elliotchance/pie/pie&quot;\n)\n \n// 示例\nfunc main() {\n    name := pie.Strings{&quot;Bob&quot;, &quot;Sally&quot;, &quot;John&quot;, &quot;Jane&quot;}.\n        // 过滤\n        FilterNot(func (name string) bool {\n            return strings.HasPrefix(name, &quot;J&quot;)\n        }).\n        // 变换\n        Map(strings.ToUpper).\n        // 取最后一个元素\n        Last()\n \n    fmt.Println(name) // &quot;SALLY&quot;\n}\n如果希望为任何自定义的类型生成上面这样的接口需要添加注释：\ntype Car struct {\n    Name, Color string\n}\n \n//go:generate pie Cars.*\ntype Cars []Car\n然后执行 go generate 会生成 cars_pie.go 文件，其中定义了上面那样的接口。\n你还可以自定义 Equality、Strings 等方法，实现类似于 Java 的灵活性：\ntype Car struct {\n    Name, Color string\n}\n \ntype Cars []*Car // ElementType is *Car\n \nfunc (c *Car) Equals(c2 *Car) bool {\n    return c.Name == c2.Name\n}\nthoas/go-funk\n一个工具箱函数库，主要用于集合操作：\n\n\n元素存在性判断、索引判断\n\n\n结构转为 map，map 转为 slice\n\n\n任何可迭代对象的元素查找、过滤、迭代、去重\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n函数说明Contains检查元素是否存在（于切片、映射、数组）IndexOfLastIndexOf获得元素的索引或 -1ToMap将一个字段作为 pivot（键），转换结构为 mapFilter使用 Predicate 函数来过滤切片Find使用 Predicate 函数来查找切片元素Map在映射、切片之间进行相互转换Get使用路径导航的形式检索值：funk.Get (foo, “Bar. Bars. Bar. Name”)Keys获取结构、映射的字段名/键数组Values获取结构、映射的字段值、值数组ForEach迭代映射、切片ForEachRight反向迭代映射、切片Chunk将切片划分为子切片，每个子切片具有指定的大小FlattenDeep递归的扁平化多维数组Uniq数组去重Drop去除数组/切片的前 N 个元素Initial获取数组/切片除后 N 个的全部元素Tail获取数组/切片除前 N 个的全部元素Shuffle将指定数组进行元素重排，放到新数组中Sum数组元素求和Reverse获取反向数组SliceOf从单个元素创建切片RandomInt获得一个随机整数RandomString获得一个固定长度的随机字符串\nmholt/archiver\n压缩/解压\n能够快速的压缩/解压缩。zip, .tar, .tar. gz, .tar. bz2, .tar. xz, .tar. lz4, .tar. sz 等格式，还能够解压缩。rar 格式。示例：\nimport &quot;github.com/mholt/archiver&quot;\n \n// 压缩\nerr := archiver.Archive([]string{&quot;testdata&quot;, &quot;other/file.txt&quot;}, &quot;test.zip&quot;)\n// 解压缩\nerr = archiver.Unarchive(&quot;test.tar.gz&quot;, &quot;test&quot;)\n上面的代码自动根据扩展名来判断使用何种归档、压缩算法。你也可以明确指定需要使用的算法：\nz := archiver.Zip{\n    CompressionLevel:       flate.DefaultCompression,\n    MkdirAll:               true,\n    SelectiveCompression:   true,\n    ContinueOnError:        false,\n    OverwriteExisting:      false,\n    ImplicitTopLevelFolder: false,\n}\n \nerr := z.Archive([]string{&quot;testdata&quot;, &quot;other/file.txt&quot;}, &quot;/Users/matt/Desktop/test.zip&quot;)\n探看文件\n下面是探看 Zip 中文件条目的例子：\nerr = z.Walk(&quot;/Users/matt/Desktop/test.zip&quot;, func(f archiver.File) error {\n    zfh, ok := f.Header.(zip.FileHeader)\n    if ok {\n        fmt.Println(&quot;Filename:&quot;, zfh.Name)\n    }\n    return nil\n})\n写入 HTTP 响应\nerr = z.Create(responseWriter)\nif err != nil {\n    return err\n}\ndefer z.Close()\n \nfor _, fname := range filenames {\n    info, err := os.Stat(fname)\n    if err != nil {\n        return err\n    }\n    \n    // 获取文件在归档文件中的内部名称\n    internalName, err := archiver.NameInArchive(info, fname, fname)\n    if err != nil {\n        return err\n    }\n \n    // 打开文件\n    file, err := os.Open(f)\n    if err != nil {\n        return err\n    }\n \n    // 写入到文件\n    err = z.Write(archiver.File{\n        FileInfo: archiver.FileInfo{\n            FileInfo:   info,\n            CustomName: internalName,\n        },\n        ReadCloser: file,\n    })\n    file.Close()\n    if err != nil {\n        return err\n    }\n}\narchive/tar\n处理 Tar 格式的归档，写示例：\nvar buf bytes.Buffer\nvar chart []byte = []byte{1, 2, 3}\nw := tar.NewWriter(&amp;buf)\n// 写入条目\n// 写入头\nw.WriteHeader(&amp;tar.Header{\n    Name: &quot;Chart.yaml&quot;,\n    Size: int64(len(chart)),\n})\n// 写入体\nw.Write(chart)\n// 刷出\nw.Close()\n// 写到文件\nioutil.WriteFile(&quot;/tmp/chart.tar&quot;, buf.Bytes(), fileutil.PrivateFileMode)\n读示例：\ntr := tar.NewReader(buf)\n// 处理下一个条目\nheader, err := tr.Next()\nprintln( header.Name )\nbuf := make([]byte, header.Size)\n// 读取此条目的内容到缓冲区\ntr.Read(buf)\ncompress/gzip\n处理 Gzip 压缩格式，下面是写 tar. gz（tgz）的例子：\nvar buf bytes.Buffer\ngw := gzip.NewWriter(&amp;buf)\n// 装饰\ntw := tar.NewWriter(gw)\n \nyamlBytes := []byte(&quot;AppVersion: 1.0.0&quot;)\ntw.WriteHeader(&amp;tar.Header{\n    Name: &quot;Chart.yaml&quot;,\n    Size: int64(len(yamlBytes)),\n    Mode: 0666,\n})\ntw.Write(yamlBytes)\ntw.Close()\ngw.Close()\n \nioutil.WriteFile(&quot;/tmp/chart.tgz&quot;, buf.Bytes(), 0666) \n下面是读的例子：\ngzipBuf := bytes.NewBuffer(req.Zip)\ngr, err := gzip.NewReader(gzipBuf)\nif err != nil {\n    // 说明是无效 GZIP 格式\n}\ndefer gr.Close()\ntr := tar.NewReader(gr)\n数据绑定/拷贝\nmitchellh/mapstructure\n支持将一般性的 Map 解码为 Go 结构，或者反向转换。示例：\nitem := make(map[string]interface{}]\n//...\n// 创建一个解码器\ndecoder, _ := mapstructure.NewDecoder(&amp;mapstructure.DecoderConfig{\n    Metadata: nil,\n    Result:   &amp;chart,\n    // 定制类型转换器\n    DecodeHook: func(from reflect.Type, to reflect.Type, v interface{}) (interface{}, error) {\n        if to.String() == &quot;*timestamp.Timestamp&quot; {\n            return parseTime(v.(string)), nil\n        }\n        // 不转换，直接返回原始值\n        return v, nil\n    },\n})\n// 执行解码\ndecoder.Decode(item)\nmitchellh/copystructure\n深拷贝（DeepCopy）对象，不管是 map、slice、pointer 都能递归的解引用并正确拷贝。示例：\ncs, _ := copystructure.Copy(allChartsProto)\nimdario/mergo\n用于合并结构、映射。非导出字段不会被合并，导出字段则会被递归的合并：\n// 合并\nif err := mergo.Merge(&amp;dst, src); err != nil {\n}\n// 将映射合并到结构\nif err := mergo.Map(&amp;dst, srcMap); err != nil {\n}\n// 也可以将映射合并到映射，一定要记得对映射取地址（Why？本身就是传递引用）\nmergo.Map(&amp;dstMap, srcMap)\n需要注意的是：将结构合并到映射时，不会递归合并。\n你还可以提供转换器，指定特定类型字段在合并之前如何转换：\nimport (\n    &quot;fmt&quot;\n    &quot;github.com/imdario/mergo&quot;\n        &quot;reflect&quot;\n        &quot;time&quot;\n)\n \ntype transfomer struct {\n}\n \nfunc (t timeTransfomer) Transformer(typ reflect.Type) func(dst, src reflect.Value) error {\n       // 时间类型的转换器\n    if typ == reflect.TypeOf(time.Time{}) {\n        return func(dst, src reflect.Value) error {\n            if dst.CanSet() {\n                                // 判断是否零值的方法\n                isZero := dst.MethodByName(&quot;IsZero&quot;)\n                result := isZero.Call([]reflect.Value{})\n                if result[0].Bool() {\n                    dst.Set(src)\n                }\n            }\n            return nil\n        }\n    }\n    return nil\n}\n \ntype Snapshot struct {\n    Time time.Time\n}\n \nfunc main() {\n    src := Snapshot{time.Now()}\n    dest := Snapshot{}\n    mergo.Merge(&amp;dest, src, mergo.WithTransformers(transfomer{}))\n    fmt.Println(dest)\n}\n和 C/C++ 交互\n对 C/C++ 的支持\n你可以导入伪包“C”来使用 C 语言中定义的类型，此导入前面紧跟着的注释叫做 Preamble。Preamble 中可以包含任意 C 代码，包括函数、变量声明和定义：\npackage main\n \n/*\ntypedef int (*accumulator) (int a, int b);\n \nint add(int a, int b){\n    return a+b;\n}\nint reduce(accumulator acc,int a,int b){\n    return acc(a,b);\n}\n*/\n// 伪包 C\nimport &quot;C&quot;\nimport &quot;fmt&quot;\nimport &quot;unsafe&quot;\n \nfunc main() {\n    // 通过伪包 C 来调用 C。C.accumulator 获取 reduce 的函数指针\n    f := C.accumulator(C.add)\n    // 调用 C 函数\n    fmt.Printf(&quot;%v&quot;, C.reduce(f, 1, 2)) // 3\n    \n    // 创建一个 C 字符串（char*）\n    cs := C.CString(&quot;Hello World&quot;)\n    // 释放 C 内存\n    C.free(unsafe.Pointer(cs))\n    \n    // 将 C 分配的内存授予 Go 指针\n    p := (*int)(C.malloc(4))\n    // 释放 C 分配的内存\n    C.free(unsafe.Pointer(p))\n}\n在构建时，一旦 go 发现 import &quot;C&quot; 语句，就会寻找目录中的非 go 源码。c/s/S 扩展名的文件会使用 C 编译器编译，cc/cpp/cxx 文件会使用 C++ 编译器编译。\nCFLAGS, CPPFLAGS, CXXFLAGS, FFLAGS, LDFLAGS 等环境变量可以通过伪指令#cgo来定义：\n// #cgo CFLAGS: -DPNG_DEBUG=1\n// #cgo amd64 386 CFLAGS: -DX86=1\n// #cgo LDFLAGS: -lpng\n// #include &lt;png.h&gt;\nimport &quot;C&quot;\n \n \n// 通过 pkg-config 获得 CPPFLAGS 和 LDFLAGS，默认 pkg-config 工具可以通过 PKG_CONFIG 获得\n// #cgo pkg-config: png cairo\n// #include &lt;png.h&gt;\nimport &quot;C&quot;\n在构建时，CGO_CFLAGS, CGO_CPPFLAGS, CGO_CXXFLAGS, CGO_FFLAGS, CGO_LDFLAGS 等环境变量被附加到上述指令引入的环境变量之后，构成构建 C 代码所需要的完整变量。特定于包的标记应该通过伪指令而非环境变量设置。\n包中所有 CPPFLAGS、CFLAGS 指令用于编译包中的 C 源码，所有 CPPFLAGS、CXXFLAGS 指令则用于编译 C++ 源码。\n程序中所有包的 LDFLAGS 指令会被连接在一起，并在链接阶段使用。\n#cgo 伪指令中可以包括一些变量，${SRCDIR}会被替换为源码目录的绝对路径：\n// #cgo LDFLAGS: -L${SRCDIR}/libs -lfoo\ncgo\n这是 Go 提供的用于支持 C/C++ 的工具。在进行本地编译时，该工具默认启用；在进行交叉编译时，该工具默认禁用。\n设置环境变量 CGO_ENABLED 可以控制是否使用 cgo，设置为 1 启用，设置为 0 禁用。\nGo 调用 C\n在 Go 文件中，如果需要访问的 C 结构字段名属于 Go 关键字，可以前缀一个 _ 来访问。C 结构中无法在 Go 语言中解释的字段被忽略（例如 bitfield）。\n类型映射关系\n标准的 C 数字类型映射到的 Go 类型如下表：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC 类型Go 类型备注charC.charsigned charC.scharunsigned charC.ucharshortC.shortunsigned shortC.ushortintC.intunsigned intC.uintlongC.longunsigned longC.ulonglong longC.longlong/extend-kubernetes-with-custom-resourcesunsigned long longC.ulonglongfloatC.floatdoubleC.doublecomplex floatC.complexfloatcomplex doubleC.complexdoublevoid*unsafe. Pointer任何指针都可以转换为 unsafe. Pointer，unsafe. Pointer 也可以转换为任何类型的指针int128_tuint128_t[16]bytechar*C.CString\n此外需要注意：\n\n\n如果需要直接访问 C 的 struct、union、enum 类型，为类型名字前缀 struct*、union*、enum_\n\n\n要获得任何 C 类型的尺寸，调用 C.sizeof_T\n\n\n由于 Go 不支持 C 的联合体，因此联合体在 Go 中映射为等长度的字节数组\n\n\nGo 的结构不能包含 C 类型的内嵌字段\n\n\ncgo 把 C 类型转换为非导出的 Go 类型，因此任何 Go 包都不能在其导出 API 中暴露 C 类型。一个包中的 C 类型，和另一个包中的同名 C 类型是不一样的\n\n\n在多赋值上下文中，可以调用任何 C 函数，第一个变量赋值为 C 函数返回值，第二个变量赋值为 C 函数调用的 errno\n\n\n目前不支持调用 C 函数指针，但是你可以定义 Go 变量来引用函数指针。C 函数可以调用这种来自 Go 的函数指针\n\n\nC 的函数，如果参数是定长数组，实参传递指向某个数组的首元素指针。在 Go 中调用这类函数时，你需要明确的传递数组首元素的指针：C.f(&amp;C.x[0])\n\n\n调用 C.malloc 时，不会直接调用 C 库中的 malloc，二是调用 Go 对 malloc 的包装函数。此包装函数保证 C.malloc 调用不会返回 nil。如果内存不足，程序直接崩溃\n\n\n链接到 C 库\n可以仅仅在 Go 代码中声明 C 头文件，然后再链接到对应的 C 库：\n// 在当前目录下寻找 libxxx 进行链接\n// #cgo LDFLAGS: -L ./ -lxxx\n// #include &quot;xxx.h&quot;\nimport &quot;C&quot;\n \nfunc main() {\n    C.xxx()\n}\nC 调用 Go\n使用注释来标注某个函数可以导出供 C 使用：\n//export MyFunction\nfunc MyFunction(arg1, arg2 int, arg3 string) int64 {...}\n \n//export MyFunction2\nfunc MyFunction2(arg1, arg2 int, arg3 string) (int64, *C.char) {...}\n在头文件_cgo_export. h 中，可以看到如下形式的声明：\nextern int64 MyFunction(int arg1, int arg2, GoString arg3);\n// 多返回值函数，其返回值被包装为结构体\nextern struct MyFunction2_return MyFunction2(int arg1, int arg2, GoString arg3);\n指针的传递\nGo 是支持垃圾回收的语言，它需要知道每个指向 Go 内存的指针的具体位置，因此，在 C 和 Go 代码之间传递指针受到限制。\n如果一个 Go 指针指向的内存不包含任何 Go 指针，则该 Go 指针可以传递给 C 代码。\nC 代码不应该存储任何 Go 指针（因为其由 Go 的垃圾回收器管理）。当将结构的某个字段的指针传递给 C 时，存在问题的是结构的某个字段；当将 Go 数组、切片的指针传递给 C 时，存在问题的是整个数组或切片。在调用完毕后，C 代码不应该保留任何 Go 指针。\n被 C 代码调用的 Go 函数，不得返回 Go 指针。但是这种函数可以：\n\n\n将 C 指针作为入参，这些指针可以指向非指针、C 指针，但是不能指向 Go 指针\n\n\n将 Go 指针作为入参，但是这些指针所指向的内存，不得包含 Go 指针\n\n\nGo 代码不得在 C 内存中存储 Go 指针。C 代码则可以在 C 内存中存储 Go 指针。但是在 C 函数返回时，必须立即停止存储 Go 指针。\n上述规则可以在运行时动态检查。配置环境变量 GODEBUG，设置其值为：\n\n\ncgocheck=1 执行廉价的动态检查\n\n\ncgocheck=0 禁用动态检查\n\n\ncgocheck=2 执行完整的检查，需要消耗一定的资源\n\n\n要打破上述规则，可以使用 unsafe 包。另外，没有任何机制来阻止 C 代码做违反上述规则的事情。如果打破上述规则，程序很可能意外的崩溃。\n常用命令\ngo\n这是一个用于管理 go 源代码的工具。\n注意，某些子命令的行为会受到 GO111MODULE 环境变量的影响。\n| 子命令       | 说明                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| ------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------ |\n| build        | 编译包及其依赖，但是不安装编译结果当编译单个 main 包时，结果二进制文件的 basename 默认和第一个源文件（go build a.go b.go 输出 a.exe）或者目录（go build unix/sam 输出 sam. exe）相同当编译多个包或者单个非 main 包时，编译结果被丢弃，也就是仅仅验证编译是否可以通过当编译包时，_test. go 结尾的文件被忽略格式：go build [-o output] [-i] [build flags] [packages]选项：-o  仅编译单个包时可用，显式指定输出的二进制文件或对象文件的名字-i 安装编译目标的依赖-a 强制重新构建所有包，即使已经 up-to-date-v 编译后打印被编译包的名称-buildmode mode 构建模式-compiler name 使用的编译器，gccgo gc-gccgoflags ‘arg list’ 编译器 gccgo 的标记-gcflags ‘arg list’  编译器 gc 的标记，参考 go tool compile -help-installsuffix suffix 包安装路径名后缀-ldflags ‘flag list’  链接标记，参考 go tool link -help-linkshared 与共享库进行链接，共享库使用 -buildmode=shared 创建-pkgdir dir  从 dir 安装、加载所有包，而非默认位置构建模式：-buildmode=archive  构建非 main 包为。a 文件，main 包被忽略-buildmode=c-archive  构建 main 包以及所有它导入的包为 C 归档文件-buildmode=c-shared 构建 main 包以及所有它导入的包为 C 共享库-buildmode=shared 构建非 main 包为共享库，main 包被忽略-buildmode=exe 构建 main 包以及所有它导入的包为可执行文件-buildmode=pie  构建为位置独立可执行文件（PIE）-buildmode=plugin 构建为 Go 插件示例：export GOROOT=/home/alex/Go/sdk/1.9.2export GOPATH=/home/alex/Go/workspaces/defaultpushd /home/alex/Go/workspaces/default/src/digital-app &gt; /dev/nullexport PATH=/home/alex/Go/sdk/1.9.2/bin/:PATH&lt;br&gt; &lt;br&gt;# 构建&lt;br&gt;go build -i -o build/digitalsrv&lt;br&gt; &lt;br&gt;# 静态连接&lt;br&gt;# CGO_ENABLED 提示使用 cgo 而非 go 作为编译器，以便进行静态连接&lt;br&gt;# -a 重新构建所有依赖&lt;br&gt;# -ldflags &#039;-s&#039;减小二进制文件大小&lt;br&gt;CGO_ENABLED=0 go build -i -a -o build/digitalsrv -ldflags &#039;-s&#039;&lt;br&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| tool compile | 将单个 Go 包编译为对象文件&lt;br&gt;**格式：**go tool compile [flags] file...&lt;br&gt;**选项：**&lt;br&gt;-I dir1 -I dir2 导入包的搜索路径，在搜索 GOROOT/pkg/ GOOS\\_GOARCH 之后搜索-N 禁用优化-c int 编译时的并发度，默认 1-dynlink 允许引用共享库中的 Go 符号-l 禁用内联-lang version 设置 Go 语言版本，例如-lang=go1.12-largemodel 基于大内存模型的假设来编译-pack 生成归档而非对象文件-shared 生成能够链接到共享库的代码-dwarf 生成 DWARF 符号                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| tool link    | 从 main 包中读取 Go 归档/object，以及它们的依赖，并链接为二进制文件格式：go tool link [flags] main. a # 从 go build 调用go build -ldflags “[flags]“选项：-D address 设置数据段地址-T address 设置文本段地址-E entry 设置入口符号名称-H type 设置可执行文件格式类型，默认类型从 GOOS+GOARCH 推断-I interpreter 设置使用的 ELF 动态链接器-L dir1 -L dir2 在搜索 GOROOT/pkg/ GOOS*GOARCH 之后，从 dir1 dir2 中搜索导入包&lt;br&gt;-X importpath.name=value 设置导入路径中的字符串变量 name 的值为 value。示例：&lt;br&gt;-X github.com/stefanprodan/flagger/pkg/version.REVISION= {GIT_COMMIT}“上述选项只有当源码中定义了 REVISION 变量且它的值没有初始化、或者初始化为常量字符串表达式时有意义：package version var VERSION = “0.8.0”var REVISION = “unknown”-a 反汇编输出-buildid id 设置 Go 工具链的 build id-buildmode mode 构建模式，默认 exe-c Dump 出调用图-compressdwarf 如果可能压缩 DWARF，默认 true-cpuprofile file 将 CPU profile 写入到文件-d 禁止生成动态可执行文件。控制是否生成动态头。默认情况下即使没有引用任何动态库也会生成动态头-dumpdep Dump 出符号依赖图-extar ar 设置外部归档程序（默认 ar），仅配合-buildmode=c-archive 使用-extld linker 设置外部链接器（默认 clang 或 gcc）-extldflags flags 空格分隔的，传递给外部链接器的选项-installsuffix suffix 从 GOROOT/pkg/ GOOS*GOARCH_suffix 中搜索包，而非 GOROOT/pkg/ GOOS\\_GOARCH-linkmode mode 设置链接模式，可选值 internal, external, auto-linkshared 和已经安装的 Go 共享库进行链接-msan 支持 C/C++ 内存消毒器-n Dump 出符号表-o 将输出写入到指定文件-r dir1: dir2… 设置 ELF 动态链接器的搜索路径-race 链接到竞态检测共享库-s 移除符号表和调试信息-shared 生成共享对象，隐含-linkmode external-w 禁止 DWARF 生成链接模式：internal：解析并链接主机上的对象文件（ELF/Mach-O/PE …）到最终可执行文件里面。由于实现宿主机链接器的全部功能存在困难，因此这种模式下能够链接的对象文件种类是受限的external：为了支持链接到任何对象文件而不需要动态库，cgo 支持所谓外部链接模式。此模式下，所有 Go 代码被收集到 go. o 文件中，并通过宿主机链接器（通常 gcc）将 go. o 以及所有依赖的非 Go 的代码链接到最终可执行文件里面大部分构建同时编译代码、调用链接器来创建二进制文件。在使用 cgo 的情况下，编译时期已经依赖 gcc，因此链接阶段再次依赖 gcc 没有问题 |\n| clean        | 移除编译后的对象文件（Object files）格式：go clean [-i] [-r] [-n] [-x] [build flags] [packages]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |\n| doc          | 显示包或者符号的文档格式：go doc [-u] [-c] [package                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | [package.]symbol[. methodOrField]] # 显示 fmt 包的 Errorf 函数的文档 go doc fmt Errorf |\n| env          | 打印 Go 相关环境变量信息，相关的环境变量包括：GOOS，目标操作系统，支持 darwin、freebsd、linux、windows、android 等GOARCH，目标体系结构，支持 arm、arm64、386、amd64 等                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n| fix          | 针对指定的包运行 Go fix 命令。Fix 能够查找到使用旧 API 的 Go 程序，并将其替换为新 API。升级到新版本的 Go 之后，可以调用此命令                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |\n| fmt          | 指定指定的包源代码运行 gofmt                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| generate     | 通过处理源文件，产生 Go 文件                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| get          | 下载并安装包及其依赖**格式：**go get [-d] [-f] [-fix] [-insecure] [-t] [-u] [build flags] [packages]选项：-d 仅仅下载，不安装-f 配合-u，不去检查是否每个 import 语句对应的包以及从它的原始代码仓库检出-fix  在解析依赖、构建代码之前，对下载的包运行 fix tool-t 同时下载构建测试代码所需的依赖-insecure 允许通过非安全连接下载代码-u 使用网络下载包及其依赖-v 显示详细输出                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| install      | 编译并安装包及其依赖                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |\n| list         | 列出包                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| run          | 编译并运行程序                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |\n| test         | 测试指定的包                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |\n| tool         | 运行指定的 Go tool                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |\n依赖管理\nvendor\ngo vendor 是 go 1.5 官方引入依赖包管理机制。其基本思路是，将引用的外部包的源代码放在当前工程的 vendor 目录下面，go 1.6 以后编译 go 代码会优先从 vendor 目录先寻找依赖包。这样，当前工程放到任何机器的$GOPATH/src 下都可以通过编译。\n如果不使用 vendor 机制，每次构建都需要 go get 依赖包，下载的依赖包版本可能和工程需要的版本不一致，导致编译问题。\n仅可执行程序（main 包）应该 vendor 依赖，共享的库则不应该。当你编写项目时，应该将所有传递性的依赖都扁平化到当前项目的 vendor 目录下。\n依赖搜索的优先级：vendor 目录 ⇨ GOROOT ⇨ GOPATH\nglide\ngo vendor 无法精确的引用外部包进行版本控制，不能指定引用某个特定版本的外部包。只是在开发时，将其拷贝过来，但是一旦外部包升级，vendor 下的代码不会跟着升级，而且 vendor 下面并没有元文件记录引用包的版本信息，这个引用外部包升级产生很大的问题，无法评估升级带来的风险。\nglide 是 Go 语言的包管理工具，它能够管理 vendor 目录。\n安装\ncurl glide.sh/get | sh\n命令\n格式：glide [global options] command [command options] [arguments...]\n常用子命令：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n子命令说明create别名 init，创建一个新工程，包含 glide. yaml 文件cwconfig-wizard，自动扫描代码中的依赖，给出依赖版本的建议get下载一或多个包到 vendor 目录，并在 glide. yaml 中添加依赖项rm从 glide. yaml 中移除依赖，重新生成 lock 文件import从其它依赖管理系统中导入文件nv列出目录下所有 non-vendor 路径，如果不希望测试依赖的包，可以：go test $(glide novendor)install安装项目的依赖，读取 glide. lock 文件，根据其中的 commit id 来安装特定版本的包如果 glide. lock 文件不存在，则此命令自动调用 glide update 并生成 glide. lockupdate更新项目的依赖list列出所有的依赖项cc清除 Glide 缓存\ndep\nGo 语言的官方的试验阶段的依赖管理工具。需要 Go 1.9+ 版本。从 1.11 版本开始，Go 工具链内置了和 dep 差异很大的依赖管理机制。\n安装\ngo get -u github. com/golang/dep/cmd/dep\n创建项目\nmkdir -p $GOPATH/src/github. com/gmemcc/dep-study\ncd $GOPATH/src/github. com/gmemcc/dep-study\n \ndep init # 自动生成 Gopkg. toml Gopkg. lock vendor/\n管理依赖\ndep ensure 可用于管理依赖，更新依赖后，vendor 目录中的内容出现变化。dep ensure 的功能包括：\n\n\n添加新的依赖\n\n\n更新现有依赖\n\n\n对 Gopkg. toml 中的规则变化作出响应\n\n\n项目中第一次导入某个包，或者移除某个包的最后一个导入后，作出响应\n\n\n命令示例：\n# 添加依赖\ndep ensure -add github. com/foo/bar github. com/baz/quux\n# 更新一个依赖项目到新版本\ndep ensure -update github. com/foo/bar\n# 更新所有依赖，通常不建议\n# 搜索匹配 Gopkg. toml 中的 branch、version、revision 约束的代码版本\ndep ensure -update\nGopkg. toml\n此文件由 dep init 自动生成，后续主要由人工编辑。此文件可以包含几种规则声明，以控制 dep 的行为：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n规则类型说明constraints定义直接依赖如何加入到依赖图中： constraint # 导入路径   name = “github. com/user/project”# 导入的版本，可以指定 version branch 或 revision# version 操作符：# = 等于！= 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 ⇐ 小于等于# - 版本范围，示例 1.2 - 1.4.5# ~ 小版本范围，示例 ~1.2.3 表示大于等于 1.2.3 但小于 1.3.0# ^ 大版本范围，示例 ^1.2.3 表示大于等于 1.2.3 但小于 2.0.0# xX* 通配符，示例   1.2. x 表示大于等于 1.2.0 但小于 1.3.0   version = “1.0.0”   branch = “master”# 通常是反模式，例如 Git 的 SHA1   revision = “abc123” # 可选。此依赖的源码的替换位置（URL 或者导入路径），通常用在 fork 的场景下   source = “https://github. com/myfork/package. git”  [metadata]# 定义一些键值对，dep 本身不使用这些键值对overrides覆盖所有依赖（直接或传递）的规则，应当小心使用。示例： override    name = “k8s. io/api”   version = “kubernetes-1.11.0”  override    name = “k8s. io/apimachinery”   version = “kubernetes-1.11.0”  override    name = “k8s. io/code-generator”   version = “kubernetes-1.11.0”  override    name = “k8s. io/client-go”   version = “kubernetes-1.11.0” required必须在任何 constraint 或 override 之前声明dep 通过分析 go 代码中的 import 语句来构建一个依赖图。required/ignored 规则用于操控此依赖图required 列出必须包含在 Gopkg. lock 中的包的列表，此列表会和当前项目导入的包合并。required 可以强制声明一个未 import 的包为项目的直接依赖对于 linter、generator 或者其它开发工具，如果：1. 被当前项目使用2. 不被直接或传递的导入到当前项目3. 你不需要把这些工具加入 GOPATH，或者你想锁定版本则可以使用 required 规则声明：required = [“k8s. io/code-generator/cmd/client-gen”]ignored必须在任何 constraint 或 override 之前声明dep 通过分析 go 代码中的 import 语句来构建一个依赖图。required/ignored 规则用于操控此依赖图required 列出 dep 进行静态代码分析时需要忽略的包，可以使用通配符：ignored = [“github. com/user/project/badpkg*“]metadata定义供第三方工具使用的元数据，可以定义在根下，或者 constraint、override 下prune定义全局/某个项目的依赖修剪选项。这些选项决定了写入 vendor 时哪些文件被忽略支持以下变量，取值均为布尔：1. unused-packages 提示不在包导入图中出现的目录，应该被修剪掉2. non-go 提示不被 Go 使用的文件应该修剪掉3. go-tests 将 Go 测试文件修剪掉dep init 会自动生成：[prune]   go-tests = true   unused-packages = true你可以为每个项目（依赖）定义修剪规则：[prune]   non-go = true    prune.project      name = “github. com/project/name”     go-tests = true     non-go = false\nvgo\n由于 Go 一直没有提供官方的依赖管理工具，导致了 dep，glide，govendor，godep 等工具群雄争霸的局面。vgo 是解决这种现状的早期尝试，vgo 即 Versioned go。\n安装\ngo get -u golang. org/x/vgo\ngo. mod\n这是 vgo 的依赖配置文件，需要放在项目的根目录下。\n命令\nvgo 具有同名的 CLI，可以使用的子命令包括：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n子命令说明install安装依赖build编译项目run运行项目get github. com/pkg获取依赖的最新版本。依赖包数据会缓存到 GOPATH 路径下的 src/mod 目录get github. com/ pkg@v1.0获取依赖的指定版本mod -vendor将依赖直接放在 vendor 目录中\ngo modules\n从 vgo 发展而来。\nGo modules 在 1.11 属于试验特性，环境变量GO111MODULE用于控制其开关，取值 auto/on/off，默认 auto。\n从 1.16 开始，默认开启 go modules，即使项目中没有 go. mod 文件。计划在 1.17 中完全废弃对 GOPATH 模式的支持。\n工作流\n使用 go modules 进行依赖管理的日常工作流如下：\n\n\n在 Go 源码中，使用 import 语句导入需要的包\n\n\n调用 go build/test 等命令时，会自动将依赖加入到 go. mod 并下载依赖\n\n\n如果需要限定依赖的版本，你可以选用以下方法之一：\n\n使用 go get，例如：\n\n\n\ngo get foo@v1.2.3\ngo get foo@master\ngo get foo@e3702bed2 \n2. 手工修改 go. mod 文件\n\n代理\n很多 Google 的库在国内无法访问，可以设置环境变量：\n# 默认源\nexport GOPROXY= goproxy.io\n \n# 国内源\nexport GOPROXY= goproxy.cn\n这样，所有模块都会通过此代理下载。\n访问私有仓库\n你需要在仓库软件管理页面创建自己的 Access Token，并配置 Git：\n#                                用户 Token\ngit config --global url.&quot; https://alex:***@git.pacloud.io&quot;.insteadOf &quot; git.pacloud.io&quot;\n \n# SSH 方式\ngit config --global url.&quot; git@git.tencent.com : &quot;. insteadOf &quot; git.tencent.com/&quot;\n然后，需要设置跳过代理：\nexport GOPRIVATE=*. pacloud. io,*. gmem. cc\n命令\nGo modules 在go mod下定义了若干子命令：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n子命令说明init初始化一个新模块，示例：cd gotoolsgo mod init github. com/gmemcc/gotoolsdownload将模块下载到本地缓存edit编辑 go. modgraph打印模块依赖图tidy添加缺失的、移除多余的模块vendor将依赖的副本拷贝到 vendor 目录verify验证依赖是否满足期望why解释包或模块为何被 main 模块需要：go mod why github. com/coreos/etcd\n此外，你还可能用到以下 Go 命令：\n# 显示构建时会实际使用的直接、间接依赖的版本\ngo list -m all\n \n# 显示所有直接、间接依赖可用的 minor/patch 版本更新\ngo list -u -m all\n \n# 列出依赖的可用版本\ngo list -m -json -versions go. etcd. io/ etcd@latest\n \n# 更新所有直接、间接依赖到最新的 minor 版本\ngo get -u\n# 更新指定的依赖\ngo get -u -v go. etcd. io/etcd\n# 更新所有直接、间接依赖到最新的 patch 版本\ngo get -u=patch\n \n# 在模块根目录下执行，构建或测试模块的所有包\ngo build ./...\ngo test ./...\n \n# 修剪不再需要的依赖\ngo mod tidy\n \n# 创建并同步到 vendor 目录\ngo mod vendor\ngo.mod\n仅仅包含四个指令：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n指令说明module声明当前模块的标识：module github. com/my/thing此标识提供了模块路径（module path），模块中所有包的导入路径，都以此模块路径为前缀。模块路径 + 包相对于 go. mod 的路径共同决定了包的导入路径require声明依赖：require (     github. com/some/dependency v1.2.3     github. com/another/dependency/v4 v4.0.0)replace仅仅针对当前（主）模块，在构建主模块时，非主模块的 go. mod 中 replace 声明被忽略。该指令可以：1. 用来映射导入路径（在你 Fork 一个项目并做补丁的情况下使用）：# 模块代码中使用的导入路径                       实际寻找代码时的导入路径replace example. com/original/import/path ⇒ /your/forked/import/path2. 精确的控制依赖的版本：replace example. com/some/dependency ⇒ example. com/some/dependency v1.2.33. 提示一个多模块协作项目的模块位于磁盘的绝对、相对路径：module example. com/me/hello require (   example. com/me/goodbye v0.0.0) replace git. yun. gmem. cc/eks/chart-service ⇒ ../chart-service这种用法可以将依赖位置定位到磁盘，解除对 VCS 的依赖exclude仅仅针对当前（主）模块，在构建主模块时，非主模块的 go. mod 中 exclude 声明被忽略该指令用于禁止某个直接或传递性的依赖包，例如：exclude k8s. io/client-go v2.0.0-alpha. 0.0.20190313235726-6ee68ca5fd83+incompatible\n模块\n一个 Go 项目通常会在 Git 上托管源码，例如 github. com/gmem/gotools，项目的代码库的 URL 称为代码库（Repo）。\n在同一 Repo 中，可以有多个包（Package），在 Go 1.11 中这些包被抽象为模块（Module）—— 模块是一系列相关包的集合，使用go. mod来记录模块的元数据。\nGoogle 的风格是使用单个代码库（Mono Repo），包括像 Istio 这样的项目，所有组件都在同一个代码库中。这种情况下，在单个代码库中创建多个模块是自然的需求，Go modules 支持这种需求：\n# 单代码库单模块\nmonorepo-single-mod\n├── go. mod\n├── pkga\n├── pkgb\n└── pkgc\n \n# 单代码库多模块\nmonorepo-multi-mods\n├── proj1\n│   ├── go. mod\n│   ├── pkga\n│   ├── pkgb\n│   └── pkgc\n├── proj2\n│   ├── go. mod\n│   ├── pkga\n│   ├── pkgb\n│   └── pkgc\n└── proj3\n    ├── go. mod\n    ├── pkga\n    ├── pkgb\n    └── pkgc\n逐级的 1: N 关系：Repo ⇨ Module ⇨ Package ⇨ Source。\n依赖搜索模式\n我们最熟悉的依赖搜索模式：vender、$GOPATH 下搜索，叫做 GOPATH mode。从 1.8 开始，可以不去显式的设置 GOPATH，SDK 默认使用~/go\nGo modules 引入一种新的 Module-aware mode，在此模式下：\n\n\n你的项目源码不需要放在 GOPATH 下\n\n\n源码树的顶层目录下有一个 go. mod 文件，这种文件定义了一个 Go 模块\n\n\n放置了 go. mod 的目录称为模块根目录，它通常是源码库的根目录，但非必须\n\n\n模块根目录，及其子目录中的所有 Go 包，都属于模块。除了那些自身定义了 go. mod 的子目录\n\n\nGo 编译器不再在 vendor、GOPATH 下寻找第三方 Go 包，而是会直接去下载并编译，然后更新 go.mod：\n\n\nmodule proj1\n \n// 分析出的依赖，放到 require 区域\nrequire (\n    # 使用最新版的代码，并以 Pseudo-versions 形式记录\n    github. com/gmem/gotools/x v0.0.0-20190515063616-861b08fcd24b\n    github. com/gmem/gotools/y v0.0.0-20190515005150-3e3f9af80a02 // indirect   传递性依赖\n) \n\nGo 编译器会把下载的依赖包，缓存到$GOPATH/pkg/mod目录下\n\n依赖版本选择\ngo. mod 一旦被创建，其内容将被 Go 工具链管理，执行 get/build/mod 都会导致 go. mod 被修改。\n命令go list -m输出的信息被称为 build list，它是构建当前 module 所要构建的所有相关 Package（及其版本）的列表：\n// go list -m -json all\n{\n    &quot;Path&quot;: &quot;proj1&quot;,\n    &quot;Main&quot;: true,\n    &quot;Dir&quot;: &quot;/root/proj1&quot;\n}\n{\n    &quot;Path&quot;: &quot;github. com/gmem/gotools/x&quot;,\n    &quot;Version&quot;: &quot;v0.0.0-20190515063616-861b08fcd24b&quot;,\n    &quot;Time&quot;: &quot;2015-05-15T06:36:16Z&quot;,\n    &quot;Dir&quot;: &quot;/home/alex/Go/workspaces/default/pkg/mod/github. com/gmem/gotools/ x@v0.0.0-20190515063616-861b08fcd24b &quot;\n}\n标记为 Main: true 的模块，称为主模块（main module），即执行 Go 命令所在的目录。Go 会在当前目录，以及当前目录的祖先目录寻找 go. mod 文件。\n如果依赖打了发布版的 Tag，则不会使用最新版的代码的 Pseudo-version，而是使用最新的发布版。\n如果需要显式依赖指定版本，可以使用命令来操控 go. mod：\ngo mod -require=github. com/gmem/gotools/ x@v1.0.0\ngo mod -require=github. com/gmem/gotools/ y@v1.1.0\n上述命令修改 go. mod：\nrequire (\n    github. com/gmem/gotools/x v1.0.0 // indirect\n    github. com/gmem/gotools/y v1.1.0 // indirect\n)\n你还可以指定依赖表达式：\ngo mod -require=&#039;github. com/gmem/gotools/y@&gt;=v1.1.0&#039;\n使用 go get 命令，可以更新 go. mod 中的依赖为指定分支的最新 Commit：\ngo get -u git. pacloud. io/pks/ helm-operator@master \n版本号格式\n发布版 Tag 必须是vMAJOR. MINOR. PATCH格式。\nincompatible表示你的依赖不支持 Go modeules。\nPseudo-version 的格式是v0.0.0-yyyymmddhhmmss-abcdefabcdef。\n版本号升级\n对于一个库 helm. sh/helm，Tag 1.x.x 发布后，消费者这样引用：\nrequire helm. sh/helm v1.0.0 \n没有问题。但是如果主版本改成 3.x.x，引用：\nrequire helm. sh/helm v3.0.2 \n就会提示：require helm. sh/helm: version “v3.0.2” invalid: module contains a go. mod file, so major version must be compatible: should be v0 or v1, not v3\n解决办法是，对于 3. x 版本，（库的作者）修改模块路径，添加一个 v3 后缀：\n# Git 仓库地址 github.com/helm/helm 一直不变\nmodule helm. sh/helm/v3\n相应的，消费者这样引用：require helm. sh/helm/v3 v3.0.2\n如果你想 Fork 此库到 Git 私服 git. pacloud. io/pks/helm，然后 Replace 时必须这样写：\n#                                          注意这个 v3 不能少，否则报错\n# replace git. pacloud. io/pks/helm: version &quot;v3.0.2&quot; invalid: module contains a go. mod file,\n# so major version must be compatible: should be v0 or v1, not v3\nhelm. sh/helm/v3 =&gt; git. pacloud. io/pks/helm/v3 v3.0.2\n同步到 vendor\n使用下面的命令，可以将某个模块的全部依赖保存一份副本到根目录的 vendor 目录：\ngo mod vendor\n这样，你就可以使用 vendor 下的包来构建当前模块了：\ngo build -getmode=vendor tool. go\n生成的 vendor 还可以用来兼容 1.11 以前的版本，但是由于 1.11 以前的版本不支持在 GOPATH 之外使用 vendor 机制，因此你需要把代码库移动到$GOPATH/src 下。\nvendor 模式\nGo modules 支持使用 vendoring 模式：\n# 使用环境变量\nexport GOFLAGS=-mod=vendor\n \n# 或者\ngo build -mod=vendor ...\n上述命令提示 Go 命令使用 main 模块的 vendor 目录来满足依赖，而忽略 go. mod 中的指令。\n最佳实践\n代码组织\nGo 代码包含在工作区中：\n\n\n你通常把所有的 Go 代码存放在单一的工作区中\n\n\n一个工作区中可能包含多个版本控制仓库\n\n\n每个仓库中可能包含一个或者多个包\n\n\n每个包会包含一个或者多个位于单个目录中的 Go 源码文件\n\n\n到达包的目录路径，对应了它的导入路径\n\n\n一个工作区包含以下目录：\n\n\nsrc 目录包含源代码。其中常常包含多个版本库。源代码文件必须总是以 UTF-8 方式存储\n\n\npkg 目录包含包对象\n\n\nbin 目录可执行文件\n\n\nGOPATH\n该环境变量指定你的工作区的位置，默认指向$HOME/go\n导入路径\n导入路径唯一的识别包，一个包的导入路径对应了它在工作区中、或者远程仓库中的位置。\n标准库占用了很多简短的导入路径，例如 fmt、net/http。设计自己的包时，你要注意避免导入路径的冲突。例如，可以使用你的 GitHub 账号作为包路径前缀。\n命名\n驼峰式记法\n变量命名使用驼峰式大小写。\nGetter/Setter\n不提供 Getter/Setter 支持，如果你有一个字段 owner，建议Owner ()方法作为 Getter，SetOwner ()作为 Setter。\n接口名\n一般只有一个方法的接口，以er作为后缀，例如 Reader、Writer、Formatter、CloseNotifier。\n包名\n包名应该是导入路径的最后一段：位于 src/encoding/base64 的包，其导入路径为 encoding/base64，而其包名是 base64。\n包命名方面没有硬性规定。但是作为惯例，包名应该尽可能简短、仅仅使用小写字母。\n包名仅仅用于导入，不需要是全局唯一的，如果出现名字冲突，你可以在导入时赋予别名：\n//     别名包名\nimport FMT &quot;fmt&quot;\n \nfunc main () {\n    FMT.Print (0)\n}\n工程布局\nGo 官方没有提供开发工程的结构的标准布局，下面是 Go 生态系统中常用的一种布局：\n/cmd 存放工程会产生的所有二进制文件\n/binname/main. go 二进制文件 binname 的入口点函数，量尽量少的胶水代码\n/internal 存放工程私有的、不需要被其它应用程序或者库引用的 Go 代码\n/app  私有应用程序代码\n/pkg 可以被私有应用程序共享的库代码\n/pkg  可以被外部应用导入、使用的库代码\n/vendor  依赖的外部库代码\n/api  OpenAPI/Swagger Specs、JSON Schema 文件、Protocol 定义文件\n/web  Web 应用的特殊组件，例如静态资产、服务器端模板\n/configs  配置文件模板、默认配置\n/init 系统初始化（Systemd、System V 等）配置、进程管理器（Supervisor）配置\n/scripts  执行构建、安装、分析等任务的脚本\n/build  打包和 CI 用目录\n/package  云/容器/操作系统级别的打包配置信息\n/ci  持续集成配置信息\n/deployments  IaaS/PaaS/容器编排的配置文件，例如 K8S 资源定义，或者 Chart\n/test 额外的外部测试应用，以及测试数据\n/docs 设计文档、用户手册\n/tools  工程的支持性工具\n/examples  示例代码\n/assets  资产文件，例如图片、图标\n/githooks  Git 的钩子\n测试\nGo 提供了一个轻量级的测试框架，此框架由test包和go test命令组成。\n要编写测试用例，你需要创建一个以_test. go结尾的源文件。该文件中包含名为func TestXXX (t *testing. T)的函数。\n注意：运行一个测试文件时，里面的所有函数在一个进程内调用完成。\n远程包\n包的导入路径可以用来描述如何从某个版本控制系统（Git 或者 Mercurial）获取包的源代码。go 命令会自动基于此路径从远程仓库自动抓取包（及其依赖的其它包）：\ngo get github. com/golang/example/hello\n如果上述包不存在于本地工作区，则 go 命令会自动下载到工作区。如果上述包已经存在，则 go get 的行为和 go install 相同。\nGetter/Setter\nGo 没有提供统一的 Getter/Setter 支持，参考如下方式：\ntype User struct {\n    // 字段小写，表示不导出到包外部\n    name string\n}\n \n// Getter，不需要 Get 前缀\nfunc (user *User) Name () string {\n    return user. name\n}\n \n// Setter，通常使用 Set 前缀\nfunc (user *User) SetName (name string) {\n    user. name = name\n}\n接口名称\n作为惯例，单方法的接口，命名使用-er 后缀，例如 Reader、Writer、Formatter。\n驼峰式大小写\n如果一个标识符包含多个单词，Go 中惯例的方式是使用 CamelCase 或者 camelCase 风格的驼峰式大小写，而不是使用下划线。\n暴露接口而非实现\n如果某个类型仅仅是为了实现一个接口，则应该导出接口，而非类型本身。然后使用构造函数创建类型的实例：\n// 接口\ntype Block interface {\n    BlockSize () int\n    Encrypt (src, dst []byte)\n    Decrypt (src, dst []byte)\n}\n \ntype Stream interface {\n    XORKeyStream (dst, src []byte)\n}\n \n// 构造函数\nfunc NewCTR (block Block, iv []byte) Streamgcflags\n \n// 实现 ...\n内存\nGo 语言使用垃圾回收机制，这可能导致性能问题。要编写高性能的应用程序，应当尽量避免触发 GC。\n内存重用和对象池\n利用 sync. Pool，预先分配好一块内存，然后反复的使用它。这样不但 GC 压力小，而且 CPU 缓存命中更高、TLB 效率更高，代码的速度可能提升 10 倍。\n避免使用指针\n引用“外部”对象具有与生俱来的开销：\n\n\n指向对象需要 8 字节\n\n\n每个独立对象具有隐藏的内存开销，可能在 8-16 字节之间\n\n\n使用引用（指针）效率更低，因为 GC 写屏障的存在\n\n\n因此，如果不需要共享 OtherStuff，使用下面的风格：\ntype MyContainer struct {\n  inlineStruct OtherStuff\n}\n而非：\ntype MyContainer struct {\n  outoflineStruct *OtherStruct\n}\n不要提供需要内存分配的 API\n倾向于：\n// 由调用者提供缓冲\nfunc (r *Reader) Read (buf []byte) (int, error)\n而不是：\nfunc (r *Reader) Read () ([]byte, error)\n后者可能导致大量内存分配。\n关于 Goroutine\n\n\nGoroutine基本上只有栈的开销，一开始栈只有 2KB\n\n\n尽管 Goroutine 成本较低，还是要避免在主要的请求处理路径上创建 Goroutine。提前创建 Goroutine 并让其等待输入\n\n\nToString\n为任何命名类型实现如下签名的方法，即可获得类似 Java 的 toString () 的功能：\npackage main\nimport &quot;fmt&quot;\n \ntype bin int\nfunc (b bin) String () string {\n        return fmt.Sprintf (&quot;%b&quot;, b)\n}\n \nfunc main () {\n        fmt.Println (bin (42))  // 101010\n}\n远程调试\n构建选项\n为了保留调试信息，你需要在构建时设置特定的标记：\ngo build -i -a -o build/eb-rdbg -gcflags=&quot;all=-N -l&quot; -ldflags=&#039;-linkmode internal&#039;\n                                -gcflags=&quot;-N -l&quot;  # 1.10 之前的版本，用于保留调试信息\n运行应用程序\n你需要通过 dlv 来启动被调试应用程序，dlv 具有反复重启被调试程序的能力：\n# 需要预先安装 dlv\ngo get -u github. com/derekparker/delve/cmd/dlv\n# 启动应用程序\ndlv --listen=: 2345 --headless=true --api-version=2 exec build/eb-rdbg\n连接到应用程序\n你需要连接到被调试应用程序：\ndlv connect localhost:2345\n如果使用 IDE，则更加简单。例如对于 Goland，你只需要创建一个 Go Remote 类型的 Run Configuration 即可。\n调试命令\n连接到被调试应用程序后，你会看到(dlv)命令提示符，以下命令可用：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n 命令说明hhelp显示命令列表，或者显示某个命令的帮助：# 显示命令列表help# 显示 config 命令的帮助信息help config config进行 dlv 配置：# 列出配置config -list # 保存位置到磁盘，覆盖当前配置文件config -save示例：# 进行源码路径映射config substitute-path /go/src /home/alex/Go/workspaces/default/src bbreak设置断点，格式：break [name] &lt; linespec&gt;其中 linespec 格式可以是：1. &lt; address&gt;，内存地址2. &lt; filename&gt;:&lt; line&gt;，文件路径和行号，文件路径可以是部分路径，甚至仅仅是 basename，只要不产生歧义即可3. +&lt; offset&gt;，当前行的后面 N 行4. -&lt; offset&gt;，当前行的前面 N 行5. &lt; function&gt;[:&lt; line&gt;]，指定函数的第 N 行，函数的完整形式&lt; package&gt;. (&lt; receiver type&gt;).&lt; function name&gt;，但是仅仅 function name 是必须的，其它的可以省略（只要不产生歧义）6. /&lt; regex&gt;/，匹配正则式的位置示例：b pkg/cmd/cli/restic/server. go:156 condcondition设置条件式断点：condition &lt; breakpoint name or id&gt; &lt; boolean expression&gt;bpbreakpoints列出断点clear删除一个断点：clear &lt; breakpoint name or id&gt;clearall删除全部断点on到达断点时执行命令：on &lt; breakpoint name or id&gt; &lt; command&gt;，可用命令 print, stack, goroutineccontinue执行到下一个断点，或者程序结束locals打印本地变量：[goroutine &lt; n&gt;] [frame &lt; m&gt;] locals [-v] [&lt; regex&gt;]vars打印包变量：vars [-v] [&lt; regex&gt;]print估算一个表达式的值：[goroutine &lt; n&gt;] [frame &lt; m&gt;] print &lt; expression&gt;whatis打印表达式的类型：whatis &lt; expression&gt;set设置变量的值：[goroutine &lt; n&gt;] [frame &lt; m&gt;] set &lt; variable&gt; = &lt; value&gt;nnextStep Over：next [count]，count 指定前进多少行sstep单步跟踪，遇到函数会自动 Step IntosostepoutStep Outbtstack打印当前调用栈up向上移动帧，可以同时指定在其上执行命令：up [&lt; m&gt;] &lt; command&gt;down向下移动帧，可以同时指定在其上执行命令：down [&lt; m&gt;] &lt; command&gt;frame设置当前帧，或者在一个指定的帧上执行命令：frame &lt; m&gt; &lt; command&gt;llist列出当前调用栈对应的源码也可以指定列出任何协程的源码：[goroutine &lt; n&gt;] [frame &lt; m&gt;] list [&lt; linespec&gt;]funcs列出函数，一般都要带正则式，否则太多了：grgoroutine显示协程，或者切换当前协程：goroutine &lt; id&gt; &lt; command&gt;grsgoroutines列出所有协程libraries列出加载的动态库sources列出所有源文件清单restart重启被调试进程，dlv 进程保持不变qexit退出调试客户端deferred在延迟调用上下文中执行命令args打印程序参数disassemble执行反汇编regs打印寄存器内容\n常见问题\n零散问题\n编译报错 cannot load… but does not contain package\n使用命令go mod tidy可以发现根源。\n调用包内函数提示 undefiend\n原因是构建时没有引用目标函数所在文件，可以这样进行构建：\ngo build *. go\n容器内报错 no such file or directory\n找不到可执行文件：could not launch process: fork/exec /eb-rdbg: no such file or directory\n实际上此文件是存在的，只是二进制格式不支持。CGO_ENABLED=0 后发现解决。\ngo get 私有仓库报错 disabled by GOPRIVATE/GONOPROXY\n命令：go get -u git. pacloud. io/pks/ addons-api-server@develop\n报错原因：可能因为执行命令时 Gitlab 正在处理 develop 分支的 Push\nchecksum mismatch\n基于 Go Modules 进行构建，或者执行命令go mod tiny可能产生此错误。可能需要清除 mod 缓存重新下载：\ngo clean -modcache\ncd project &amp;&amp; rm go. sum\ngo mod tidy"},"A计科工程/编程语言/Go/字符串":{"title":"字符串","links":[],"tags":[],"content":"Golang 字符串\n字符串拼接1\n常见方法\n\n使用+\n使用fmt.Sprintf\n使用strings.Builder\n使用bytes.Buffer\n使用[]byte\n使用strings.Join\n\n参考链接\nFootnotes\n\n\ngeektutu.com/post/hpg-string-concat.html ↩\n\n\n"},"A计科工程/编程语言/Lua/Lua-笔记":{"title":"Lua 笔记","links":["/"],"tags":[],"content":"基本语法\n注释\n\n单行注释：-- 单行注释\n多行注释：--[[ 多行注释 ]]--\n\n关键词\n以下列出了 lua 的保留关键词。保留关键字不能作为常量或变量或其他用户自定义标示符：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nandbreakdoelseelseifendfalseforfunctionifinlocalnilnotorrepeatreturnthentrueuntilwhilegoto\n数据类型\nLua 是动态类型语言，变量不要类型定义，只需要为变量赋值。值可以存储在变量中，\r\n作为参数传递或结果返回。\nLua 中有 8 个基本类型分别为：nil、boolean、number、string、userdata、function、\r\nthread 和 table.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型描述nil这个最简单，只有值 nil 属于该类，表示一个无效值（在条件表达式中相当于 false）.booleanfalse, truenumber表示双精度类型的实浮点数string字符串由一对双引号或单引号来表示function由 C 或 Lua 编写的函数userdata表示任意存储在变量中的 C 数据结构thread表示执行的独立线路，用于执行协同程序tableLua 中的表（table）其实是一个”关联数组”（associative arrays）, 数组的索引可以是数字、字符串或表类型。\n在 lua 里，table 的创建是通过”构造表达式”来完成，最简单构造表达式是{}，用来创建一个空表。\n变量\n在默认情况下，lua 中的变量总是认为是全局的。\n全局变量不需要声明，给一个变量赋值后即创建了这个全局变量，访问一个没有初始化的\r\n全局变量也不会出错，只不过得到的结果是：nil.\n如果你想删除一个全局变量，只需要将变量赋值为 nil.\n变量在使用前，需要在代码中进行声明，即创建该变量。\n编译程序执行代码之前编译器需要知道如何给语句变量开辟存储区，用于存储变量的值。\nLua 变量有三种类型：全局变量、局部变量、表中的域。\nLua 中的变量全是全局变量, 哪怕是语句块或是函数里，除非用 local 显式声明为局部变量。\n局部变量的作用域为从声明位置开始到所在语句块结束。\n变量的默认值均为 nil.\n赋值语句\n赋值是改变一个变量的值和改变表域的最基本的方法。\na = &quot;hello&quot; .. &quot;world&quot;\nt.n = t.n + 1\nLua 可以对多个变量同时赋值，变量列表和值列表的各个元素用逗号分开，赋值语句右边的\r\n值会依次赋给左边的变量。\na, b = 10, 2*x       &lt;--&gt;       a=10; b=2*x\n遇到赋值语句 Lua 会先计算右边所有的值然后再执行赋值操作，所以我们可以这样进行交换变量的值：\nx, y = y, x                     -- swap &#039;x&#039; for &#039;y&#039;\na[i], a[j] = a[j], a[i]         -- swap &#039;a[i]&#039; for &#039;a[j]&#039;\n当变量个数和值的个数不一致时，Lua 会一直以变量个数为基础采取以下策略：\r\na. 变量个数 &gt; 值的个数 按变量个数补足 nil\r\nb. 变量个数 &lt; 值的个数 多余的值会被忽略\n循环语句\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n循环类型描述while在条件为 true 时，让程序重复地执行某些语句。for重复执行指定语句，重复次数可在 for 语句中控制。repeat until重复执行循环，直到 指定的条件为真时为止\nwhile 循环\nwhile(condition)\ndo\n   statements\nend\na=10\nwhile( a &lt; 20 )\ndo\n   print(&quot;a 的值为:&quot;, a)\n   a = a+1\nend\nfor 循环\n\n数值 for 循环：\n\nfor var=exp1,exp2,exp3 do\n    &lt;执行体&gt;\nend\nvar 从 exp1 变化到 exp2, 每次变化以 exp3 为步长递增 var，并执行一次 “执行体”.\r\nexp3 是可选的，如果不指定，默认为 1。\nfor i=1,f(x) do\n    print(i)\nend\n \nfor i=10,1,-1 do\n    print(i)\nend\nfor 的三个表达式在循环开始前一次性求值，以后不再进行求值。比如上面的 f(x) 只会\r\n在循环开始前执行一次，其结果用在后面的循环中。\n验证如下：\n#!/usr/local/bin/lua  \nfunction f(x)  \n    print(&quot;function&quot;)  \n    return x*2  \nend  \nfor i=1,f(5) do print(i)  \nend\n以上输出结果为：\nfunction\r\n1\r\n2\r\n3\r\n4\r\n5\r\n6\r\n7\r\n8\r\n9\r\n10\n\n\n泛型 for 循环：\r\n泛型 for 循环通过一个迭代器函数来遍历所有值，类似 java 中的 foreach 语句。\n\nLua 编程语言中泛型 for 循环语法格式：\n--打印数组a的所有值\na = {&quot;one&quot;, &quot;two&quot;, &quot;three&quot;}\nfor i, v in ipairs(a) do\n    print(i, v)\nend\ni 是数组索引值，v 是对应索引的数组元素值。ipairs 是 Lua 提供的一个迭代器函数，\r\n用来迭代数组。\n循环数组 days：\n#!/usr/local/bin/lua  \ndays = {&quot;Sunday&quot;,&quot;Monday&quot;,&quot;Tuesday&quot;,&quot;Wednesday&quot;,&quot;Thursday&quot;,&quot;Friday&quot;,&quot;Saturday&quot;}  \nfor i,v in ipairs(days) do  print(v) end  \n以上实例输出结果为：\nSunday\r\nMonday\r\nTuesday\r\nWednesday\r\nThursday\r\nFriday\r\nSaturday\n\nrepeat\nLua 编程语言中 repeat…until 循环语句不同于 for 和 while 循环，for 和 while\r\n循环的条件语句在当前循环执行开始时判断，而 repeat…until 循环的条件语句在当前\r\n循环结束后判断。\nrepeat\n   statements\nuntil( condition )\n--[ 变量定义 --]\na = 10\n--[ 执行循环 --]\nrepeat\n   print(&quot;a的值为:&quot;, a)\n   a = a + 1\nuntil( a &gt; 15 )\n循环控制\n\n\nbreak\r\n退出当前循环或语句，并开始脚本执行紧接着的语句。\n\n\ngoto\r\n将程序的控制点转移到一个标签处。:: Label ::\n\n\nlocal a = 1\n::label:: print(&quot;--- goto label ---&quot;)\n \na = a+1\nif a &lt; 3 then\n    goto label   -- a 小于 3 的时候跳转到标签 label\nend\n流程控制\nLua 编程语言流程控制语句通过程序设定一个或多个条件语句来设定。在条件为 true 时\r\n执行指定程序代码，在条件为 false 时执行其他指定代码。\n--[ 0 为 true ]\nif(0)\nthen\n    print(&quot;0 为 true&quot;)\nend\n--[ 定义变量 --]\na = 100;\n--[ 检查条件 --]\nif( a &lt; 20 )\nthen\n   --[ if 条件为 true 时执行该语句块 --]\n   print(&quot;a 小于 20&quot; )\nelse\n   --[ if 条件为 false 时执行该语句块 --]\n   print(&quot;a 大于 20&quot; )\nend\nprint(&quot;a 的值为 :&quot;, a)\n--[ 定义变量 --]\na = 100\n \n--[ 检查布尔条件 --]\nif( a == 10 )\nthen\n   --[ 如果条件为 true 打印以下信息 --]\n   print(&quot;a 的值为 10&quot; )\nelseif( a == 20 )\nthen  \n   --[ if else if 条件为 true 时打印以下信息 --]\n   print(&quot;a 的值为 20&quot; )\nelseif( a == 30 )\nthen\n   --[ if else if condition 条件为 true 时打印以下信息 --]\n   print(&quot;a 的值为 30&quot; )\nelse\n   --[ 以上条件语句没有一个为 true 时打印以下信息 --]\n   print(&quot;没有匹配 a 的值&quot; )\nend\nprint(&quot;a 的真实值为: &quot;, a )\n函数\n在 lua 中，函数是对语句和表达式进行抽象的主要方法。既可以用来处理一些特殊的工作，\r\n也可以用来计算一些值。\nLua 提供了许多的内建函数，你可以很方便的在程序中调用它们，如 print() 函数可以将\r\n传入的参数打印在控制台上。\nLua 函数主要有两种用途：\n\n1.完成指定的任务，这种情况下函数作为调用语句使用；\n2.计算并返回值，这种情况下函数作为赋值语句的表达式使用。\n\nLua 编程语言函数定义格式如下：\noptional_function_scope function function_name( argument1, argument2, argument3..., argumentn)\n    function_body\n    return result_params_comma_separated\nend\n解析：\n\noptional_function_scope: 该参数是可选的制定函数是全局函数还是局部函数，\r\n未设置该参数默认为全局函数，如果你需要设置函数为局部函数需要使用关键字 local.\nfunction_name: 指定函数名称。\nargument1, argument2, argument3…, argumentn: 函数参数，多个参数以逗号隔开，函数也可以不带参数。\nfunction_body: 函数体，函数中需要执行的代码语句块。\nresult_params_comma_separated: 函数返回值，Lua 语言函数可以返回多个值，每个值以逗号隔开。\n\n多返回值\nLua 函数可以返回多个结果值。\n可变参数\nLua 函数可以接受可变数目的参数，在函数参数列表中使用...表示函数有可变的参数。\nfunction average(...)\n   result = 0\n   local arg={...}    --&gt; arg 为一个表，局部变量\n   for i,v in ipairs(arg) do\n      result = result + v\n   end\n   print(&quot;总共传入 &quot; .. #arg .. &quot; 个数&quot;)\n   return result/#arg\nend\n \nprint(&quot;平均值为&quot;,average(10,5,3,4,5,6))\n结果：\n总共传入 6 个数\n平均值为    5.5\n运算符\n算术运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作符描述实例+加法A + B 输出结果 30-减法A - B 输出结果 -10*乘法A * B 输出结果 200/除法B / A 输出结果 2%取余B % A 输出结果 0^乘幂A^2 输出结果 100-负号-A 输出结果 -10//整除运算符 (&gt;=lua5.3)5//2 输出结果 2\n关系运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作符描述实例==等于，检测两个值是否相等，相等返回 true，否则返回 false(A == B) 为 false。~=不等于，检测两个值是否相等，不相等返回 true，否则返回 false(A ~= B) 为 true。&gt;大于，如果左边的值大于右边的值，返回 true，否则返回 false(A &gt; B) 为 false。&lt;小于，如果左边的值大于右边的值，返回 false，否则返回 true(A &lt; B) 为 true。&gt;=大于等于，如果左边的值大于等于右边的值，返回 true，否则返回 false(A &gt;= B) 返回 false。⇐小于等于，如果左边的值小于等于右边的值，返回 true，否则返回 false(A ⇐ B) 返回 true。\n逻辑运算符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n操作符描述实例and逻辑与操作符。若 A 为 false，则返回 A，否则返回 B。(A and B) 为 false。or逻辑或操作符。若 A 为 true，则返回 A，否则返回 B。(A or B) 为 true。not逻辑非操作符。与逻辑运算结果相反，如果条件为 true，逻辑非为 false。not(A and B) 为 true。\n其他运算符\n\n.. 连接两个字符串\n# 一元运算符，返回字符串或表的长度\n\n字符串\n字符串的表达方式：\n\n单引号：local str1 = &#039;This is a string.&#039;\n双引号：local str2 = &quot;This is a string.&quot;\n: local str3 = [[This is a  multiline string]]\n\n字符串操作\n在 Neovim 中h: string.upper() 查看详细说明。\n\nstring.upper(str): 全部转化为大写字母\nstring.lower(str): 全部转化为小写字母\nstring.gsub(): 查找替换\nstring.find()：查找子串返回位置\nstring.reverse()：反转字符串\nstring.format(…)：格式化字符串，类似 c 的 print\nstring.char(), string.byte()：类型转化\nstring.len()：返回长度\n\n更多方法查看:h lua.lib.string\n数组"},"A计科工程/编程语言/Python/Python-笔记":{"title":"Python 笔记","links":[],"tags":["TODO","python"],"content":"PYTHON 笔记\n\n变量和数据类型\n变量\n在 Python 中，变量可以被视为数据的引用，它们指向计算机内存中存储的数据。Python 是一种动态类型语言，这意味着变量的类型是在运行时决定的，同一个变量可以重新赋值为任何类型。\n判断变量类型\ntype() 返回变量的类型\r\nisinstance() 判断是否为特定的类型\n作用域和生命周期\n在函数之外创建的变量为全局变量。全局变量可在函数内部和外部使用。在函数内部可以使用 global 关键字创建全局变量。\n数据类型"},"A计科工程/编程语言/Python/Python-虚拟环境":{"title":"Python 虚拟环境","links":[],"tags":["TODO","python"],"content":"Python 虚拟环境\n\nMiniconda\n配置\n使用镜像 conda config --set show_channel_urls yes, 然后编辑 .condarc\nchannels:\r\n  - defaults\r\nshow_channel_urls: true\r\ndefault_channels:\r\n  - mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main\r\n  - mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r\r\n  - mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2\r\ncustom_channels:\r\n  conda-forge: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  msys2: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  bioconda: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  menpo: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  pytorch: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  pytorch-lts: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  simpleitk: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud\r\n  deepmodeling: mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/\n\n运行 conda clean -i 清除索引缓存，保证用的是镜像站提供的索引。\r\n运行 conda create -n myenv numpy 测试一下吧\n参考链接"},"A计科工程/编程语言/Python/类属性延迟计算":{"title":"类属性延迟计算","links":[],"tags":[],"content":"所谓类属性的延迟计算就是将类的属性定义成一个 property，只在访问的时候才会计算，而且一旦被访问后，结果将会被缓存起来，不用每次都计算。\n实现\nclass LazyProperty(object):\n    def __init__(self, func):\n        self.func = func\n \n    def __get__(self, instance, owner):\n        if instance is None:\n            return self\n        else:\n            value = self.func(instance)\n            setattr(instance, self.func.__name__, value)\n            return value\n \n \nimport math\n \n \nclass Circle(object):\n    def __init__(self, radius):\n        self.radius = radius\n \n    @LazyProperty\n    def area(self):\n        print &#039;Computing area&#039;\n        return math.pi * self.radius ** 2\n \n    @LazyProperty\n    def perimeter(self):\n        print &#039;Computing perimeter&#039;\n        return 2 * math.pi * self.radius\n说明\n定义了一个延迟计算的装饰器类 LazyProperty。Circle 是用于测试的类，Circle 类有是三个属性半径 (radius)、面积 (area)、周长 (perimeter)。面积和周长的属性被 LazyProperty 装饰，下面来试试 LazyProperty 的魔法：\n&gt;&gt;&gt; c = Circle(2)\r\n&gt;&gt;&gt; print c.area\r\nComputing area\r\n12.5663706144\r\n&gt;&gt;&gt; print c.area\r\n12.5663706144\n\n在 area() 中每计算一次就会打印一次“Computing area”，而连续调用两次 c.area 后“Computing area”只被打印了一次。这得益于 LazyProperty，只要调用一次后，无论后续调用多少次都不会重复计算。"},"A计科工程/编程语言/Python/魔术方法":{"title":"魔术方法","links":[],"tags":["TODO"],"content":"魔术方法\n\n介绍\n在 Python 中，所有以“**”双下划线包起来的方法，都统称为“Magic Method”,例如类的初始化方法 **init\\_\\_ ,Python 中所有的魔术方法均在官方文档中有相应描述，但是对于官方的描述比较混乱而且组织比较松散。很难找到有一个例子。\n构造和初始化\n每个 Pythoner 都知道一个最基本的魔术方法， __init__ 。通过此方法我们可以定义一个对象的初始操作。然而，当调用 x = SomeClass() 的时候， __init__ 并不是第一个被调用的方法。实际上，还有一个叫做__new__ 的方法，两个共同构成了“构造函数”。\n__new__是用来创建类并返回这个类的实例，而__init__只是将传入的参数来初始化该实例。\n在对象生命周期调用结束时，__del__ 方法会被调用，可以将__del__理解为“构析函数”。下面通过代码的看一看这三个方法：\nfrom os.path import join\n \nclass FileObject:\n    &#039;&#039;&#039;给文件对象进行包装从而确认在删除时文件流关闭&#039;&#039;&#039;\n \n    def __init__(self, filepath=&#039;~&#039;, filename=&#039;sample.txt&#039;):\n        #读写模式打开一个文件\n        self.file = open(join(filepath, filename), &#039;r+&#039;)\n \n    def __del__(self):\n        self.file.close()\n        del self.file\n控制属性访问\n许多从其他语言转到 Python 的人会抱怨它缺乏类的真正封装。(没有办法定义私有变量，然后定义公共的 getter 和 setter)。Python 其实可以通过魔术方法来完成封装。我们来看一下：\n\n__getattr__(self, name):\n\n定义当用户试图获取一个不存在的属性时的行为。这适用于对普通拼写错误的获取和重定向，对获取一些不建议的属性时候给出警告 (如果你愿意你也可以计算并且给出一个值) 或者处理一个 AttributeError 。只有当调用不存在的属性的时候会被返回。\n\n__setattr__(self, name, value):\n\n与__getattr__(self, name)不同，__setattr__ 是一个封装的解决方案。无论属性是否存在，它都允许你定义对对属性的赋值行为，以为这你可以对属性的值进行个性定制。实现__setattr__时要避免”无限递归”的错误。\n\n__delattr__:\n\n与 __setattr__ 相同，但是功能是删除一个属性而不是设置他们。实现时也要防止无限递归现象发生。\n\n__getattribute__(self, name):\n\n__getattribute__定义了你的属性被访问时的行为，相比较，__getattr__只有该属性不存在时才会起作用。因此，在支持__getattribute__的 Python 版本，调用__getattr__前必定会调用 __getattribute__。__getattribute__同样要避免”无限递归”的错误。需要提醒的是，最好不要尝试去实现__getattribute__,因为很少见到这种做法，而且很容易出 bug。\n在进行属性访问控制定义的时候很可能会很容易引起“无限递归”。如下面代码：\n#  错误用法\ndef __setattr__(self, name, value):\n    self.name = value\n    # 每当属性被赋值的时候 (如 self.name = value)，``__setattr__()`` 会被调用，这样就造成了递归调用。\n    # 这意味这会调用 ``self.__setattr__(&#039;name&#039;, value)``，每次方法会调用自己。这样会造成程序崩溃。\n \n#  正确用法\ndef __setattr__(self, name, value):\n    self.__dict__[name] = value  # 给类中的属性名分配值\n    # 定制特有属性\nPython 的魔术方法很强大，但是用时却需要慎之又慎，了解正确的使用方法非常重要。\n创建自定义容器\n有很多方法可以让你的 Python 类行为向内置容器类型一样，比如我们常用的 list、dict、tuple、string 等等。Python 的容器类型分为可变类型 (如 list、dict) 和不可变类型（如 string、tuple），可变容器和不可变容器的区别在于，不可变容器一旦赋值后，不可对其中的某个元素进行修改。在讲创建自定义容器之前，应该先了解下协议。这里的协议跟其他语言中所谓的”接口”概念很像，它给你很多你必须定义的方法。然而在 Python 中的协议是很不正式的，不需要明确声明实现。事实上，他们更像一种指南。\n自定义容器的 magic method\n下面细致了解下定义容器可能用到的魔术方法。首先，实现不可变容器的话，你只能定义 __len__ 和 __getitem__ (下面会讲更多)。可变容器协议则需要所有不可变容器的所有，另外还需要 __setitem__ 和 __delitem__ 。如果你希望你的对象是可迭代的话，你需要定义 __iter__ 会返回一个迭代器。迭代器必须遵循迭代器协议，需要有 __iter__(返回它本身) 和 next。\n\n__len__(self):\n\n返回容器的长度。对于可变和不可变容器的协议，这都是其中的一部分。\n\n__getitem__(self, key):\n\n定义当某一项被访问时，使用*self[key]*所产生的行为。这也是不可变容器和可变容器协议的一部分。如果键的类型错误将产生 TypeError；如果 key 没有合适的值则产生 KeyError。\n\n__setitem__(self, key, value):\n\n当你执行self[key] = value时，调用的是该方法。\n\n__delitem__(self, key):\n\n定义当一个项目被删除时的行为 (比如 del self[key])。这只是可变容器协议中的一部分。当使用一个无效的键时应该抛出适当的异常。\n\n__iter__(self):\n\n返回一个容器迭代器，很多情况下会返回迭代器，尤其是当内置的iter()方法被调用的时候，以及当使用for x in container:方式循环的时候。迭代器是它们本身的对象，它们必须定义返回self的__iter__方法。\n\n__reversed__(self):\n\n实现当*reversed()*被调用时的行为。应该返回序列反转后的版本。仅当序列可以是有序的时候实现它，例如对于列表或者元组。\n\n__contains__(self, item):\n\n定义了调用 in 和 not in 来测试成员是否存在的时候所产生的行为。你可能会问为什么这个不是序列协议的一部分？因为当__contains__没有被定义的时候，如果没有定义，那么 Python 会迭代容器中的元素来一个一个比较，从而决定返回 True 或者 False。\n\n__missing__(self, key):\n\ndict 字典类型会有该方法，它定义了 key 如果在容器中找不到时触发的行为。比如d = {‘a’: 1}, 当你执行*d[notexist]*时，d.__missing__[&#039;notexist&#039;]就会被调用。\n一个列子\n下面是书中的例子，用魔术方法来实现 Haskell 语言中的一个数据结构。\n# -*- coding: utf-8 -*-\nclass FunctionalList:\n    &#039;&#039;&#039; 实现了内置类型 list 的功能，并丰富了一些其他方法：head, tail, init, last, drop, take&#039;&#039;&#039;\n \n    def __init__(self, values=None):\n        if values is None:\n            self.values = []\n        else:\n            self.values = values\n \n    def __len__(self):\n        return len(self.values)\n \n    def __getitem__(self, key):\n        return self.values[key]\n \n    def __setitem__(self, key, value):\n        self.values[key] = value\n \n    def __delitem__(self, key):\n        del self.values[key]\n \n    def __iter__(self):\n        return iter(self.values)\n \n    def __reversed__(self):\n        return FunctionalList(reversed(self.values))\n \n    def append(self, value):\n        self.values.append(value)\n    def head(self):\n        # 获取第一个元素\n        return self.values[0]\n    def tail(self):\n        # 获取第一个元素之后的所有元素\n        return self.values[1:]\n    def init(self):\n        # 获取最后一个元素之前的所有元素\n        return self.values[:-1]\n    def last(self):\n        # 获取最后一个元素\n        return self.values[-1]\n    def drop(self, n):\n        # 获取所有元素，除了前 N 个\n        return self.values[n:]\n    def take(self, n):\n        # 获取前 N 个元素\n        return self.values[:n]\n其实在 collections 模块中已经有了很多类似的实现，比如 Counter、OrderedDict 等等。\n反射\n你也可以控制怎么使用内置在函数 sisinstance() 和 issubclass() 方法 反射定义魔术方法。这个魔术方法是：\n\n__instancecheck__(self, instance):\n\n检查一个实例是不是你定义的类的实例\n\n__subclasscheck__(self, subclass):   检查一个类是不是你定义的类的子类\n\n这些魔术方法的用例看起来很小，并且确实非常实用。它们反应了关于面向对象程序上一些重要的东西在 Python 上，并且总的来说 Python: 总是一个简单的方法去找某些事情，即使是没有必要的。这些魔法方法可能看起来不是很有用，但是一旦你需要它们，你会感到庆幸它们的存在。\n可调用的对象\n你也许已经知道，在 Python 中，方法是最高级的对象。这意味着他们也可以被传递到方法中，就像其他对象一样。这是一个非常惊人的特性。\n在 Python 中，一个特殊的魔术方法可以让类的实例的行为表现的像函数一样，你可以调用它们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性，其让 Python 编程更加舒适甜美。\n\n__call__(self, [args...]):\n\n允许一个类的实例像函数一样被调用。实质上说，这意味着 x() 与 x.__call__() 是相同的。注意 __call__ 的参数可变。这意味着你可以定义 __call__ 为其他你想要的函数，无论有多少个参数。\n__call__ 在那些类的实例经常改变状态的时候会非常有效。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了：\n# -*- coding: UTF-8 -*-\n \nclass Entity:\n    &quot;&quot;&quot;\n    调用实体来改变实体的位置\n    &quot;&quot;&quot;\n \ndef __init__(self, size, x, y):\n    self.x, self.y = x, y\n    self.size = size\n \n \ndef __call__(self, x, y):\n    &quot;&quot;&quot;\n    改变实体的位置\n    &quot;&quot;&quot;\n    self.x, self.y = x, y\n上下文管理\nwith声明是从 Python2.5 开始引进的关键词。你应该遇过这样子的代码：\nwith open(&#039;foo.txt&#039;) as bar:\n    # do something with bar\n在 with 声明的代码段中，我们可以做一些对象的开始操作和退出操作，还能对异常进行处理。这需要实现两个魔术方法: __enter__ 和 __exit__。\n\n__enter__(self):\n\n定义了当使用 with 语句的时候，会话管理器在块被初始创建时要产生的行为。请注意，__enter__的返回值与 with 语句的目标或者 as 后的名字绑定。\n\n__exit__(self, exception_type, exception_value, traceback):\n\n定义了当一个代码块被执行或者终止后，会话管理器应该做什么。它可以被用来处理异常、执行清理工作或做一些代码块执行完毕之后的日常工作。如果代码块执行成功，exception_type，exception_value，和 traceback 将会为 None。否则，你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，请确保__exit__在所有语句结束之后返回 True。如果你想让异常被会话管理器处理的话，那么就让其产生该异常。\n创建对象描述器\n描述器是通过获取、设置以及删除的时候被访问的类。当然也可以改变其它的对象。描述器并不是独立的。相反，它意味着被一个所有者类持有。当创建面向对象的数据库或者类，里面含有相互依赖的属相时，描述器将会非常有用。一种典型的使用方法是用不同的单位表示同一个数值，或者表示某个数据的附加属性。为了成为一个描述器，一个类必须至少有__get__，__set__，__delete__方法被实现：\n\n\n__get__(self, instance, owner):\n定义了当描述器的值被取得的时候的行为。instance 是拥有该描述器对象的一个实例。owner 是拥有者本身\n\n\n__set__(self, instance, value):\n定义了当描述器的值被改变的时候的行为。instance 是拥有该描述器类的一个实例。value 是要设置的值。\n\n\n__delete__(self, instance):\n定义了当描述器的值被删除的时候的行为。instance 是拥有该描述器对象的一个实例。\n\n\n下面是一个描述器的实例：单位转换。\n# -*- coding: UTF-8 -*-\nclass Meter(object):\n    &quot;&quot;&quot;\n    对于单位&quot;米&quot;的描述器\n    &quot;&quot;&quot;\n \n    def __init__(self, value=0.0):\n        self.value = float(value)\n \n    def __get__(self, instance, owner):\n        return self.value\n \n    def __set__(self, instance, value):\n        self.value = float(value)\n \n \nclass Foot(object):\n    &quot;&quot;&quot;\n    对于单位&quot;英尺&quot;的描述器\n    &quot;&quot;&quot;\n \n    def __get__(self, instance, owner):\n        return instance.meter * 3.2808\n \n    def __set__(self, instance, value):\n        instance.meter = float(value) / 3.2808\n \n \nclass Distance(object):\n    &quot;&quot;&quot;\n    用米和英寸来表示两个描述器之间的距离\n    &quot;&quot;&quot;\n    meter = Meter(10)\n    foot = Foot()\n使用时：\n&gt;&gt;&gt;d = Distance()\r\n&gt;&gt;&gt;print d.foot\r\n&gt;&gt;&gt;print d.meter\r\n32.808\r\n10.0\n\n复制\n有时候，尤其是当你在处理可变对象时，你可能想要复制一个对象，然后对其做出一些改变而不希望影响原来的对象。这就是 Python 的 copy 所发挥作用的地方。\n\n__copy__(self):\n\n定义了当对你的类的实例调用*copy.copy()*时所产生的行为。*copy.copy()*返回了你的对象的一个浅拷贝——这意味着，当实例本身是一个新实例时，它的所有数据都被引用了——例如，当一个对象本身被复制了，它的数据仍然是被引用的（因此，对于浅拷贝中数据的更改仍然可能导致数据在原始对象的中的改变）。\n\n__deepcopy__(self, memodict={}):\n\n定义了当对你的类的实例调用*copy.deepcopy()*时所产生的行为。copy.deepcopy()返回了你的对象的一个深拷贝——对象和其数据都被拷贝了。memodict 是对之前被拷贝的对象的一个缓存——这优化了拷贝过程并且阻止了对递归数据结构拷贝时的无限递归。当你想要进行对一个单独的属性进行深拷贝时，调用copy.deepcopy()，并以 memodict 为第一个参数。\n附录\n用于比较的魔术方法\nMagic method\nexplain\n__cmp__(self, other)\n是比较方法里面最基本的的魔法方法\n__eq__(self, other)\n定义相等符号的行为，==\n__ne__(self,other)\n定义不等符号的行为，！=\n__lt__(self,other)\n定义小于符号的行为，&lt;\n__gt__(self,other)\n定义大于符号的行为，&gt;\n__le__(self,other)\n定义小于等于符号的行为，⇐\n__ge__(self,other)\n定义大于等于符号的行为，&gt;=\n数值计算的魔术方法\n单目运算符和函数\nMagic method\nexplain\n__pos__(self)\n实现一个取正数的操作\n__neg__(self)\n实现一个取负数的操作\n__abs__(self)\n实现一个内建的 abs() 函数的行为\n__invert__(self)\n实现一个取反操作符（～操作符）的行为\n__round__(self, n)\n实现一个内建的 round（）函数的行为\n__floor__(self)\n实现 math.floor() 的函数行为\n__ceil__(self)\n实现 math.ceil() 的函数行为\n__trunc__(self)\n实现 math.trunc() 的函数行为\n双目运算符或函数\nMagic method\nexplain\n__add__(self, other)\n实现一个加法\n__sub__(self, other)\n实现一个减法\n__mul__(self, other)\n实现一个乘法\n__floordiv__(self, other)\n实现一个“//”操作符产生的整除操作（）\n__div__(self, other)\n实现一个“/”操作符代表的除法操作\n__truediv__(self, other)\n实现真实除法\n__mod__(self, other)\n实现一个“%”操作符代表的取模操作\n__divmod__(self, other)\n实现一个内建函数 divmod（）\n__pow__\n实现一个指数操作 (“**”操作符）的行为\n__lshift__(self, other)\n实现一个位左移操作（&lt;&lt;）的功能\n__rshift__(self, other)\n实现一个位右移操作（&gt;&gt;）的功能\n__and__(self, other)\n实现一个按位进行与操作（&amp;）的行为\n__or__(self, other)\n实现一个按位进行或操作的行为\n__xor__(self, other)\n__xor__(self, other)\n增量运算\nMagic method\nexplain\n__iadd__(self, other)\n加法赋值\n__isub__(self, other)\n减法赋值\n__imul__(self, other)\n乘法赋值\n__ifloordiv__(self, other)\n整除赋值，地板除，相当于 //= 运算符\n__idiv__(self, other)\n除法赋值，相当于 /= 运算符\n__itruediv__(self, other)\n真除赋值\n__imod_(self, other)\n模赋值，相当于 %= 运算符\n__ipow__\n乘方赋值，相当于 **= 运算符\n__ilshift__(self, other)\n左移赋值，相当于 &lt;⇐ 运算符\n__irshift__(self, other)\n左移赋值，相当于 &gt;&gt;= 运算符\n__iand__(self, other)\n与赋值，相当于 &amp;= 运算符\n__ior__(self, other)\n或赋值\n__ixor__(self, other)\n异或运算符，相当于 ^= 运算符\n类型转换\nMagic method\nexplain\n__int__(self)\n转换成整型\n__long__(self)\n转换成长整型\n__float__(self)\n转换成浮点型\n__complex__(self)\n转换成 复数型\n__oct__(self)\n转换成八进制\n__hex__(self)\n转换成十六进制\n__index__(self)\n如果你定义了一个可能被用来做切片操作的数值型，你就应该定义index\n__trunc__(self)\n当 math.trunc(self) 使用时被调用__trunc__返回自身类型的整型截取\n__coerce__(self, other)\n执行混合类型的运算"},"A计科工程/编程语言/QT/Untitled":{"title":"Untitled","links":[],"tags":[],"content":"QtWebEngine\r\n加载本地 html 文件时，引入 css, js 等资源时，不能使用/path/xx.js 这种格式，需要使用相对路径。\n在 vite 项目设置中，可以通过设置 base 解决\n"},"A计科工程/编程语言/Rust/Cargo":{"title":"Cargo","links":[],"tags":["TODO","rust"],"content":"\n"},"A计科工程/编程语言/Rust/Rust-笔记":{"title":"Rust 笔记","links":["C知识宝库/名词"],"tags":["TODO","rust"],"content":"Rust\n\n数据类型\n标量类型\n整型\n浮点\n布尔\n字符\n复合类型\n元组\n参考链接"},"A计科工程/编程语言/Zig/Zig-笔记":{"title":"Zig 笔记","links":[],"tags":[],"content":"变量和数据类型\n变量声明\n声明变量可以使用 var 和 const, 如下：\nvar a : u8 = undefined;\nconst b = &quot;Hello World!&quot;;\n函数\nzig 函数参数是常量。"},"A计科工程/编辑器":{"title":"编辑器","links":[],"tags":[],"content":"fleet\nJetbrains 全家桶\nVscode\nzed\nneovim"},"A计科工程/网络安全":{"title":"网络安全","links":[],"tags":[],"content":"国内媒体的私自使用 P2P\n\n优先使用浏览器\n浏览器禁用 webrtc\nfirefox: about:config media.peerconnection.enabled\n"},"A计科工程/计算机基础":{"title":"计算机基础","links":[],"tags":["TODO","Doc"],"content":""},"B数据分析/jupyter":{"title":"jupyter","links":[],"tags":[],"content":"安装\npip config set global.index-url pypi.tuna.tsinghua.edu.cn/simple\r\n\r\n# arch\r\nsudo pacman -S python-jupyterlab_server\r\n#sudo pip install jupyterlab\r\n\r\njupyter-lab\n"},"C知识宝库/Git-提交规范":{"title":"Git 提交规范","links":[],"tags":["Doc"],"content":"约定式提交\n概述\n约定式提交规范是一种基于提交信息的轻量级约定。它提供了一组简单规则来创建清晰的提交历史；这更有利于编写自动化工具。通过在提交信息中描述功能、修复和破坏性变更，使这种惯例与 SemVer 相互对应。\n提交说明的结构如下所示：\n\n原文：\n&lt;type&gt;[optional scope]: &lt;description&gt;\r\n\r\n[optional body]\r\n\r\n[optional footer(s)]\n\n译文：\n&lt;类型&gt;[可选 范围]: &lt;描述&gt;\r\n\r\n[可选 正文]\r\n\r\n[可选 脚注]\n\n\n提交说明包含了下面的结构化元素，以向类库使用者表明其意图：\n\nfix: 类型 为 fix 的提交表示在代码库中修复了一个 bug（这和语义化版本中的 PATCH 相对应）。\nfeat: 类型 为 feat 的提交表示在代码库中新增了一个功能（这和语义化版本中的 MINOR 相对应）。\nBREAKING CHANGE: 在脚注中包含 BREAKING CHANGE: 或 &lt;类型&gt;(范围) 后面有一个 ! 的提交，表示引入了破坏性 API 变更（这和语义化版本中的 MAJOR 相对应）。破坏性变更可以是任意 类型 提交的一部分。\n除 fix: 和 feat: 之外，也可以使用其它提交 类型，例如 @commitlint/config-conventional（基于 Angular 约定）中推荐的 build:、chore:、 ci:、docs:、style:、refactor:、perf:、test:，等等。\n脚注中除了 BREAKING CHANGE: &lt;description&gt; ，其它条目应该采用类似 git trailer format 这样的惯例。\n\n其它提交类型在约定式提交规范中并没有强制限制，并且在语义化版本中没有隐式影响（除非它们包含 BREAKING CHANGE）。可以为提交类型添加一个围在圆括号内的范围，以为其提供额外的上下文信息。例如 feat(parser): adds ability to parse arrays.。\n示例\n包含了描述并且脚注中有破坏性变更的提交说明\nfeat: allow provided config object to extend other configs\r\n\r\nBREAKING CHANGE: `extends` key in config file is now used for extending other config files\n\n包含了 ! 字符以提醒注意破坏性变更的提交说明\nfeat!: send an email to the customer when a product is shipped\n\n包含了范围和破坏性变更 ! 的提交說明\nfeat(api)!: send an email to the customer when a product is shipped\n\n包含了 ! 和 BREAKING CHANGE 脚注的提交说明\nchore!: drop support for Node 6\r\n\r\nBREAKING CHANGE: use JavaScript features not available in Node 6.\n\n不包含正文的提交说明\ndocs: correct spelling of CHANGELOG\n\n包含范围的提交说明\nfeat(lang): add polish language\n\n包含多行正文和多行脚注的提交说明\nfix: prevent racing of requests\r\n\r\nIntroduce a request id and a reference to latest request. Dismiss\r\nincoming responses other than from latest request.\r\n\r\nRemove timeouts which were used to mitigate the racing issue but are\r\nobsolete now.\r\n\r\nReviewed-by: Z\r\nRefs: #123\n\n约定式提交规范\n本文中的关键词“必须（MUST）”、“禁止（MUST NOT）”、“必要（REQUIRED）”、“应当（SHALL）”、“不应当（SHALL NOT）”、“应该（SHOULD）”、“不应该（SHOULD NOT）”、“推荐（RECOMMENDED）”、“可以（MAY）”和“可选（OPTIONAL）” ，其相关解释参考 RFC 2119 。\n\n每个提交都必须使用类型字段前缀，它由一个名词构成，诸如 feat 或 fix ，其后接可选的范围字段，可选的 !，以及必要的冒号（英文半角）和空格。\n当一个提交为应用或类库实现了新功能时，必须使用 feat 类型。\n当一个提交为应用修复了 bug 时，必须使用 fix 类型。\n范围字段可以跟随在类型字段后面。范围必须是一个描述某部分代码的名词，并用圆括号包围，例如： fix(parser):\n描述字段必须直接跟在 &lt;类型&gt;(范围) 前缀的冒号和空格之后。描述指的是对代码变更的简短总结，例如：fix: array parsing issue when multiple spaces were contained in string。\n在简短描述之后，可以编写较长的提交正文，为代码变更提供额外的上下文信息。正文必须起始于描述字段结束的一个空行后。\n提交的正文内容自由编写，并可以使用空行分隔不同段落。\n在正文结束的一个空行之后，可以编写一行或多行脚注。每行脚注都必须包含 一个令牌（token），后面紧跟 :&lt;space&gt; 或 &lt;space&gt;# 作为分隔符，后面再紧跟令牌的值（受 git trailer convention 启发）。\n脚注的令牌必须使用 - 作为连字符，比如 Acked-by (这样有助于 区分脚注和多行正文)。有一种例外情况就是 BREAKING CHANGE，它可以被认为是一个令牌。\n脚注的值可以包含空格和换行，值的解析过程必须直到下一个脚注的令牌/分隔符出现为止。\n破坏性变更必须在提交信息中标记出来，要么在 &lt;类型&gt;(范围) 前缀中标记，要么作为脚注的一项。\n包含在脚注中时，破坏性变更必须包含大写的文本 BREAKING CHANGE，后面紧跟着冒号、空格，然后是描述，例如：BREAKING CHANGE: environment variables now take precedence over config files。\n包含在 &lt;类型&gt;(范围) 前缀时，破坏性变更必须通过把 ! 直接放在 : 前面标记出来。如果使用了 !，那么脚注中可以不写 BREAKING CHANGE:，同时提交信息的描述中应该用来描述破坏性变更。\n在提交说明中，可以使用 feat 和 fix 之外的类型，比如：docs: updated ref docs.。\n工具的实现必须不区分大小写地解析构成约定式提交的信息单元，只有 BREAKING CHANGE 必须是大写的。\nBREAKING-CHANGE 作为脚注的令牌时必须是 BREAKING CHANGE 的同义词。\n\n为什么使用约定式提交\n\n自动化生成 CHANGELOG。\n基于提交的类型，自动决定语义化的版本变更。\n向同事、公众与其他利益关系者传达变化的性质。\n触发构建和部署流程。\n让人们探索一个更加结构化的提交历史，以便降低对你的项目做出贡献的难度。\n\nFAQ\n在初始开发阶段我该如何处理提交说明？\n我们建议你按照假设你已发布了产品那样来处理。因为通常总 有人 使用你的软件，即便那是你软件开发的同事们。他们会希望知道诸如修复了什么、哪里不兼容等信息。\n提交标题中的类型是大写还是小写？\n大小写都可以，但最好是一致的。\n如果提交符合多种类型我该如何操作？\n回退并尽可能创建多次提交。约定式提交的好处之一是能够促使我们做出更有组织的提交和 PR。\n这不会阻碍快速开发和迭代吗？\n它阻碍的是以杂乱无章的方式快速前进。它助你能在横跨多个项目以及和多个贡献者协作时长期地快速演进。\n约定式提交会让开发者受限于提交的类型吗（因为他们会想着已提供的类型）？\n约定式提交鼓励我们更多地使用某些类型的提交，比如 fixes。除此之外，约定式提交的灵活性也允许你的团队使用自己的类型，并随着时间的推移更改这些类型。\n这和 SemVer 有什么关联呢？\nfix 类型提交应当对应到 PATCH 版本。feat 类型提交应该对应到 MINOR 版本。带有 BREAKING CHANGE 的提交不管类型如何，都应该对应到 MAJOR 版本。\n我对约定式提交做了形如 @jameswomack/conventional-commit-spec 的扩展，该如何版本化管理这些扩展呢？\n我们推荐使用 SemVer 来发布你对于这个规范的扩展（并鼓励你创建这些扩展！）\n如果我不小心使用了错误的提交类型，该怎么办呢？\n当你使用了在规范中但错误的类型时，例如将 feat 写成了 fix\n在合并或发布这个错误之前，我们建议使用 git rebase -i 来编辑提交历史。而在发布之后，根据你使用的工具和流程不同，会有不同的清理方案。\n当使用了 不在 规范中的类型时，例如将 feat 写成了 feet\n在最坏的场景下，即便提交没有满足约定式提交的规范，也不会是世界末日。这只意味着这个提交会被基于规范的工具错过而已。\n所有的贡献者都需要使用约定式提交规范吗？\n并不！如果你使用基于 squash 的 Git 工作流，主管维护者可以在合并时清理提交信息——这不会对普通提交者产生额外的负担。有种常见的工作流是让 git 系统自动从 pull request 中 squash 出提交，并向主管维护者提供一份表单，用以在合并时输入合适的 git 提交信息。\n约定式提交规范中如何处理还原（revert）提交？\n还原提交（Reverting）会比较复杂：你还原的是多个提交吗？如果你还原了一个功能模块，下次发布的应该是补丁吗？\n约定式提交不能明确的定义还原行为。所以我们把这个问题留给工具开发者，基于 类型 和 脚注 的灵活性来开发他们自己的还原处理逻辑。\n一种建议是使用 revert 类型，和一个指向被还原提交摘要的脚注：\nrevert: let us never again speak of the noodle incident\r\n\r\nRefs: 676104e, a215868\n\nReferences\n\nGit 提交规范\n"},"C知识宝库/Git":{"title":"Git","links":[],"tags":[],"content":"Git 手册\nPro Git 阅读笔记。\n起步\n\nGit 诞生于 2005 年，由 linus 编写。\nGit 是一个分布式系统。\nGit 保存文件的快照而非差异。\n\nGit 文件状态：\nuntracked &lt;--&gt; unmodified &lt;--&gt; modified &lt;--&gt; staged\n"},"C知识宝库/JWT":{"title":"JWT","links":[],"tags":[],"content":"JWT(JSON Web Token)"},"C知识宝库/Mumu模拟器":{"title":"Mumu模拟器","links":[],"tags":["TODO"],"content":"Mumu 模拟器\n\n开屏广告\n开屏广告目录 C:\\Users\\iFlygo\\AppData\\Roaming\\Netease\\MuMuPlayer-12.0\\data\\startupImage，禁止写入权限就可以屏蔽了。\n\n参考链接"},"C知识宝库/Obsidian":{"title":"Obsidian","links":[],"tags":["TODO","obsidian"],"content":"Obsidian\n\n参考链接"},"C知识宝库/SkipLists":{"title":"SkipLists","links":[],"tags":[],"content":"跳表\nSkipList(跳表) 这种数据结构是由_William Pugh_于 1990 年在在 Communications of the ACM June 1990, 33(6) 668-676 发表了_Skip lists: a probabilistic alternative to balanced trees_，在其中详细描述了他的工作。由论文标题可知，SkipList 的设计初衷是作为替换平衡树的一种选择。\n我们都知道，AVL 树有着严格的 O(\\log_2N) 的查询效率，但是由于插入过程中可能需要多次旋转，导致插入效率较低，因而才有了在工程界更加实用的红黑树。\n但是红黑树有一个问题就是在并发环境下使用不方便，比如需要更新数据时，Skip 需要更新的部分比较少，锁的东西也更少，而红黑树有个平衡的过程，在这个过程中会涉及到较多的节点，需要锁住更多的节点，从而降低了并发性能。\nSkipList 还有一个优势就是实现简单，SkipList 的实现只花了 2 个小时，而红黑树，我可能得 2 天。\n时隔将近三十多年，SkipList 这种数据结构仍在许多途径有用武之地，比如Redis, 还有 Google 的著名项目Bigtable."},"C知识宝库/名词":{"title":"名词","links":[],"tags":[],"content":"RDNS\n反向 DNS（rDNS 或 RDNS）是从 IP 地址查找域名的域名服务（DNS）。常规的 DNS 请求将解析给定域名的 IP 地址；因此名称为“reverse”。\n标量类型\n标量类型（Scalar type）是相对复合类型（Compound type）来说的：标量类型只能有一个值，而复合类型可以包含多个值。复合类型是由标量类型构成的。"},"C知识宝库/对数":{"title":"对数","links":[],"tags":["math","doc","TODO"],"content":"对数\n\n"},"C知识宝库/数学":{"title":"数学","links":[],"tags":[],"content":"指数\nX^AX^B = X^{A+B}\r\n\\frac{X^A}{X^B} = X^{A-B}"},"C知识宝库/数据结构":{"title":"数据结构","links":[],"tags":["TODO"],"content":"空间复杂度\n时间复杂度\n\n表\n形如 A_1,A_2,A_3,\\cdots,A_N 的表，我们说，这个表的大小是N。我们称大小为 0 的表为空表 (empty list)。\r\n对于除空表外的任何表，我们说A_{i+1}后继A_i(或继A_i之后) 并称A_{i-1}(i&lt;N) 前驱A_i(i&gt;1)。表中的第一个元素是A_1，最后一个元素是A_N。\n数组 Array\n数组就是一种线性表，物理结构为顺序存储，是大多数语言内置的基本数据类型。\n\n\n// 定义数据元素\ntypedef struct {\n\tint id;\n\tchar name[30];\n\tchar sex; // man-&gt;m, woman-&gt;w\n\tunsigned int age;\n} Node;\n \nNode array[5];\n优点\n\n构建非常简单\n能在 O(1) 的时间里根据数组的下标（index）查询某个元素\n\n缺点\n\n构建时必须分配一段连续的较大的空间，容易造成浪费\n查询某个元素是否存在时需要遍历整个数组，耗费 O(n) 的时间（其中，n 是元素的个数）\n删除和添加某个元素时，同样需要耗费 O(n) 的时间\n\n链表 Linked List\n链表是链式存储结构的线性表。\n\n单链表（singlelist）\n\nstruct Node {\n\tElementType data;\n\tstruct Node next;\n};\n \ntypedef struct Node *PtrNode;\ntypedef PtrNode List;\ntypedef PtrNode Position;\n \n双链表\n\n\n \n \n\n栈\nLast In First Out 先进先出\n栈是限定仅在表尾进行插入和删除操作的线性表。\n插入 → 入栈 → 压栈\r\n删除 → 出栈 → 弹栈\r\n\n\n队列\n队列是只能在一端进行插入操作，在另一端进行删除操作的线性表。\n\n串（字符串）string\n树 tree\n"},"C知识宝库/概率论/概率":{"title":"概率","links":[],"tags":["TODO"],"content":""},"C知识宝库/翻译积累":{"title":"翻译积累","links":[],"tags":[],"content":"翻译积累\n计算机\nout of memory(OOM) 内存不足\nparameters(形参)\narguments(实参)\nscope(作用域)\n论坛\noff-topic(OT) 跑题"},"C知识宝库/达芬奇剪辑":{"title":"达芬奇剪辑","links":[],"tags":[],"content":"快捷键\n剪辑\n\ni  o ：标记入点和出点\nF9 : 插入\n\n性能优化\n代理媒体\n\n替身\n媒体优化"},"E临时笔记/Bilibili福利社兑换":{"title":"Bilibili福利社兑换","links":[],"tags":[],"content":"return code:\r\n78107: ‘兑换中，权益将在5分钟内发放，若因库存不足等原因兑换失败将自动退还’,\r\n78113: ‘该手机号已被其他账号授权绑定，无法兑换，请切换账号重试’,\r\n78122: ‘您要兑换权益的手机号与注册手机号不一致，请重新绑定’,\r\n78125: ‘本月领取已达上限’,\r\n78126: ‘手机号非2233卡’,\r\n78127: ‘权益已发完，请明日再来’,\r\n78104: ‘福利点不足’,\r\n78117: ‘该手机号/账号本月已兑换福利点达上限’"},"E临时笔记/ESP32":{"title":"ESP32","links":[],"tags":["TODO"],"content":"ESP32\n\n\n\n"},"E临时笔记/KDE-6-体验报告":{"title":"KDE 6 体验报告","links":["A计科工程/主机运维/Linux/btrfs"],"tags":["TODO","linux","kde"],"content":"KDE 6 体验报告\n2024 年开春时，archlinux 的 KDE 6 发布，默认启用了 wayland. 曾经尝试过 KDE, 但是因为其多而杂的设置，\r\n最后弃之而选择了 sway. KDE 6 带来了很多特性和优化，考虑再三后，决定再一次尝试 KDE.\n\n备份\n为避免后续对 KDE 不满意，其配置文件污染我的目录，提前利用 btrfs 的特性备份系统。\n安装\n仅安装 plasma-meta 包，算是最小化安装了.\r\n既然选择使用 DE, 那就启用 SDDM 吧。\nsudo systemctl enable --now sddm.service\n配置\n\nKde 相关配置。1\nsddm 启用 wayland.2\n关闭 File Search 的索引。(Setting→Search→File Search)\n启用 Virtual Keyboard, 享受在 electron 应用输入中文的快感。(Setting→Keyboard→Virtual Keyboard)\n\n问题\n参考链接\nFootnotes\n\n\nwiki.archlinux.org/title/KDE ↩\n\n\nwiki.archlinux.org/title/SDDM#Running_under_Wayland ↩\n\n\n"},"E临时笔记/Linux-Kernel-参数":{"title":"Linux Kernel 参数","links":[],"tags":["TODO"],"content":"Linux Kernel 参数\n"},"E临时笔记/Obsidian":{"title":"Obsidian","links":[],"tags":[],"content":""},"E临时笔记/Rime":{"title":"Rime","links":[],"tags":["rime","fcitx5","linux"],"content":"Rime\n这是一个多平台的输入法引擎，可高度自定义。\n"},"E临时笔记/Wayland":{"title":"Wayland","links":[],"tags":["TODO"],"content":"Wayland 应用开发\n"},"E临时笔记/constraint":{"title":"constraint","links":[],"tags":[],"content":""},"E临时笔记/ffmpeg":{"title":"ffmpeg","links":[],"tags":["TODO","ffmpeg","video","audio"],"content":"ffmpeg\n\n查看视频信息\n分离音频\nffmpeg -i input.mp4 -vn -c:a copy output.aac\n-vn 是“no video”的缩写，表示在输出中排除视频流。_-c:a copy_ 表示音频编解码器（codec of audio）应该直接复制，不进行转码，这样可以加快处理速度。如果需要输出为 MP3 格式，可以将命令修改为 ffmpeg -i input.mp4 -vn -c:a mp3 output.mp3"},"E临时笔记/firefox":{"title":"firefox","links":[],"tags":["TODO"],"content":"FIREFOX\n\n美化\nFirefox 默认的主题在一些细节处让人有些不满，firefox-ui-fix 修复了这些问题。\nbash -c &quot;$(curl -fsSL raw.githubusercontent.com/black7375/Firefox-UI-Fix/master/install.sh)&quot;"},"E临时笔记/fish":{"title":"fish","links":[],"tags":[],"content":""},"E临时笔记/go":{"title":"go","links":[],"tags":[],"content":""},"E临时笔记/htop":{"title":"htop","links":[],"tags":["TODO","htop","linux","terminal"],"content":"HTOP\nHtop 是一款跨平台的终端交互式进程监视器。1\n\n界面介绍\n\nCPU2\n\n红色: kernel thread 占用，像是系統需要自動做 process scheduling、memory management 等等，是整個系統中最重要、優先權也最高的任務\n绿色: normal priority thread, 排程的優先權比 kernel thread 低一些，一般來說使用者執行的程式如果沒有特別調優先權的話，都會歸在這一類\n蓝色: low priority thread，因為優先權比較低，分配到的 CPU 自然也比較少，適合「我 ok，你先跑」那類比較無關緊要的 process，如果 CPU 已經被操到快不行了，或是 memory 真的不夠用了，第一個殺掉的也是這類 process\n\nMemory &amp; Swap\n参考链接\nFootnotes\n\n\ngithub.com/htop-dev/htop ↩\n\n\n你一定用過 htop，但你有看懂每個欄位嗎 ↩\n\n\n"},"E临时笔记/icat-develop":{"title":"icat-develop","links":[],"tags":["TODO","c","linux"],"content":"icat develop history\n\n性能分析\n\nicat:\n\nv0.1.0\n\nprintf → fputs\r\n\n‘show-ends’\r\n\n\n\ncat:\n\n\n\nuu-cat:\r\nv0.0.20\r\n\n\n"},"E临时笔记/iperf":{"title":"iperf","links":[],"tags":["TODO"],"content":"IPERF\nIperf 3 是一个 tcp, udp 和 sctp 网络带宽测量工具。\n\n用例\n参考链接"},"E临时笔记/irik":{"title":"irik","links":[],"tags":["TODO"],"content":"TODO\n\n媒体信息服务\n\n\n TMDB v3 api ✅ 2022-12-07\n douban api\n bangumi api\n\n\nJackett 服务接入\n下载器接入\n\n\n qBittorrent\n[ ]\n"},"E临时笔记/javascript笔记":{"title":"javascript笔记","links":[],"tags":["TODO"],"content":"JavaScript 学习笔记\n\n"},"E临时笔记/kvm":{"title":"kvm","links":[],"tags":[],"content":"KVM\nKVM(Kernel-based Virtual Machine)，是内建在 Linux Kernel 中的 hypervisor。相对于另一种开源虚拟化 Xen，\r\nKVM 更为简单和易用，并且和原生 QEMU 不同，KVM 通过一个内核模块使用 CPU 硬件扩展 (HVM) 来运行一个特殊运行模式的 QEMU。\n通过 KVM，可以在 Host 物理主机上运行多种无需修改的操作系统 (Linux, Windows, 甚至 macOS)，每个额虚拟机都有自己私有的\r\n虚拟硬件：网卡、磁盘、显卡等等。注意，KVM 和 Xen 不同之处是 KVM 是作为 Linux 的一部分，采用了常规的 Linux 调度和内存管理，\r\n所以更为小巧和易于使用。同时 KVM 仅支持 x86 hvm（vt/svm 指令集），不需要修改 Guest 操作系统，所以 KVM 并不支持\r\nparavirtualation for CPU，但是 KVM 为了提高 I/O 性能，支持 paravirtualization for device drivers（驱动半虚拟化）。\n准备工作"},"E临时笔记/qemu":{"title":"qemu","links":[],"tags":[],"content":"QEMU\nQEMU 是一款开源免费的物理机模拟器和虚拟器。更多介绍前往官网了解。www.qemu.org/\n安装\n \n使用\nqemu-system-x86_64 -enable-kvm -machine q35 \\\n                   -device intel-iommu -cpu host -smp 6 -m 8G \\\n                   -drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2-ovmf/x64/OVMF_CODE.fd \\\n                   -drive file=$HOME/KVM/ArchLinux.img,index=0,media=disk,if=virtio \\\n                   -vga none -device qxl-vga,vgamem_mb=256 -display egl-headless,gl=on \\\n                   -spice unix=on,addr=/run/user/1000/archlinux.spice.sock,disable-ticketing=on \\\n                   -device virtio-serial-pci \\\n                   -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 \\\n                   -chardev spicevmc,id=spicechannel0,name=vdagent\n \nqemu-system-x86_64 -enable-kvm -machine q35 \\\n                         -device intel-iommu -cpu host -smp 6 -m 8G \\\n                         -drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2-ovmf/x64/OVMF_CODE.fd \\\n                         -drive file=$HOME/KVM/ArchLinux.img \\\n                         -cdrom $HOME/Downloads/archlinux-2023.06.01-x86_64.iso -boot order=d \\\n                         -display egl-headless,gl=on,rendernode=/dev/dri/renderD128 \\\n                         -spice unix=on,addr=/run/user/1000/archlinux.spice.sock,disable-ticketing=on \\\n                         -device virtio-serial-pci \\\n                         -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 \\\n                         -chardev spicevmc,id=spicechannel0,name=vdagent\nqemu-system-x86_64 -enable-kvm -machine q35 \\\n                             -device intel-iommu -cpu host -smp 6 -m 8G \\\n                             -drive if=pflash,format=raw,readonly=on,file=/usr/share/edk2-ovmf/x64/OVMF_CODE.fd \\\n                             -drive file=$HOME/KVM/ArchLinux.img,index=0,media=disk,if=virtio \\\n                             -cdrom $HOME/Downloads/archlinux-2023.06.01-x86_64.iso -boot order=d \\\n                             -device virtio-vga-gl -display egl-headless,gl=on,rendernode=/dev/dri/renderD128 \\\n                             -spice unix=on,addr=/run/user/1000/archlinux.spice.sock,disable-ticketing=on \\\n                             -device virtio-serial-pci \\\n                             -device virtserialport,chardev=spicechannel0,name=com.redhat.spice.0 \\\n                             -chardev spicevmc,id=spicechannel0,name=vdagent\nvirt-viewer 连接 spice+unix:///run/user/1000/archlinux.spice.sock\nReferences\nwiki.qemu.org/Main_Page\r\nwiki.archlinux.org/title/QEMU"},"E临时笔记/strace":{"title":"strace","links":[],"tags":["TODO","linux"],"content":"strace\nstrace 常用来跟踪进程执行时的系统调用和所接收的信号。在 Linux 世界，进程不能直接访问硬件设备，当进程需要访问硬件设备 (比如读取磁盘文件，接收网络数据等等) 时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace 可以跟踪到一个进程产生的系统调用，包括参数，返回值，执行消耗的时间。\n"},"E临时笔记/swap":{"title":"swap","links":["G绘图文件/swap.excalidraw"],"tags":["TODO","Doc","swap","linux"],"content":"SWAP\nswap.excalidraw\n先说结论：\nzram：就只是内存压缩技术，可以将内存的一定区域用于压缩空间，从而具有更高的内存利用率。关机无法保存数据，如果你不希望使用休眠功能，都不需要设置什么swap分区，直接设置zram来使用。\nswap：这个东西叫交换空间，一般有两种形态，交换分区和交换文件，只用它的话平时打开大文件也有可能写入硬盘交换空间，也可以用来休眠，断电保存工作进度。\nzswap：zswap是一个内核功能，它为交换页提供了一个压缩的内存缓存。原本会交换到磁盘的页被压缩并存储到内存中的存储池中。与zram 相比的区别在于，zswap与swap 设备协同工作，而zram是内存中的交换设备，不需要后备交换设备。你既要休眠就的有swap，通过调整交换率可以做到，平时别老往swap写入数据，内存压缩解决了平时开机使用的需求，只在休眠的时候数据要存到硬盘里，简直是个完美的方案。\n我的终极方案是：采用btrfs+swapfile+zswap结合的方式。\n注意：zswap和zram二者不可共存，使用zram时一定要关闭zswap\n一.btrfs的swapfile启用：\n从内核版本5.0开始支持在btrfs分区使用交换文件作为swap形态\n从btrfs-progs 6.0版本之后才能通过自身磁盘工具命令来快速创建交换文件\n从systemd 255版本才支持休眠到btrfs下的交换文件，可用 systemctl --version查看，因此uos专业版版本为241不可以\n对于对硬盘使用没有过多要求的人实际上可以使用交换分区即可，因为即使是交换文件它也是固定占用空间的，只是具有一点灵活性，可以后期调整文件的大小。所以使用交换分区可以适应更多场景。\n否则参照从前的方法来创建：bbs.deepin.org/post/270299\n查询btrfs版本可以通过btrfs version 来查询，目前deepin23beta3是v6.3.2\nbtrfs version\nbtrfs-progs v6.3.2\n\n这里需要注意btrfs磁盘工具在创建和使用交换文件时，存在一些局限性：\nfilesystem - 只能是单个硬件分区中创建\nfilesystem - 必须只有单个数据配置文件\nsubvolume - 如果包含任何活动交换文件，则无法创建快照\nswapfile - 必须预先分配（即没有漏洞）\nswapfile - 必须是 NODATACOW（即也是 NODATASUM，无压缩）\n创建交换文件：\n这个过程在系统启动状态下即可配置，无需进入live环境，@swap为独立子卷，不可用于快照\n挂载父卷\nsudo mount /dev/sda2 /mnt\n创建 @swap子卷\nsudo btrfs subvolume create /mnt/@swap\n创建交换文件\nsudo btrfs filesystem mkswapfile --size 8G /mnt/@swap/swapfile\n输出：create swapfile /mnt/@swap/swapfile size 8.00GiB (8589934592)\n启用交换文件：\nsudo swapon /mnt/@swap/swapfile\n激活后，该文件将出现在 /proc/swaps 中：\n$ cat /proc/swaps\nFilename                 Type    Size       Used      Priority\n/mnt/@swap/swapfile      file    8388604    0         -2\n\n前面的设置是临时性启用交换文件，可以通过fstab永久启用\n编辑：sudo nano /etc/fstab 增加以下内容，uuid换成你的\n#将子卷@swap挂载到/swap,进一步把/swap/swapfile这个文件挂载到swap,这里的处理很多资料都没写具体\nUUID=0a79ef53-4ea9-4cdb-9b5e-5b7fb8ff0c64 /swap btrfs subvol=@swap 0 0\n/swap/swapfile none swap sw 0 0\n\n启用休眠到交换文件：\n启用交换文件后，交换文件可用于休眠，不过这可不简单，你即使看到deepin重启界面有休眠按钮了，但任然会出错，无法正常休眠，这里需要进一步设置\n在休眠之前，必须将恢复偏移量写入文件 /sys/power/resume_offset 该值是设备上的物理偏移量\nBtrfs文件系统使用逻辑和物理之间的映射地址，但在这里，物理仍然可以映射到一个或多个特定设备的物理块地址。这是特定设备的物理偏移量，适合作为恢复偏移。\n从btrfs-progs 6.1 版开始，有一个命令可以直接查询该偏移量，你说有些发行版不更新btrfs-progs像话吗？\n$ sudo btrfs inspect-internal map-swapfile /mnt/@swap/swapfile\nPhysical start: 183341248512\nResume offset:      44761047\n\n为了编写一些脚本和方便起见，选项 -r 将只打印偏移量，获得一个唯一输出：\n$ sudo btrfs inspect-internal map-swapfile -r /mnt/@swap/swapfile\n44761047\n\nsudo nano /sys/power/resume_offset\n写入：44761047这个值保存即可\n非btrfs文件系统的情形可以使用如下命令获得偏移量值,btrfs使用该命令是不准确的：\nsudo filefrag -v /swap/swapfile\n取图中这个位置的值即可\n\n但是上面这个文件重启就会失效，如何永久固化呢？\n重点来了，使将以下参数加入到两个地方\nsudo nano /etc/initramfs-tools/conf.d/resume\n写入：resume=UUID=0a79ef53-4ea9-4cdb-9b5e-5b7fb8ff0c64 resume_offset=44761047\n\n刷新配置 \nsudo update-initramfs -c -k all\n\nsudo nano /etc/default/grub\nGRUB_CMDLINE_LINUX_DEFAULT=&quot;splash quiet resume=UUID=0a79ef53-4ea9-4cdb-9b5e-5b7fb8ff0c64 resume_offset=44761047&quot;\n\n刷新配置\nsudo update-grub\n\n二.zswap的应用：\n关闭 zswap\nsudo sh -c &#039;echo 0 &gt; /sys/module/zswap/parameters/enabled&#039;\n开启 zswap\nsudo sh -c &#039;echo 1 &gt; /sys/module/zswap/parameters/enabled&#039;\n\nzswap参数设置：\nzswap 有几个可自定义的参数。可以使用以下方式显示实时设置\n$ grep -R . /sys/module/zswap/parameters\n/sys/module/zswap/parameters/same_filled_pages_enabled:Y\n/sys/module/zswap/parameters/enabled:Y\n/sys/module/zswap/parameters/max_pool_percent:20\n/sys/module/zswap/parameters/compressor:zstd\n/sys/module/zswap/parameters/zpool:z3fold\n/sys/module/zswap/parameters/accept_threshold_percent:90\n\n其它参数参考 docs.kernel.org/admin-guide/mm/zswap.html\n每个设置都可以在运行时通过 sysfs 接口进行更改。作为示例，要更改 compressor 参数\nsudo echo zstd &gt; /sys/module/zswap/parameters/compressor\n使用内核引导参数持久化更改：\nzswap.enabled=1 zswap.compressor=zstd zswap.max_pool_percent=20 zswap.zpool=z3fold\n比较简单的方式是通过grub引导时传递内核参数：\nsudo nano /etc/default/grub\nGRUB_CMDLINE_LINUX_DEFAULT=&quot;splash quiet 跟着加到这里面 zswap.compressor=zstd zswap.enabled=1&quot;\n\n之后 sudo update-grub即可\n同时我们还需要把压缩工具等放到内核模块里写入\nsudo nano /etc/initramfs-tools/modules\n#写入\nzstd\nzatd_compress\nz3fold\n\n执行 sudo update-initramfs -c -k all\n交换值(Swappiness)\n你可以通过此命令查看当前的交换值，deepin/uos都被预设为10，而默认值应为60，Swappiness 的值可以是 0 到 200 之间 (在Linux内核版本低于5.8时最大值为100)\nsysctl vm.swappiness\n\n你可以在内存占用的环境下通过临时改变交换值来观察测试。\nsysctl -w vm.swappiness=10\n\n最终通过写入文件参数来永久生效\n文件由sysctl.d管理，按顺序的优先级生效，我这里挖出deepin/uos在最低优先级路径做了相关配置\n/etc/sysctl.conf\n/etc/sysctl.d/*.conf\n/run/sysctl.d/*.conf\n/usr/local/lib/sysctl.d/*.conf\n/usr/lib/sysctl.d/*.conf\n\n查看deepin/uos相关配置\nsudo nano /usr/lib/sysctl.d/deepin.conf\n#这个参数用于控制交换值，数字越小则优先使用内存，减少内存的交换，从而提升一些系统上的响应度；\nvm.swappiness=10\n#这个参数控制内核回收 VFS 缓存的程度，增大数值会增加回收 VFS 缓存的频率，最好不要让文件系统太过于疲劳控制在50以下\nvm.vfs_cache_pressure=40\n\n使更改生效\nsudo sysctl -p\n重点阐述： swappiness此参数控制用于定义内核相对于页面缓存和其他缓存换出匿名内存的积极程度。增加该值会增加交换量。默认值为 60。\n减小该值则优先使用内存，减少内存对swap的交换，从而提升一些系统上的响应度，适合需要内存快速响应的这类工作，对内存占用不敏感的人群。这类人群可以适当划出一部分内存做zram，将 swappiness值设为几乎为0，swap将只用于休眠。\n增大 swappiness值，将提升交换的积极性，毕竟是写入硬盘，I/O性能会相比内存会降低，内存将大部分用于实际的工作，而swap则用于存放缓存数据，这种配置方法则适合常常使用虚拟机、常常编辑几万行xls文件、常常浏览器开20个标签以上的用户。这类用户不太注重io的及时性，而更在乎能稳定持续的工作不会卡死，建议为swap分区划分更多的空间，对于服务器最好不要交换swap业务稳定最重要，性能最重要，对于个人PC机默认的60可能是个好事。\n因此 swappiness值是权衡之下的结果，找到自己的平衡点最重要！\n请注意，换出的数据越多，系统在需要时换回数据所需的时间就越长。\n三.内存压缩的启用\n我的终极方案说完了，下面说说zram在debian系里的启用，由于大多数内核默认开启了zswap的配置，要启用zram请设置内核参数 zswap.enabled=0来禁用zswap\nzram-tools 或者 systemd-zram-generator 软件包可用于自动设置 zram 设备,uos专业版本有zram-tools而deepin有后者systemd-zram-generator\nuos的方式：\n安装zram-tools并启动相应服务：\nsudo apt install zram-tools\n默认情况下，zRAM使用的压缩算法是lzo，如果想使用其他算法或修改zRAM的大小，我们可以修改配置文件/etc/default/zramswap\nsudo nano /etc/default/zramswap\n#压缩算法选择,注意系统必须安装这些压缩工具\n#压缩速度：lz4 &gt; zstd &gt; lzo\n#压缩率：zstd &gt; lzo &gt; lz4\nALGO=zstd\n#指定用于zram的RAM量，基于可用内存总量的百分比，这优先并覆盖下面的SIZE\nSIZEPERCENT=70\n#指定应该用于的静态RAM量单位MiB中，如果上面设置了百分比，这条将不生效，也可以注释掉\nSIZE=8192\n#指定交换设备的优先级，数字越大=优先级越高，这应该高于硬盘swaps的优先级\nPRIORITY=100\n#建立几个zram设备，默认cpu内核几个就创建几个，以此控制数量\n#CORES=1\n\n配置好以上参数启用服务即可：\nsudo service zramswap reload\n可以通过以下命令查看当前用于swap的zram\nswapon -s\ndeepin的方式：\n先安装\nsudo apt install systemd-zram-generator\n修改配置文件\n/etc/systemd/zram-generator.conf\n写入：\n[zram0]\ncompression-algorithm = zstd\nzram-size = ram / 2\nswap-priority = 100\n\n这里创建了一个使用zstd压缩、大小为所有可用内存容量一半的zram swap 设备（ram/2表示大小为 RAM大小的1/2；也可以设置为4Ｇ、512M这样的值）\n详细扩展参数看：github.com/systemd/zram-generator\n启用服务：\nsystemctl daemon-reload\nsystemctl start /dev/zram0\n\n调用 zramctl 或 swapon 以确认设备已创建并正在使用中。\n$zramct\nlNAME       ALGORITHM DISKSIZE DATA COMPR TOTAL STREAMS MOUNTPOINT\n/dev/zram0 lzo-rle       4.8G   4K   80B   12K       4[SWAP]\n\n注意：在动完磁盘和相关操作重启之前一定要更新一下initramfs\nsudo update-initramfs -c -k all\n\n\n以上代表了我个人对此方案的最终理解，不使用btrfs的伙伴也一样可以搞起，举一反三！\n参考\n\nwiki.archlinux.org/title/Swap\n"},"E临时笔记/systemd-networkd":{"title":"systemd-networkd","links":[],"tags":["TODO"],"content":"systemd-networkd\n"},"E临时笔记/texlive":{"title":"texlive","links":[],"tags":["TODO","arch"],"content":"texlive 安装\n\nArch 官方源\n# 基本包\nsudo pacman -S texlive-core\n \n# 无脑安装\nsudo pacman -S texlive-most\n \n# 中文支持\nsudo pacman -S texlive-langchinese\n其他\n默认 TeX Live 的字体是不自动给 Fontconfig 提供字体的，因此若想让 XeTeX 之类的使用他们，需要参考 Arch Wiki 上的方法作符号链接。这里以中文环境默认的字体 Fandol 为例：\nln -s /usr/share/texmf-dist/fonts/opentype/public/fandol ~/.fonts/OTF/\nfc-cache ~/.fonts\nmkfontscale ~/.fonts/OTF\nmkfontdir ~/.fonts/OTF\n这样 fc-list | grep Fandol 应该就能找到这个字体了。\n但此时去编译中文字体的话，默认的 pdf 查看器却依然无法看到汉字，而 Chrome 却能正常显示中文。最后再安装如下包：\nsudo pacman -S poppler-data\n汉字就可以正常在 evince 之类的默认 pdf 查看器中正常显示了。"},"E临时笔记/truncate":{"title":"truncate","links":[],"tags":["TODO","linux"],"content":"truncate\n\n参考\n\ngnu coreutils-truncate\n"},"E临时笔记/wine":{"title":"wine","links":[],"tags":["TODO","wine"],"content":"WINE\n"},"E临时笔记/zram":{"title":"zram","links":[],"tags":[],"content":"ZRAM\nzram 是一个 Linux 内核模块，可以用来创建最高 5:1 压缩率的基于 RAM 的块设备。\r\nzram 从内存中分出一块区域，使用压缩算法可以增加数据的容量。"},"E临时笔记/回调函数":{"title":"回调函数","links":[],"tags":["TODO"],"content":"回调函数\n\n在计算机程序设计中，回调函数，或简称回调（Callback 即 call then back 被主函数调用运算后会返回主函数），是指通过参数 将函数传递到其它代码的，某一块可执行代码的引用。这一设计允许了底层代码调用在高层定义的子程序。\n\n下列C 语言代码描述了利用回调处理POSIX风格的信号（在本示例中为SIGUSR1）的过程。值得注意的是，在处理信号的过程中，调用printf(3)是不安全的。\n#include &lt;stdio.h&gt;\n#include &lt;signal.h&gt;\n#include &lt;unistd.h&gt;\n \nvoid sig(int signum)\n{\n        printf(&quot;Received signal number %d!\\n&quot;, signum);\n}\n \nint main(int argc, char *argv[])\n{\n        signal(SIGUSR1, sig);\n \n        pause();\n \n        return 0;\n}\n系统调用pause(3)会导致这个例子不做任何有意义的事，但这样做可以给你充分的时间来给这个进程发送信号。（在类 Unix 系统上，可以调用kill -USR1 **&lt;pid&gt;**，其中**&lt;pid&gt;**代表该程序的进程号。运行之后，该程序应当会有反应。）"},"E临时笔记/文件读写":{"title":"文件读写","links":[],"tags":["TODO"],"content":"C 文件处理\n对于文件的处理不外乎读和写两种基本操作。\r\nC 语言 stdio.h 头文件包含处理文件的相关函数。\n这些函数处理的对象都是文件流（FILE），fopen、fclose 是\r\n用来创建和关闭流的函数。\n读"},"E临时笔记/计算机网络":{"title":"计算机网络","links":[],"tags":["TODO","net"],"content":"计算机网络\n\n网络基础\n\n全双工通信：可同时发送和接收的通信方式。\n半双工通信：只发送或只接收的通信方式。"},"G绘图文件/Drawing-2024-10-09-05.01.56.excalidraw":{"title":"Drawing 2024-10-09 05.01.56.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nDrawing\nN4IgLgngDgpiBcIYA8DGBDANgSwCYCd0B3EAGhADcZ8BnbAewDsEAmcm+gV31TkQAswYKDXgB6MQHNsYfpwBGAOlT0AtmIBeNCtlQbs6RmPry6uA4wC0KDDgLFLUTJ2lH8MTDHQ0YNMWHRJMRZFAFZFAAYyJE9VGEYwGgQAbQBdcnQoKABlALA+UEl8PGzsDT5GTkxMch0YIgAhdFQAayKuRlwAYXpMenwEEABiADMx8ZAAX0mgA\n%%"},"G绘图文件/Drawing-2024-11-05-12.32.21.excalidraw":{"title":"Drawing 2024-11-05 12.32.21.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements\nt/ns \np/100% "},"G绘图文件/Linux-Lancher.excalidraw":{"title":"Linux Lancher.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nText Elements\nItem List 1 \nInput Box \nRadius "},"G绘图文件/MVC.excalidraw":{"title":"MVC.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements\nModel \nView \nController "},"G绘图文件/calculator":{"title":"calculator","links":[],"tags":["excalidraw"],"content":"⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nText Elements\nstring \nstart \nis string\r\nvalid \nno \nyes \nstring → num + sign \ncalculate \noutput result \ncontinue \nend \nyes \nno "},"G绘图文件/iptables":{"title":"iptables","links":[],"tags":["excalidraw"],"content":"⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nText Elements\n网卡 \n内核空间 \n用户空间 "},"G绘图文件/nastools":{"title":"nastools","links":[],"tags":["excalidraw"],"content":"⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nText Elements\n开始 \n环境检查 \n关键词搜索 \n处理关键词 \nWeb \n媒体搜索 \n普通搜索 \nTMDB\r\n信息搜索 \n索引器搜索 \n信息过滤 \n返回\r\n影视\r\n列表 \nUI 选择 \n关键词 \n剧集信息匹配 \nBT 下载器 \n读取配置信息 \n服务启动 "},"G绘图文件/swap.excalidraw":{"title":"swap.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements\nRam \nzswap \nram \nBacking store \ncompress \nwhen zswap is full \ndecompress \nBacking store \nzram \n压缩，充当块设备 "},"G绘图文件/内存池结构图.excalidraw":{"title":"内存池结构图.excalidraw","links":[],"tags":["excalidraw"],"content":"⚠  Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: ‘Decompress current Excalidraw file’. For more info check in plugin settings under ‘Saving’\nExcalidraw Data\nText Elements"},"G绘图文件/数据结构":{"title":"数据结构","links":[],"tags":["excalidraw"],"content":"⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠\nText Elements\n表 \n0 \n1 \nN "},"H其他文件/PPT/Lua教程":{"title":"Lua Tutorial","links":[],"tags":[],"content":"Lua\n\nLua 特性\n\nLua 语法\n\n变量与类型\nLua 是一种动态类型语言\n\n变量\n变量的默认值均为nil;\nLua 中有三类变量：全局变量，局部变量，table 的域;\nLua 中的变量全为全局变量，除非用local显示声明为局部变量。\n\n\n    table {\n        font-size: 10px;\n    }\n    thead {\n        font-size: 12px;\n}\n\n类型\nLua 中有八种基本类型：nil, boolean, number, string, function, userdata, thread, table\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n数据类型描述nil只有唯一值 nilboolean布尔值：false, true(false 和 nil 是唯二的 false, 其他都为 true)numberlua 只有一种数字类型：doublestring字符串由一对双引号和单引号表示tablelua 中表其实是一个”关联数组”, 数组的索引可以是数字或者字符串，创建空表 m = {}function函数是被看作是”第一类值（First-Class Value）“，函数可以存在变量里threaduserdata用户自定义数据，用于表示一种由应用程序或 C/C++ 语言库所创建的类型\n\n循环\n重复执行一组语句\n循环类型\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n循环类型描述whileforrepeat…until\n循环控制：\n\nbreak: 退出当前循环\ngoto: 将程序的控制点转移到一个标签处\n"},"H其他文件/PPT/demo":{"title":"demo","links":[],"tags":[],"content":"\nMarp\nMarkdown Presentation Ecosystem\nmarp.app/\n\nHow to write slides\nSplit pages by horizontal ruler (---). It’s very simple! :satisfied:\n# Slide 1\n \nfoobar\n \n---\n \n# Slide 2\n \nfoobar"},"index":{"title":"学海无涯苦作舟","links":["代办列表","项目记录","娱乐记录","学习记录","阅读记录","常用工具"],"tags":[],"content":"一个人至少拥有一个梦想，有一个理由去坚强。心若没有栖息的地方，到哪里都是在流浪。——《我的青春谁做主》\n\n\n代办列表\n项目记录\n娱乐记录\n学习记录\n阅读记录\n常用工具\n"},"tags/TODO":{"title":"TODO","links":[],"tags":[],"content":""},"tags/linux":{"title":"Linux","links":[],"tags":[],"content":""},"代办列表":{"title":"代办列表","links":["A计科工程/isync"],"tags":["TODO"],"content":"TODO\n编程\n\n isync 项目发布 v 0.1.0 🛫 2024-06-13\n"},"娱乐记录":{"title":"娱乐记录","links":[],"tags":["TODO"],"content":"娱乐记录\n\n动漫\n\n[/] 灵能百分百\n 最后的召唤师 Bilibili\n\n\n电影\n\n 我的天才女友\n\n\n阅读\n\n[/] 赘婿 笔趣阁\n[/] 吞噬星空 笔趣阁\n"},"学习记录":{"title":"学习记录","links":["Just-in-Time-Learning"],"tags":[],"content":"学习记录\n学习哲学\n\nJust in Time Learning\nPro Git 中文版（第二版）\n"},"常用工具":{"title":"常用工具","links":[],"tags":[],"content":"网页小工具\n\n程序员快速参考清单\n"},"阅读记录":{"title":"阅读记录","links":[],"tags":[],"content":"TABLE 书名, 作者, 类别, 状态\nFROM &quot;F阅读娱乐/阅读&quot;\n影视"},"项目记录":{"title":"项目记录","links":["E临时笔记/irik","A计科工程/主机运维/Scrapy"],"tags":[],"content":"个人项目\nirik\n媒体影音自动化程序，个人 NAS 的自动化助手。\n个人博客设计\n\n 使用 赫蹏 美化排版。\n\nSimpleDNS\n编写一个简单的 DNS 服务器。\n目的\n\n 熟悉语言。\n 学习 DNS 的技术细节。\n\nBilibili 用户数据爬虫\n使用 Scrapy 编写 Bilibili 用户数据爬虫。\n目的\n\n 熟练 Python 语法\n 学习 Scrapy 使用\n 熟悉 SQL 语法与应用\n 用户数据分析\n\nCMD 聊天软件\n命令行翻译\n\n\n                  \n                  命令行翻译 \n                  \n                \n\n\n 熟练 Python 语法\n 学习 Scrapy 使用\n 熟悉 SQL 语法与应用\n 用户数据分析\n\n\n"}}